/*
    Returns NM API Version
    NM API Version: 1
*/
query nm_api_version() = 7;

/*
    Returns version of peerlist
    NM API Version: 1
    Deprecated since version 5:  is not relevant for multi-cluster environment
*/
query nm_get_peer_list_version() = node_list.last_update;

/*
    Returns peer info list
    NM API Version: 1
    (API expects array, so we need suppress naming)
*/
query nm_get_peer_infos() = node @* {} (_ = .host, _ = .port, _ = .pubkey, _ = .last_updated);

/*
    Returns last built height of the blockchain
    NM API Version: 4
    Deprecated: relies on legacy anchoring which will be removed
*/
query nm_get_blockchain_last_built_height(blockchain_rid: byte_array) =
    deprecated_get_blockchain_last_height(blockchain_rid);

/*
    Configuration updates are found in two tables. Both must be checked to get next configuration height.
    NM API Version: 1
*/
query nm_find_next_configuration_height(blockchain_rid: byte_array, height: integer): integer? {
    val bc = blockchain @? { blockchain_rid };
    if (bc == null) return null;
    val conf_h = blockchain_configuration @? { bc, .height > height } (@sort .height) limit 1;
    val sign_h = blockchain_configuration_signers @? { bc, .height > height } (@sort .height) limit 1;
    if (conf_h == null) return sign_h;
    if (sign_h == null) return conf_h;
    return min(conf_h, sign_h);
}

/*
    Merge content of blockchain_configuration and blockchain_configuration_signers
    NM API Version: 1
*/
query nm_get_blockchain_configuration(blockchain_rid: byte_array, height: integer): byte_array? {
    val bc = require_blockchain(blockchain_rid);
    // Find configuration height -- the latest height up to given height.
    // If conf_h exist, so does signer_h, thus no need to check both.
    val base_config = blockchain_configuration @? { bc, .height <= height } (@omit @sort_desc .height, $) limit 1;
    if (base_config != null) {
        // Checking that signers.size() is non-zero is done when population blockchain_configuration_signers.
        val signers = require(blockchain_configuration_signers @? { bc, .height <= height } (@omit @sort_desc .height, .signers) limit 1,
            "No signers configuration for blockchain %s for height %d".format(blockchain_rid, height));

        val full_config = map<text, gtv>.from_gtv(gtv.from_bytes(base_config.data));
        full_config["signers"] = gtv.from_bytes(signers);
        return full_config.to_gtv().to_bytes();
    } else {
        return null;
    }
}

/*
    NM API Version: 5
*/
query nm_get_blockchain_configuration_v5(blockchain_rid: byte_array, height: integer):
        (base_config: byte_array, signers: list<pubkey>, config_hash: byte_array)? {
    val bc = require_blockchain(blockchain_rid, include_removed = true);
    // Find configuration height -- the latest height up to given height.
    // If conf_h exist, so does signer_h, thus no need to check both.
    val base_config = blockchain_configuration @? { bc, .height <= height } (@omit @sort_desc .height, .data) limit 1;
    if (base_config != null) {
        // Checking that signers.size() is non-zero is done when population blockchain_configuration_signers.
        val signers = require(blockchain_configuration_signers @? { bc, .height <= height } (@omit @sort_desc .height, .signers) limit 1,
            "No signers configuration for blockchain %s for height %d".format(blockchain_rid, height));
        val full_config = map<text, gtv>.from_gtv(gtv.from_bytes(base_config));
        full_config["signers"] = gtv.from_bytes(signers);
        return (
            base_config = base_config,
            signers = list<pubkey>.from_gtv(gtv.from_bytes(signers)),
            config_hash = full_config.to_gtv().hash()
        );
    } else {
        return null;
    }
}

/*
    Returns list of blockchains to be launched
    NM API Version: 1 (Deprecated: Use nm_compute_blockchain_info_list)
*/
query nm_compute_blockchain_list(node_id: pubkey): list<byte_array> {
    val res = list<byte_array>();
    for (blockchain in compute_blockchain_info_list(node_id)) {
        res.add(blockchain.rid);
    }
    return res;
}

/*
    Returns list of blockchains to be launched
    NM API Version: 4
*/
query nm_compute_blockchain_info_list(node_id: pubkey): list<blockchain_info> {
    return compute_blockchain_info_list(node_id);
}

function compute_blockchain_info_list(node_id: pubkey): list<blockchain_info> {
    val node = node @? { node_id };
    if (exists(node)) {
        val res = set<blockchain_info>();
        res.add_all(get_cluster_node_blockchains(node));
        res.add_all(get_cluster_replica_node_blockchains(node));
        res.add_all(get_blockchains_replicated_by_node(node));
        return list(res);
    } else {
        return [blockchain_info(chain_context.blockchain_rid, true, blockchain_state.RUNNING)];
    }
}

/*
    NM API Version: 4
*/
query nm_get_blockchain_replica_node_map(blockchain_rids: set<byte_array>): map<byte_array, set<byte_array>> {
    val res = map<byte_array, set<byte_array>>();
    for (brid in set(blockchain_rids)) {
        res.put(brid, get_blockchain_replica_nodes(brid));
    }
    return res;
}

/*
    Function used by  mustSyncUntil (height) pos-146
    NM API Version: 2
    Deprecated: relies on legacy anchoring which will be removed
*/
query nm_get_blockchain_last_height_map(blockchain_rids: list<byte_array>) : list<integer> {
    val res = list<integer>();
    for (brid in blockchain_rids) {
        if (empty(blockchain @? { brid })) {
            res.add(-1);
        } else {
            res.add(deprecated_get_blockchain_last_height(brid));
        }
    }
    return res;
}

/*
    NM API Version: 3
*/
query nm_get_container_limits(name): map<text, integer> {
    var return_map = map<text, integer>();

    val container_limits = get_current_container_resource_limits(name);

    val container_units = container_limits[container_resource_limit_type.container_units];
    val max_blockchains = container_limits[container_resource_limit_type.max_blockchains];

    val cpu = _get_container_limit_or_default(standard_container_unit.cpu, container_units);
    val ram = _get_container_limit_or_default(standard_container_unit.ram, container_units);
    val io_read = _get_container_limit_or_default(standard_container_unit.io_read, container_units);
    val io_write = _get_container_limit_or_default(standard_container_unit.io_write, container_units);
    val storage = _get_container_limit_or_default(standard_container_unit.storage, container_units);

    return_map.put("max_blockchains", max_blockchains);
    return_map.put("storage", storage);
    return_map.put("cpu", cpu);
    return_map.put("ram", ram);
    return_map.put("io_read", io_read);
    return_map.put("io_write", io_write);

    return return_map;
}

function _get_container_limit_or_default(value: integer, container_units: integer): integer {
    return if (container_units == -1 or value == -1) -1 else container_units * value;
}

/*
    Returns node containers
    NM API Version: 3
*/
query nm_get_containers(pubkey): list<text> {
    val clusters = cluster_node @* { node @ { pubkey } } .cluster;
    val res = list<text>();
    for (cl in clusters) {
        val containers = container @* { cl } .name;
        res.add_all(containers);
    }
    return res;
}

/*
    NM API Version: 3
*/
query nm_get_blockchains_for_container(container_name: text): list<byte_array> {
    val container = container @? {container_name};
    val res = list<byte_array>();
    if (exists(container)) {
        val cluster = container.cluster;
        res.add_all(container_blockchain @* {container, .blockchain.state in [blockchain_state.RUNNING, blockchain_state.PAUSED]} .blockchain.rid);
    }
    return res;
}

/*
    NM API Version: 3
*/
query nm_get_container_for_blockchain(blockchain_rid: byte_array): text {
    val bc = require_blockchain(blockchain_rid);
    return container_blockchain @ { bc } .container.name;
}

/*
    Returns a list of brids with corresponding container that this blockchain is dependent on. At the given height.
    NM API Version: 3
*/
query nm_get_blockchain_dependencies(blockchain, height: integer): list<(byte_array, text)> {
    val res = list<(byte_array, text)>();
    val conf_h = blockchain_configuration @? { blockchain, .height <= height }
            (@sort .height) limit 1;
    if (conf_h != null) {
        val brids = blockchain_dependency @* {.me == blockchain, conf_h} .dependent_on.rid;
        for (brid in brids) {
            res.add((brid, container_blockchain @ { blockchain @{brid}} .container.name));
        }
    }
    return res;
}

/*
    Precise Configuration Update: Returns list of pending configs with minimum_height <= height
    NM API Version: 5
*/
query nm_get_pending_blockchain_configuration(blockchain_rid: byte_array, height: integer):
        list<(base_config: byte_array, signers: list<pubkey>, minimum_height: integer)> {
    if (not pcu_enabled()) return list();
    val bc = require_blockchain(blockchain_rid);
    return pending_blockchain_configuration @* { bc, .minimum_height <= height } (
        base_config = .base_config,
        signers = list<pubkey>.from_gtv(gtv.from_bytes(.signers)),
        @sort minimum_height = .minimum_height
    );
}

/*
    Precise Configuration Update: Returns a pending blockchain config by config hash or null
    NM API Version: 5
*/
query nm_get_pending_blockchain_configuration_by_hash(blockchain_rid: byte_array, config_hash: byte_array):
        (base_config: byte_array, signers: list<pubkey>, minimum_height: integer)? {
    if (not pcu_enabled()) return null;
    val bc = require_blockchain(blockchain_rid, include_removed = true);
    return pending_blockchain_configuration @? { bc, config_hash } (
        base_config = .base_config,
        signers = list<pubkey>.from_gtv(gtv.from_bytes(.signers)),
        @sort minimum_height = .minimum_height
    );
}

/*
    Precise Configuration Update: Returns a faulty blockchain config by height or null
    NM API Version: 5
*/
query nm_get_faulty_blockchain_configuration(blockchain_rid: byte_array, height: integer): byte_array? {
    val bc = require_blockchain(blockchain_rid);
    return faulty_blockchain_configuration @? { bc, .reported_at_height == height }.config_hash;
}

/*
    Returns current state of blockchain
    NM API Version: 6
*/
query nm_get_blockchain_state(blockchain_rid: byte_array): text {
    val bc = require_blockchain(blockchain_rid, false, true);
    return bc.state.name;
}

/*
    Returns Blockchain RID of management chain
    NM API Version: 7
*/
query nm_get_management_chain() = blockchain @ { blockchains.c0 } (.rid);
