function _staking_cannot_change_before(): timestamp = _staking_last_known_time() + chain_context.args.staking_rate_change_delay_ms;

// As per https://learn.chromia.com/courses/latest-known-time
function _staking_last_known_time() 
    = if (op_context.exists) op_context.last_block_time else block @ {} (@max .timestamp) ?: 0;

function _pay_to(staker: ft4.accounts.account, amount: integer) {
    // We pay from the same pool account as provider rewards
    ft4.assets.Unsafe.transfer(get_pool_account(), staker, get_asset(), amount);
}

// As approach suggested by https://chromadev.zulipchat.com/#narrow/stream/316358-Protocols/topic/Little.20questions/near/421469052
val NULL_ACCOUNT_ID = "NULL".hash();
function get_null_provider_account() {
    // Relies on code that runs at initialisation
    val ft4_null = ft4.accounts.account @ { NULL_ACCOUNT_ID };
    val provider_null = provider @ {.pubkey == NULL_ACCOUNT_ID};
    return provider_account @ { .account == ft4_null };
}

function _staking_pubkey_to_provider(pubkey) {
    val provider_account = provider_account @? {.provider.pubkey == pubkey};
    require(provider_account, "No provider for this public key.");
    require(_staking_is_active_provider(provider_account), "Must be active provider.");
    return provider_account;
}
