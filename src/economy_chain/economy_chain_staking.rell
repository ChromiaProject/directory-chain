@extend(remove_provider_handler) function(pubkey) = _staking_offboard_provider(pubkey);

// It might be better for this to live in a table
enum network {
    BSC, ETH, CHR
}

entity staker_withdrawal_request {
    key request_finish: timestamp, staker_state;
    mutable active: boolean;
}

entity staker_state {
    key ft4.accounts.account, network;
    mutable provider;
    mutable balance: integer;
    mutable last_update: timestamp;
    mutable pending_token_time: integer;
}

@log
entity reward_rate {
    rate: decimal;
}

operation staking_deposit_native(amount: integer, delegateTo: pubkey? = null) {
    require(amount > 0, "Can't deposit nothing (or less)!");

    val staker = ft4.auth.authenticate();

    // Pull in the CHR
    require(amount < get_account_balance(staker), "Insufficent funds to deposit.");
    ft4.assets.Unsafe.transfer(staker, get_deposit_account(), get_asset(), amount);

    val _provider = provider @? { .pubkey == delegateTo };

    val ss = staker_state @? { .account == staker and .network == network.CHR };
    if (exists(ss)) {
        _update_pending_token_time(ss);
        ss.balance += amount;
        if (exists(_provider)) ss.provider = _provider;
    } else {
        require(_provider, "Must delegate to a provider");
        create staker_state (
            staker,
            network.CHR,
            _provider,
            balance = amount,
            last_update = _staking_last_known_time(),
            pending_token_time = 0
        );
    }
}

function _update_pending_token_time(staker_state) {
    staker_state.pending_token_time = staker_state.balance * (_staking_last_known_time() - staker_state.last_update);
    staker_state.last_update = _staking_last_known_time();
}

function _staking_claim_rewards() {
    var payout_list = map<ft4.accounts.account, integer>();
    var total_amount = 0;
    val rate = staking_get_current_rate() / millis_per_year;

    // Get a list of payouts
    for (staker in staker_state @* {}) {
        _update_pending_token_time(staker);
        val token_reward = integer(staker.pending_token_time * rate);
        staker.pending_token_time = 0;
        payout_list.put(staker.account, token_reward + (payout_list.get_or_null(staker.account) ?: 0));
        total_amount += token_reward;
    }

    // Do not start what we cannot finish
    if (get_account_balance(get_pool_account()) < total_amount) {
        log("Cannot pay rewards. Insufficient funds.");
        return;
    }

    // Do the payouts
    for (staker in payout_list.keys()) {
        val amount = payout_list.get(staker);
        ft4.assets.Unsafe.transfer(get_pool_account(), staker, get_asset(), amount);
        log("Paid out %s to %s", staker, amount);
    }
}

operation staking_request_withdrawal() {
    val staker = ft4.auth.authenticate();
    val ss = staker_state @? { .account == staker and .network == network.CHR };
    require(ss, "No staker state for %s".format(staker));

    val active_withdraw_request = staker_withdrawal_request @? { ss, .active };
    require(not exists(active_withdraw_request), "Only one withdrawal request allowed at a time");
    require(ss.balance > 0, "Balance must be over 0");

    _staking_delegate(staker, get_null_account());

    // Make a new request
    create staker_withdrawal_request (
        request_finish = _staking_last_known_time()+86400*7,
        ss,
        true
    );
}

function _staking_delegate(staker: ft4.accounts.account, provider_pubkey: pubkey) {
    val staker_states = staker_state @* { .account == staker };
    val withdraw_requests = staker_withdrawal_request @* { .active and .staker_state in staker_states };

    // deactivate chromia withdraw requests
    val withdraw_requests_chr = withdraw_requests @ { .staker_state.network == network.CHR };
    update withdraw_requests_chr ( .active = false );

    val staker_states_to_exclude = withdraw_requests @* { .staker_state.network != network.CHR } ( .staker_state );

    val new_provider = provider @ { provider_pubkey };

    // Update appropriate staker states with new provider
    val staker_states_to_update = staker_states @* { $ not in staker_states_to_exclude };
    update staker_states_to_update ( .provider = new_provider );
}

function get_null_account(): pubkey {
    return "NULL".hash();
}

function _staking_last_known_time() 
    = if (op_context.exists) op_context.last_block_time else block @ { } ( @max .timestamp ) ?: 0;

query staking_get_current_rate(): decimal {
    val current_rate = reward_rate @ { } ( .rate, @omit @sort_desc .transaction.block.timestamp ) limit 1;
    return current_rate;
}

function _staking_withdraw_all() {
    val open_withdrawals = staker_withdrawal_request @* {
        .active and .staker_state.network == network.CHR and .request_finish < _staking_last_known_time()
    } ( ss = .staker_state, account = .staker_state.account, balance = .staker_state.balance );

    for (withdrawal in open_withdrawals) {
        // Send the balance back to them through ft4
        ft4.assets.Unsafe.transfer(
                get_deposit_account(),
                withdrawal.account,
                get_asset(),
                withdrawal.balance
            );
        withdrawal.ss.balance = 0;
    }
}
