val NO_ONE : pubkey = x'';

entity staker_balance {
    time: timestamp;
    staker: pubkey;
    amount: integer;
    mutable latest: boolean;
    index staker;
    key time, staker;
}

entity staker_withdrawal_request {
    time: timestamp;
    staker: pubkey;
    mutable used: boolean;
    index staker;
    key time, staker;
}

entity provider_registration {
    time: timestamp;
    provider: pubkey;
    name: text;
    mutable active: boolean;
    index provider;
    key time, provider;
}

entity staker_delegation {
    delegate: pubkey;
    time: timestamp;
    cutover_time: timestamp;
    new_provider: pubkey;
    old_provider: pubkey;
    mutable latest: boolean;
    index delegate;
    key time, delegate;
}

entity reward_rate {
    time: timestamp;
    delegator_rate: decimal;
    provider_rate: decimal;
    key time;
}

object staking_config {
    rate_change_delay_ms: integer = 7 * 8600 * 1000;
    withdrawal_delay_ms: integer = 14 * 8600 * 1000;
}

operation staking_set_rates_at(delegator_rate: decimal, provider_rate: decimal, time: timestamp) {
   _staking_set_rates_at(delegator_rate, provider_rate, time);
}

function _staking_set_rates_at(delegator_rate: decimal, provider_rate: decimal, time: timestamp) {
    require(time >= _staking_cannot_change_before(), "Cannot change rate before " + _staking_cannot_change_before());
    create reward_rate(time, delegator_rate, provider_rate);
}

operation staking_set_rates(delegator_rate: decimal, provider_rate: decimal) {
   _staking_set_rates_at(delegator_rate, provider_rate, _staking_cannot_change_before());
}

operation staking_deposit(staker: pubkey, amount: integer) {
    require(amount > 0, "Can't deposit nothing (or less)!");
    // TODO Probably should take some chr from them now!
    val existing = staking_get_balance(staker);
    update staker_balance @? { .staker==staker and .latest==true } ( latest=false );
    create staker_balance(time=_staking_last_known_time(), staker=staker, amount=amount + existing, latest=true);
}

function staking_get_balance(staker: pubkey) = staker_balance @? { .staker == staker and .latest==true } (.amount) ?: 0;

operation staking_request_withdrawal(staker: pubkey) {
    require(staking_get_balance(staker) > 0, "Need something to withdraw.");
    require(NO_ONE == staking_get_current_delegate(staker), "Must undelegate before requesting a withdrawal.");
    require(null == staking_get_withdrawal_time(staker), "Only one withdrawal request at a time.");

    // Make a new request
    require(_staking_last_known_time() > 0, "Require an actual time");
    create staker_withdrawal_request(time=_staking_last_known_time(), staker=staker, false);
}

operation staking_withdraw(staker: pubkey) {
    val withdrawal_time = staking_get_withdrawal_time(staker);
    require(withdrawal_time, "Need a withdrawal request.");
    require(_staking_last_known_time() >= withdrawal_time, "Need to wait for withdrawal request.");
    // TODO Send the balance back to them through ft4 somehow
    update staker_balance @? { .staker==staker and .latest==true } ( latest=false );
    create staker_balance(time=_staking_last_known_time(), staker=staker, amount=0, latest=true);
    update staker_withdrawal_request @ {.staker == staker } (used = true );
}

query staking_get_withdrawal_time(staker: pubkey) : timestamp? {
    val valid_request = staker_withdrawal_request @? {.staker == staker and .used == false};
    return if (null != valid_request) valid_request.time + staking_config.withdrawal_delay_ms else null;
}

query staking_is_active_provider(provider : pubkey) : boolean {
    val provider_registration = provider_registration @? {.provider == provider} (.active, @omit @sort_desc .rowid) limit 1;
    return provider_registration ?: false;
}

query staking_get_total_delegation_to(provider : pubkey) : integer {
    return
        // Join deposit and delegation information 
        (d: staker_delegation, b: staker_balance) @ {
            // consider only the latest entries
            d.latest == true and b.latest ==true
            // joined on delegate
            and d.delegate == b.staker
            // restricted to those currently on this provider according to the cut off date
            and (
                ( d.new_provider == provider and d.cutover_time <= _staking_last_known_time() )
                or
                ( d.old_provider == provider and d.cutover_time > _staking_last_known_time() )
            )
        } (
            // sum the balances
            @sum b.amount
        )
    ;
}

query staking_rewards_earned_for(_pubkey : pubkey) : integer = 0;
query staking_rewards_collected_for(_pubkey : pubkey) : integer = 0;
query staking_rewards_claimable_for(_pubkey : pubkey) : integer = 0;

operation staking_add_provider(name : text, provider : pubkey) {
    require(not staking_is_active_provider(provider), "Provider cannot be active.");
    create provider_registration(_staking_last_known_time(), provider, name, true);
}

operation staking_remove_provider(provider : pubkey) {
    require(staking_is_active_provider(provider), "Provider not active.");

    // Unwind delegations immediately
    for (removed_delegation in staker_delegation @* {.provider == provider} (@group .delegate)) {
        if (staking_get_current_delegate(removed_delegation) == provider)
            create staker_delegation(delegate = removed_delegation, time=staking_get_last_known_time(), provider = NO_ONE);
    }

    val name = provider_registration @ { .provider == provider } ( .name );
    create provider_registration(_staking_last_known_time(), provider, name, false);
}

operation staking_delegate(staker : pubkey, provider: pubkey) {
    require(staking_is_active_provider(provider), "Must be active provider.");
    require(staking_get_balance(staker) > 0, "Must have a stake to delegate.");

    // Clear any withdrawal request
    delete staker_withdrawal_request @? {.used == false and .staker == staker};

    _staking_delegate(staker, provider);
}

operation staking_undelegate(delegator : pubkey) {
    _staking_delegate(delegator, NO_ONE);
}

function _staking_delegate(delegator : pubkey, provider: pubkey) {
    require(staking_get_balance(delegator) > 0, "Need a stake to delegate.");

    // Get the value before messing with the flag
    val current_delegation = staking_get_current_delegate(delegator);

    // Clear flag from previous
    update staker_delegation @? {.delegate == delegator and .latest == true} (latest = false);

    // New delegation record
    create staker_delegation(
        delegate = delegator,
        time = staking_get_last_known_time(),
        cutover_time = _staking_cannot_change_before(),
        new_provider = provider,
        old_provider = current_delegation,
        latest = true
    );
}

operation staking_claim_rewards() {}

query staking_get_current_rate() : (decimal, decimal) {
    val current_rate = reward_rate @ {
        .time <= _staking_last_known_time()
    } (
        .delegator_rate, .provider_rate, @sort_desc .time
    ) limit 1;
    val delegator_rate = current_rate.delegator_rate;
    val provider_rate = current_rate.provider_rate;
    return (delegator_rate, provider_rate);
}

query staking_get_current_delegate(delegate : pubkey) : pubkey {
    val current_delegation = staker_delegation @? { .delegate == delegate and .latest == true };
    return
        if  (null == current_delegation) NO_ONE
    else if ( staking_get_last_known_time() >= current_delegation.cutover_time ) current_delegation.new_provider
    else    current_delegation.old_provider;
}

function _staking_cannot_change_before() : timestamp = _staking_last_known_time() + staking_config.rate_change_delay_ms;

query staking_get_cannot_change_before() : timestamp = _staking_cannot_change_before();

// As per https://learn.chromia.com/courses/latest-known-time
function _staking_last_known_time() 
    = if (op_context.exists) op_context.last_block_time else block @ {} (@max .timestamp) ?: 0;

query staking_get_last_known_time() = _staking_last_known_time();
