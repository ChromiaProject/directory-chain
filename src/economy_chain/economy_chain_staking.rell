@extend(remove_provider_handler)
function(
    provider_account
) = _staking_offboard_provider(
    provider_account
        .provider
        .pubkey
);

@extend(after_pay_reward)
function(pay_reward_result) = _staking_shared_rewards(pay_reward_result);

// It might be better for this to live in a table
enum network {
    BSC, ETH, CHR
}

object _staking_state {
    mutable last_reward_distribution: integer = 0;
    mutable last_withdrawal_distribution: integer = 0;
}

entity staker_withdrawal_request {
    index finish_at: timestamp;
    index staker_state;
    index mutable active: boolean;
}

entity staker_state {
    key ft4.accounts.account, network;
    mutable balance: integer;
    mutable last_update: timestamp;
    mutable pending_token_time: integer;
}

entity staker_state_to_provider {
    index timestamp;
    index staker_state;
    provider;
}

entity reward_rate {
    index timestamp;
    rate: decimal;
}

function __staking_begin_block(height: integer) {
    if (
        (_staking_last_known_time() - _staking_state.last_reward_distribution) > chain_context.args.staking_payout_interval_ms
    ) {
        _staking_distribute_rewards();
        _staking_state.last_reward_distribution = _staking_last_known_time();
    }
    if (
        (_staking_last_known_time() - _staking_state.last_withdrawal_distribution) > chain_context.args.staking_withdrawal_delay_ms
    ) {
        _staking_distribute_withdrawals();
        _staking_state.last_withdrawal_distribution = _staking_last_known_time();
    }
}

operation staking_claim_rewards() {
    require_admin();
    _staking_distribute_rewards();
}
function __staking_init() {
    _staking_set_rate_at(chain_context.args.staking_initial_reward_rate, _staking_last_known_time());
    create provider ( get_null_account(), system = true, provider_tier.NODE_PROVIDER, active = true );
}

operation staking_set_rate(rate: decimal) {
    require_admin();
    _staking_set_rate_at(rate, _staking_last_known_time() + chain_context.args.staking_rate_change_delay_ms);
}

operation staking_set_rate_at(rate: decimal, timestamp: timestamp) {
    require_admin();
    val change_at = _staking_last_known_time() + chain_context.args.staking_rate_change_delay_ms;
    require(timestamp >= change_at, "Cannot change rate before " + change_at);
    _staking_set_rate_at(rate, timestamp);
}

function _staking_set_rate_at(rate: decimal, timestamp: timestamp) {
    create reward_rate ( rate = rate, timestamp = timestamp );
}


@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
        scope = "staking_deposit_native",
        flags = ["T"],
        message = staking_deposit_auth_message(*)
    );

function staking_deposit_auth_message(gtv): text {
    val args = struct<staking_deposit_native>.from_gtv(gtv);

    return "Please sign the message\nto transfer %s %s from account {account_id} \nto deposit account.".format(
        ft4.assets.format_amount_with_decimals(args.amount, chain_context.args.asset_decimals),
        chain_context.args.asset_symbol
    );
}
operation staking_deposit_native(amount: integer, delegateTo: pubkey? = null) {
    require(amount > 0, "Can't deposit nothing (or less)!");

    val staker = ft4.auth.authenticate();

    // Pull in the CHR
    require(amount < get_account_balance(staker), "Insufficent funds to deposit.");
    ft4.assets.Unsafe.transfer(staker, get_deposit_account(), get_asset(), amount);


    var ss = staker_state @? { .account == staker and .network == network.CHR };
    if (exists(ss)) {
        _update_pending_token_time(ss);
        ss.balance += amount;
    } else {
        ss = create staker_state (
            staker,
            network.CHR,
            balance = amount,
            last_update = _staking_last_known_time(),
            pending_token_time = 0
        );
    }
    if (delegateTo != null) {
        val _provider = provider @ { .pubkey == delegateTo };

        create staker_state_to_provider (
            timestamp = _staking_last_known_time(),
            ss,
            _provider
        );
    }
}

function _staking_update_evm_state(staker: ft4.accounts.account, network, new_balance: integer) {
    var ss = staker_state @? { .account == staker and .network == network };
    if (exists(ss)) {
        _update_pending_token_time(ss);
        ss.balance = new_balance;
    } else {
        val _provider = provider @ { .pubkey == get_null_account() };
        ss = create staker_state (
            staker,
            network,
            balance = new_balance,
            last_update = _staking_last_known_time(),
            pending_token_time = 0
        );
        create staker_state_to_provider ( timestamp = _staking_last_known_time(), ss, _provider );
    }
}


function _update_pending_token_time(staker_state) {
    update staker_state (
        pending_token_time = .balance * (_staking_last_known_time() - .last_update),
        last_update = _staking_last_known_time()
    );
}

function _update_pending_token_time_all() {
    update staker_state @* { } (
        pending_token_time = .balance * (_staking_last_known_time() - .last_update),
        last_update = _staking_last_known_time()
    );
}

function _staking_distribute_rewards() {
    var total_amount = 0;
    val rate = staking_get_current_rate() / millis_per_year;

    // Get a list of payouts
    _update_pending_token_time_all();
    val rewards = staker_state @* { } (
        @group account = .account,
        @sum amount = integer (
            (
            .pending_token_time
        ) * rate
        )
    );
    for (reward in rewards) {
        total_amount += reward.amount;
    }

    // Do not start what we cannot finish
    if (get_account_balance(get_pool_account()) < total_amount) {
        log("Cannot pay rewards. Insufficient funds.");
        return;
    }
    update staker_state @* { } ( .pending_token_time = 0 );

    // Do the payouts
    for ((account,amount) in rewards) {
        ft4.assets.Unsafe.transfer(get_pool_account(), account, get_asset(), amount);
        log("Paid out %s to %s", account, amount);
    }
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
        scope = "staking_request_withdrawal",
        flags = [],
        message = staking_request_withdrawal_auth_message(*)
    );

function staking_request_withdrawal_auth_message(gtv): text {
    val args = struct<staking_request_withdrawal>.from_gtv(gtv);
    return "Please sign the message to request a withdrawal.";
}

operation staking_request_withdrawal() {
    val user = ft4.auth.authenticate();
    _staking_request_withdrawal(user, network.CHR);
}

function _staking_request_withdrawal(user: ft4.accounts.account, _network: network) {
    val ss = staker_state @? { .account == user and .network == _network };
    require(ss, "No staker state for %s".format(user.id));

    val active_withdraw_request = staker_withdrawal_request @? {
        ss,
        .active
    };

    if (_network == network.CHR) {
        require(not exists(active_withdraw_request), "Only one withdrawal request allowed at a time");
    }
    require(ss.balance > 0, "Balance must be over 0");

    _staking_delegate(user, get_null_account());

    // Make a new request
    create staker_withdrawal_request (
        finish_at = _staking_last_known_time() + chain_context.args.staking_rate_change_delay_ms,
        ss,
        true
    );
}

function _staking_delegate(staker: ft4.accounts.account, provider_pubkey: pubkey) {
    // get all staker states of user, and all related withdraw requests
    val staker_states = staker_state @* { .account == staker };
    val withdraw_requests = staker_withdrawal_request @* { .active and .staker_state in staker_states };

    // deactivate chromia withdraw requests
    val withdraw_requests_chr = withdraw_requests @* { .staker_state.network == network.CHR };
    update withdraw_requests_chr ( .active = false );

    val staker_states_to_exclude = withdraw_requests @* { .staker_state.network != network.CHR } ( .staker_state );

    val new_provider = require(provider @? { provider_pubkey }, "No provider for this public key.");

    // Update appropriate staker states with new provider
    val staker_states_to_update = staker_states @* {
        $ not in staker_states_to_exclude
    } (
        struct<staker_state_to_provider> (
            timestamp = _staking_last_known_time(),
            staker_state = $,
            provider = new_provider
        )
    );

    create staker_state_to_provider ( staker_states_to_update );
}

function get_null_account(): pubkey {
    return "NULL".hash();
}

function _staking_last_known_time() 
    = if (op_context.exists) op_context.last_block_time else block @ { } ( @max .timestamp ) ?: 0;


query staking_get_current_rate(): decimal {
    val current_rate = reward_rate @* {
        .timestamp<=_staking_last_known_time()
    } (
        .rate,
        @omit @sort_desc .timestamp
    ) limit 1;
    return current_rate[0];
}

function _staking_distribute_withdrawals() {
    val open_withdrawals = staker_withdrawal_request @* {
        .active and .staker_state.network == network.CHR and .finish_at <= _staking_last_known_time()
    } ( account = .staker_state.account, balance = .staker_state.balance );

    for (withdrawal in open_withdrawals) {
        // Send the balance back to them through ft4
        ft4.assets.Unsafe.transfer(
                get_deposit_account(),
                withdrawal.account,
                get_asset(),
                withdrawal.balance
            );
    }

    var staker_states = staker_withdrawal_request @* {
        .active and .staker_state.network == network.CHR and .finish_at <= _staking_last_known_time( )
    } ( .staker_state );
    update staker_states ( .balance = 0 );
    update staker_withdrawal_request @* {
        .active and .staker_state.network == network.CHR and .finish_at <= _staking_last_known_time( )
    } ( .active = false);
    
}

function _staking_offboard_provider(pubkey) {
    val null_provider = provider @ { get_null_account() };

    // Update appropriate staker states with new provider TODO FIX THIS
    val updated_relationships = staker_state_to_provider @* { .provider.pubkey == pubkey } (
        struct<staker_state_to_provider> (
            timestamp = _staking_last_known_time(),
            staker_state = .staker_state,
            provider = null_provider
        )
    );

    create staker_state_to_provider ( updated_relationships );
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
        scope = "staking_delegate",
        flags = [],
        message = staking_delegate_auth_message(*)
    );

function staking_delegate_auth_message(gtv): text {
    val args = struct<staking_delegate>.from_gtv(gtv);
    // TODO Indicate which provider?
    return "Please sign the message to set the provider.";
}
operation staking_delegate(pubkey) {
    val new_provider = require(provider @? { pubkey }, "No provider for this public key.");
    val staker = ft4.auth.authenticate();
    _staking_delegate(staker, pubkey);
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
        scope = "staking_undelegate",
        flags = [],
        message = staking_undelegate_auth_message(*)
    );

function staking_undelegate_auth_message(gtv): text {
    val args = struct<staking_undelegate>.from_gtv(gtv);
    return "Please sign the message to undelegate.";
}

operation staking_undelegate() {
    val staker = ft4.auth.authenticate();
    _staking_delegate(staker, get_null_account());
}
query staking_get_current_delegate_on_network(account_id: byte_array, network): byte_array? {
    val _provider_pubkey = staker_state_to_provider @? {
        .staker_state.account.id == account_id and .staker_state.network == network and  
        (_staking_last_known_time() - chain_context.args.staking_rate_change_delay_ms) >= .timestamp
    } ( @omit @sort_desc .timestamp, .provider.pubkey ) limit 1;
    return if (_provider_pubkey == get_null_account()) null else _provider_pubkey;
}

query staking_get_current_delegate(
    account_id: byte_array
) = staking_get_current_delegate_on_network(account_id, network.CHR);

query staking_get_balance(
    account_id: byte_array
) = staker_state @ { 
    .account.id == account_id 
} ( 
    @sum .balance 
) limit 1;

query staking_get_total_delegation_to(pubkey, network? = null) {
    return ( s1: staker_state_to_provider) @* {
        .provider.pubkey == pubkey and (s1.timestamp<=(_staking_last_known_time()-chain_context.args.staking_rate_change_delay_ms)) and 
            (not exists(network) or .staker_state.network == network) and 
            not exists((s2:staker_state_to_provider) @* { 
                s2.staker_state ==s1.staker_state,
                ((s2.timestamp<=(_staking_last_known_time()-chain_context.args.staking_rate_change_delay_ms)) and (s2.timestamp>s1.timestamp)) 
                or (s2.timestamp==s1.timestamp and s2 < s1) 
            }
        )
    } ( @sum .staker_state.balance )[0];
}

// TODO Canncel withdrawal
// @extend(ft4.auth.auth_handler)
// function () = ft4.auth.add_auth_handler(
//     scope = "staking_cancel_withdrawal",
//     flags = [],
//     message = staking_cancel_withdrawal_auth_message(*)
// );

// function staking_cancel_withdrawal_auth_message(gtv): text {
//     val args = struct<staking_cancel_withdrawal>.from_gtv(gtv);
//     return "Please sign the message to cancel withdrawal.";
// }

query staking_get_cannot_change_before(): timestamp = _staking_last_known_time() + chain_context
    .args
    .staking_rate_change_delay_ms;

query staking_rewards_claimable_for(account_id: byte_array) {
    val rate = staking_get_current_rate() / millis_per_year;
    val staker = ft4.accounts.Account(account_id);
    val ss = staker_state @* { .account == staker } ( .balance, .last_update, .pending_token_time );
    var total_pending_token_time = 0;
    for (s in ss) {
        total_pending_token_time += s.pending_token_time + s.balance * (_staking_last_known_time() - s.last_update);
    }
    return integer(total_pending_token_time * rate);
}

query staking_get_next_delegation_change(account_id: byte_array): (pubkey: pubkey, time: integer)? {
    val staker = ft4.accounts.Account(account_id);
    val upcoming_delegations = staker_state_to_provider @* {
        .staker_state.account == staker and .timestamp > (_staking_last_known_time()-chain_context.args.staking_rate_change_delay_ms)
    } (
        @omit @sort_desc .timestamp,
        pubkey = .provider.pubkey,
        time = .timestamp + chain_context.args.staking_rate_change_delay_ms
    ) limit 1;
    return if (exists(
        upcoming_delegations
    )) (upcoming_delegations[0]) else null;
}

query staking_get_withdrawal_time(account_id: byte_array, network = network.CHR): timestamp? {
    return staker_withdrawal_request @? {
        .staker_state.account.id == account_id and .active and .staker_state.network == network
    } (
        .finish_at
    );
}

function _staking_shared_rewards(pay_reward_result) {
    // We ignore reward debt here as it will flow through the reward term after the pool is refreshed
    val total_shared_reward = chain_context.args.rewards_share * pay_reward_result.payed_reward;

    // Find provider pubkey
    val provider_pubkey = provider_account @? { pay_reward_result.payed_to }.provider.pubkey;

    // In some edge cases during testing a public key may be absent
    if (empty(provider_pubkey)) {
        log("Not provider public key for id: %s".format(pay_reward_result.payed_to.id));
        return;
    }
    val staker_delegations = ( s1: staker_state_to_provider) @* {
        .provider.pubkey == provider_pubkey and not exists(
            (s2:staker_state_to_provider) @* { 
                s2.staker_state ==s1.staker_state,
                (s2.timestamp>s1.timestamp) or 
                (s2.timestamp==s1.timestamp and s2 < s1) 
            }
        )
    } ( @group account = .staker_state.account, @sum balance = .staker_state.balance );
    // Get total and divide through
    val total_delegation = staker_delegations @* { } ( @sum .balance )[0];
    // Zero delegation check (should not occur in normal useage.)
    if (total_delegation == 0) return;
    // Run through and payout by share of delegation
    for (staker in staker_delegations) {
        val share_amount = integer(total_shared_reward * (staker.balance / total_delegation));

        ft4.assets.Unsafe.transfer(get_pool_account(), staker.account, get_asset(), share_amount);
        log(
            "Paid reward share of %s to %s. Based on a delegation of %s CHR."
                .format(
                    share_amount,
                    staker
                        .account
                        .id,
                    staker
                        .balance
                )
        );
    }
}

query staking_total_stake() = staker_state @* { } ( @sum .balance )[0];

query staking_total_accounts() = staker_state @* { } ( @sum 1 )[0];
