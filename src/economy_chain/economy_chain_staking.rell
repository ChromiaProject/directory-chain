@extend(remove_provider_handler) function(pubkey) = _staking_offboard_provider(pubkey);

// It might be better for this to live in a table
enum network {
    BSC, ETH, CHR
}

object _staking_state {
    mutable last_update: integer = 0;
}
entity staker_withdrawal_request {
    index finish_at: timestamp;
    index staker_state;
    index mutable active: boolean;
}

entity provider_change_request {
    index finish_at: timestamp;
    index staker_state;
    index mutable active: boolean;
    provider;
}

entity staker_state {
    key ft4.accounts.account, network;
    mutable provider;
    mutable balance: integer;
    mutable last_update: timestamp;
    mutable pending_token_time: integer;
}

@log
entity reward_rate {
    rate: decimal;
}

function __staking_begin_block(height: integer) {
    val week = integer(_staking_last_known_time() / (604800000));
    if (week > _staking_state.last_update) {
        _staking_distribute_rewards();
        _staking_distribute_withdrawals();
    }
}


operation staking_deposit_native(amount: integer, delegateTo: pubkey? = null) {
    require(amount > 0, "Can't deposit nothing (or less)!");

    val staker = ft4.auth.authenticate();

    // Pull in the CHR
    require(amount < get_account_balance(staker), "Insufficent funds to deposit.");
    ft4.assets.Unsafe.transfer(staker, get_deposit_account(), get_asset(), amount);

    val _provider = provider @? { .pubkey == delegateTo };

    val ss = staker_state @? { .account == staker and .network == network.CHR };
    if (exists(ss)) {
        _update_pending_token_time(ss);
        ss.balance += amount;
        if (exists(_provider)) ss.provider = _provider;
    } else {
        require(_provider, "Must delegate to a provider");
        create staker_state (
            staker,
            network.CHR,
            _provider,
            balance = amount,
            last_update = _staking_last_known_time(),
            pending_token_time = 0
        );
    }
}

function _staking_update_evm_state(staker: ft4.accounts.account, network, new_balance: integer) {
    val ss = staker_state @? { .account == staker and .network == network };
    if (exists(ss)) {
        _update_pending_token_time(ss);
        ss.balance = new_balance;
    } else {
        val _provider = provider @ { .pubkey == get_null_account() };
        create staker_state (
            staker,
            network,
            _provider,
            balance = new_balance,
            last_update = _staking_last_known_time(),
            pending_token_time = 0
        );
    }
}


function _update_pending_token_time(staker_state) {
    update staker_state (
        pending_token_time = .balance * (_staking_last_known_time() - .last_update),
        last_update = _staking_last_known_time()
    );
}

function _update_pending_token_time_all() {
    update staker_state @* { } (
        pending_token_time = .balance * (_staking_last_known_time() - .last_update),
        last_update = _staking_last_known_time()
    );
}

function _staking_distribute_rewards() {
    var payout_list = map<ft4.accounts.account, integer>();
    var total_amount = 0;
    val rate = staking_get_current_rate() / millis_per_year;

    // Get a list of payouts
    _update_pending_token_time_all();
    val rewards = staker_state @* { } ( account = .account, amount = integer (.pending_token_time * rate) );
    for (reward in rewards) {
        total_amount += reward.amount;
    }

    // Do not start what we cannot finish
    if (get_account_balance(get_pool_account()) < total_amount) {
        log("Cannot pay rewards. Insufficient funds.");
        return;
    }
    update staker_state @* { } ( .pending_token_time = 0 );

    // Do the payouts
    for ((account,amount) in rewards) {
        ft4.assets.Unsafe.transfer(get_pool_account(), account, get_asset(), amount);
        log("Paid out %s to %s", account, amount);
    }
}

operation staking_request_withdrawal() {
    val staker = ft4.auth.authenticate();
    val ss = staker_state @? { .account == staker and .network == network.CHR };
    require(ss, "No staker state for %s".format(staker));

    val active_withdraw_request = staker_withdrawal_request @? { ss, .active };
    require(not exists(active_withdraw_request), "Only one withdrawal request allowed at a time");
    require(ss.balance > 0, "Balance must be over 0");

    _staking_delegate(staker, get_null_account());

    // Make a new request
    create staker_withdrawal_request (
        finish_at = _staking_last_known_time()+86400*7,
        ss,
        true
    );
}

function _staking_delegate(staker: ft4.accounts.account, provider_pubkey: pubkey) {
    val staker_states = staker_state @* { .account == staker };
    val withdraw_requests = staker_withdrawal_request @* { .active and .staker_state in staker_states };

    // deactivate chromia withdraw requests
    val withdraw_requests_chr = withdraw_requests @ { .staker_state.network == network.CHR };
    update withdraw_requests_chr ( .active = false );

    val staker_states_to_exclude = withdraw_requests @* { .staker_state.network != network.CHR } ( .staker_state );

    val new_provider = provider @ { provider_pubkey };

    // Update appropriate staker states with new provider
    val staker_states_to_update = staker_states @* { $ not in staker_states_to_exclude };
    update staker_states_to_update ( .provider = new_provider );
}

function get_null_account(): pubkey {
    return "NULL".hash();
}

function _staking_last_known_time() 
    = if (op_context.exists) op_context.last_block_time else block @ { } ( @max .timestamp ) ?: 0;

query staking_get_current_rate(): decimal {
    val current_rate = reward_rate @ { } ( .rate, @omit @sort_desc .transaction.block.timestamp ) limit 1;
    return current_rate;
}

function _staking_distribute_withdrawals() {
    val open_withdrawals = staker_withdrawal_request @* {
        .active and .staker_state.network == network.CHR and .finish_at < _staking_last_known_time()
    } ( account = .staker_state.account, balance = .staker_state.balance );

    for (withdrawal in open_withdrawals) {
        // Send the balance back to them through ft4
        ft4.assets.Unsafe.transfer(
                get_deposit_account(),
                withdrawal.account,
                get_asset(),
                withdrawal.balance
            );
    }
    update staker_withdrawal_request @* {
        .active and .staker_state.network == network.CHR and .finish_at < _staking_last_known_time()
    } ( .active = false );
}
