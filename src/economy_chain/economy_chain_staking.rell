@extend(remove_provider_handler) function(pubkey) = _staking_offboard_provider(pubkey);

namespace ft4 {
    import lib.ft4.accounts;
    import lib.ft4.assets;
    import lib.ft4.auth;
}
import lib.auth;

entity staker_withdrawal_request {
    staker_withdrawal_request_time: timestamp;
    staker: ft4.accounts.account;
    mutable used: boolean;
    index staker;
    key staker_withdrawal_request_time, staker;
}

entity staker_payout {
    staker_payout_time: timestamp;
    key staker_payout_time;
}

entity staker_state {
    staker_state_time: timestamp;
    previous_staker_state_time: timestamp; // We have no look-back windowing functions
    staker: ft4.accounts.account;
    cutover_time: timestamp;
    new_provider: pubkey;
    old_provider: pubkey;

    // Native balances
    balance_native: integer;
    previous_balance_native: integer;

    // BSC balances
    balance_bsc: integer;
    previous_balance_bsc: integer;

    // Ethereum Mainnet balances
    balance_eth: integer;
    previous_balance_eth: integer;

    mutable latest: boolean; // We have no windowing functions, and want to group by other fields

    index staker;
}

struct staker_state_delta {
    cutover_time: timestamp?;
    new_provider: pubkey?;
    old_provider: pubkey?;
    balance_native: integer?;
    balance_bsc: integer?;
    balance_eth: integer?;
}

entity reward_rate {
    reward_rate_time: timestamp;
    reward_rate: decimal;
    key reward_rate_time;
}

function __staking_init() {
   _staking_set_rate_at(chain_context.args.staking_initial_reward_rate, _staking_last_known_time());
}

operation staking_set_rate_at(reward_rate: decimal, provider_rate: decimal, time: timestamp) {
    require_initialized();
    require_admin();
    require(time >= _staking_cannot_change_before(), "Cannot change rate before " + _staking_cannot_change_before());
   _staking_set_rate_at(reward_rate, time);
}

function _staking_set_rate_at(reward_rate: decimal, time: timestamp) {
    create reward_rate(time, reward_rate);
}

operation staking_set_rate(reward_rate: decimal) {
    require_admin();
   _staking_set_rate_at(reward_rate, _staking_cannot_change_before());
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "staking_deposit_native",
    flags = ["T"],
    message = staking_deposit_auth_message(*)
);

function staking_deposit_auth_message(gtv): text {
    val args = struct<staking_deposit_native>.from_gtv(gtv);

    return "Please sign the message\nto transfer %s %s from account {account_id} \nto deposit account.".format(
        ft4.assets.format_amount_with_decimals(args.amount, chain_context.args.asset_decimals),
        chain_context.args.asset_symbol);
}

operation staking_deposit_native(amount: integer, delegateTo: pubkey? = null) {
    require_initialized();
    require(amount > 0, "Can't deposit nothing (or less)!");

    val staker = ft4.auth.authenticate();

    // Pull in the CHR
    // TODO Make a trust account ???
    require(amount < get_account_balance(staker), "Insufficent funds to deposit.");
    ft4.assets.Unsafe.transfer(staker, get_pool_account(), get_asset(), amount);

    val existing = staker_state @? { .staker == staker and .latest };
    if (null == existing) {
        _staking_init_staker_state(staker);
    }
    val delta = staker_state_delta(
        balance_native = if (null != existing) existing.balance_native + amount else amount,
        cutover_time = null, new_provider = null, old_provider = null, balance_bsc = null, balance_eth = null
    );
    _staking_apply_staker_state_delta(staker, delta);

    if (null != delegateTo) {
        // Below check is duplicated, but less overhead than 2 wrapping functions.
        require(_staking_is_active_provider(delegateTo), "Must be active provider.");
        _staking_delegate(staker, delegateTo);
    }
}

function _staking_update_bsc(staker: ft4.accounts.account, new_balance: integer) {
    require_initialized();

    val existing = staker_state @? { .staker == staker and .latest };
    if (null == existing) {
        // If we're the first value, initialise first
        _staking_init_staker_state(staker);
    }
    val delta = staker_state_delta(
        balance_bsc = new_balance,
        cutover_time = null, new_provider = null, old_provider = null, balance_native = null, balance_eth = null
    );
    _staking_apply_staker_state_delta(staker, delta);
}

function _staking_update_eth(staker: ft4.accounts.account, amount: integer) {
    require_initialized();

    val existing = staker_state @? { .staker == staker and .latest };
    if (null == existing) {
        _staking_init_staker_state(staker);
    }
    val delta = staker_state_delta(
        balance_eth = if (null != existing) existing.balance_native + amount else amount,
        cutover_time = null, new_provider = null, old_provider = null, balance_native = null, balance_bsc = null
    );
    _staking_apply_staker_state_delta(staker, delta);
}

query staking_get_balance(account_id: byte_array) {
    val account = ft4.accounts.Account(account_id);
    return _staking_get_balance(account);
}

function _staking_get_balance(staker: ft4.accounts.account) = staker_state @? { .staker == staker and .latest==true } ( .balance_native + .balance_bsc + .balance_eth ) ?: 0;

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "staking_request_withdrawal",
    flags = [],
    message = staking_request_withdrawal_auth_message(*)
);

function staking_request_withdrawal_auth_message(gtv): text {
    val args = struct<staking_request_withdrawal>.from_gtv(gtv);
    return "Please sign the message to request a withdrawal.";
}

operation staking_request_withdrawal() {
    require_initialized();
    val staker = ft4.auth.authenticate();
    require(null == _staking_get_withdrawal_time(staker), "Only one withdrawal request at a time.");
    _staking_request_withdrawal(staker);
}

function _staking_request_withdrawal(staker: ft4.accounts.account) {
    require(_staking_get_balance(staker) > 0, "Need something to withdraw.");
    require(get_null_account() == _staking_get_current_delegate(staker), "Must unstake before requesting a withdrawal.");

    // Make a new request
    require(_staking_last_known_time() > 0, "Require an actual time");
    create staker_withdrawal_request(staker_withdrawal_request_time=_staking_last_known_time(), staker=staker, false);
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "staking_withdraw",
    flags = ["T"],
    message = staking_withdraw_auth_message(*)
);

function staking_withdraw_auth_message(gtv): text {
    val args = struct<staking_withdraw>.from_gtv(gtv);
    return "Please sign the message to complete the withdrawal.";
}

operation staking_withdraw() {
    require_initialized();
    val staker = ft4.auth.authenticate();
    val withdrawal_time = _staking_get_withdrawal_time(staker);
    require(withdrawal_time, "Need a withdrawal request.");
    require(_staking_last_known_time() >= withdrawal_time, "Need to wait for withdrawal request.");

    // Send the balance back to them through ft4
    ft4.assets.Unsafe.transfer(get_pool_account(), staker, get_asset(), _staking_get_balance(staker));

    // Apply change
    val delta = staker_state_delta(
        cutover_time = staking_get_last_known_time(),
        balance_native = 0,
        new_provider = null, old_provider = null, balance_bsc = null, balance_eth = null
    );
    _staking_apply_staker_state_delta(staker, delta);
}

query staking_get_withdrawal_time(account_id: byte_array): timestamp? {
    val staker = ft4.accounts.Account(account_id);
    return _staking_get_withdrawal_time(staker);
}

function _staking_get_withdrawal_time(staker: ft4.accounts.account): timestamp? {
    val valid_request = staker_withdrawal_request @? {.staker == staker and not .used};
    return
        if (null != valid_request)
            valid_request.staker_withdrawal_request_time + chain_context.args.staking_withdrawal_delay_ms
        else
            null
        ;
}

function _staking_is_active_provider(_provider: pubkey) = exists(provider @? {.pubkey == _provider});

query staking_get_total_delegation_to(provider: pubkey): integer = _staking_get_total_delegation_to(provider);

function _staking_get_total_delegation_to(provider: pubkey): integer {
    return
        // Look at the full staker state 
        (s: staker_state) @ {
            // consider only the latest state
            s.latest
            // restricted to those currently on this provider according to the cut off date
            and (
                ( s.new_provider == provider and s.cutover_time <= _staking_last_known_time() )
                or
                ( s.old_provider == provider and s.cutover_time > _staking_last_known_time() )
            )
        } (
            // sum the balances
            @sum (s.balance_native + s.balance_bsc + s.balance_eth)
        )
    ;
}

query staking_rewards_claimable_for(account_id: byte_array): integer {
    val staker = ft4.accounts.Account(account_id);
    return _staking_rewards_claimable_for(staker);
}

function _staking_rewards_claimable_for(staker: ft4.accounts.account): integer {

    // We are going to limit ourselves here by simply calculating the reward as of the last payout date at the
    // prevailing reward rate. This will give a "wrong" answer as a portion of the reward will be paid at the
    // new rate when it should have been on the old. This will not be significant.
    // The author would like to have done something more fun here tbh. Hopefully this will get easier as Rell
    // approaches its final form of a modern Tutorial D :)
    // TODO extend this query to handle the above accurately

    // So what we will do is consider all of the states, but we will cap the previous and current stake times
    // at the last payout date, which will cause periods enterly before the payout date to collapse to zero
    // duration, and the state during which the payout happened to be truncated to the payout date.
    // Each row also potentially needs to be cut in two, as the delegate could change to NO_ONE during it, we do
    // this by first considering the time before the cutoff date, and then the time afterwards (if any). 
    // We also need to recognise the last row, and for this row only, include the *present* balance extended to
    // the present date. In effect a last virtual row. (If we could UPSERT, we could cheaply create this row rather
    // than interpolating it.)

    val last_payout_time = (staker_payout @? {} (@max .staker_payout_time)) ?: 0;
    val total_token_time = staker_state @ {
        .staker == staker
    } (
        @sum(
            // Real and concluded states truncated by the last payment date
            (
                (
                    max(.staker_state_time, last_payout_time)
                        - max(.previous_staker_state_time, last_payout_time)
                ) * (.previous_balance_native + .previous_balance_bsc + .previous_balance_eth)
            )
            // TODO We need to consider the cutoff time
            +
            // Interpolated last row from latest row
            (
                when (.latest) {
                    true -> (_staking_last_known_time() - max(.staker_state_time, last_payout_time)) * (.balance_native + .balance_bsc + .balance_eth);
                    else -> 0;
                }
            )
        )
    );

    val rate = staking_get_current_rate() / millis_per_year;

    val token_reward = total_token_time * rate;
    return integer(token_reward); // Can only transfer whole minor units
}

function _staking_offboard_provider(provider: pubkey) {
    // Unwind delegations immediately
    // Find all the latest delegations involving removed provider
    // eg. latest AND new_provider is going
    val removed_delegations = staker_state @* { .new_provider == provider and .latest } (@group .staker);
    // then for each :-
    for (removed_delegation in removed_delegations) {
        // Apply undelegation
        val delta = staker_state_delta(
            cutover_time = staking_get_last_known_time(),
            new_provider = get_null_account(),
            old_provider = _staking_get_current_delegate(removed_delegation),
            balance_native = null, balance_bsc = null, balance_eth = null
        );
        _staking_apply_staker_state_delta(removed_delegation, delta);
    }
}


@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "staking_delegate",
    flags = [],
    message = staking_delegate_auth_message(*)
);

function staking_delegate_auth_message(gtv): text {
    val args = struct<staking_delegate>.from_gtv(gtv);
    // TODO Indicate which provider?
    return "Please sign the message to set the provider.";
}

operation staking_delegate(provider: pubkey) {
    require_initialized();
    require(_staking_is_active_provider(provider), "Must be active provider.");
    val staker = ft4.auth.authenticate();
    _staking_delegate(staker, provider);
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "staking_undelegate",
    flags = [],
    message = staking_undelegate_auth_message(*)
);

function staking_undelegate_auth_message(gtv): text {
    val args = struct<staking_undelegate>.from_gtv(gtv);
    return "Please sign the message to undelegate.";
}

operation staking_undelegate() {
    require_initialized();
    val delegator = ft4.auth.authenticate();
    _staking_delegate(delegator, get_null_account());
}

function _staking_delegate(delegator: ft4.accounts.account, provider: pubkey) {
    require(_staking_get_balance(delegator) > 0, "Must have a stake to staker.");

    // Clear any withdrawal request
    update staker_withdrawal_request @? {not .used and .staker == delegator} (used = true);

    // Get the values before messing with the flag
    val current_provider = _staking_get_current_delegate(delegator);

    // Apply change
    val delta = staker_state_delta(
        cutover_time = _staking_cannot_change_before(),
        new_provider = provider,
        old_provider = current_provider,
        balance_native = null, balance_bsc = null, balance_eth = null
    );
    _staking_apply_staker_state_delta(delegator, delta);
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "staking_cancel_withdrawal",
    flags = [],
    message = staking_cancel_withdrawal_auth_message(*)
);

function staking_cancel_withdrawal_auth_message(gtv): text {
    val args = struct<staking_cancel_withdrawal>.from_gtv(gtv);
    return "Please sign the message to cancel withdrawal.";
}

operation staking_cancel_withdrawal() {
    require_initialized();
    val staker = ft4.auth.authenticate();
    update staker_withdrawal_request @? {not .used and .staker == staker} (used = true);
}

operation staking_claim_rewards() {
    require_initialized();
    require_admin();
    _staking_claim_rewards();
}

function _staking_claim_rewards() {
    var payout_list: list<(ft4.accounts.account, integer)> = [];
    var total_amount = 0;

    // Get a list of payouts
    for(staker in staker_state @* {} (@group .staker) ) {
        // Find the amounts
        val payout_amount = _staking_rewards_claimable_for(staker);
        payout_list.add((staker, payout_amount));
        total_amount += payout_amount;
    }

    // Do not start what we cannot finish
    if (get_account_balance(get_pool_account()) < total_amount) {
        log("Cannot pay rewards. Insufficient funds.");
        return;
    }

    // Do the payouts
    for(payment in payout_list) {
        val (staker, payout_amount) = payment;
        if(payout_amount > 0) {
            _pay_to(staker, payout_amount);
        }
    }

    // Record payout
    create staker_payout(staker_payout_time = _staking_last_known_time());
}

query staking_get_current_rate(): decimal {
    val current_rate = reward_rate @ {
        .reward_rate_time <= _staking_last_known_time()
    } (
        .reward_rate,
        @omit @sort_desc .reward_rate_time
    ) limit 1;
    return current_rate;
}

query staking_get_current_delegate(account_id: byte_array): pubkey {
    val account = ft4.accounts.Account(account_id);
    return _staking_get_current_delegate(account);
}

function _staking_get_current_delegate(staker: ft4.accounts.account): pubkey {
    val current_state = staker_state @? { .staker == staker and .latest };
    return
        if  (null == current_state) get_null_account()
    else if ( staking_get_last_known_time() >= current_state.cutover_time ) current_state.new_provider
    else    current_state.old_provider;
}

function __staking_begin_block(height: integer) {
    val last_payout_time = (staker_payout @? {} (@max .staker_payout_time)) ?: 0;
    val interval_since_last_payout = _staking_last_known_time() - last_payout_time;
    if(interval_since_last_payout > chain_context.args.staking_payout_interval_ms) {
        _staking_claim_rewards();
    }
}

function _pay_to(staker: ft4.accounts.account, amount: integer) {
    // We pay from the same pool account as provider rewards
    ft4.assets.Unsafe.transfer(get_pool_account(), staker, get_asset(), amount);
}

function _staking_apply_staker_state_delta(staker: ft4.accounts.account, delta: staker_state_delta) {
    // Snapshot existing state
    val existing = staker_state @ {.latest and .staker == staker};

    // Clear flag from existing state
    update staker_state @? { .staker == staker and .latest } ( latest = false );

    // Create new from existing state + delta
    create staker_state(
        staker_state_time = _staking_last_known_time(),
        previous_staker_state_time = existing.staker_state_time,
        staker = staker,
        cutover_time = delta.cutover_time ?: existing.cutover_time,
        new_provider = delta.new_provider ?: existing.new_provider,
        old_provider = delta.old_provider ?: existing.old_provider,
        balance_native = delta.balance_native ?: existing.balance_native,
        previous_balance_native = existing.balance_native,
        balance_bsc = delta.balance_bsc ?: existing.balance_bsc,
        previous_balance_bsc = existing.balance_bsc,
        balance_eth = delta.balance_eth ?: existing.balance_eth,
        previous_balance_eth = existing.balance_eth,
        latest = true
    );

    // Have we reduced the balance to zero, e.g. a complete withdrawal
    if (
        (0 != existing.balance_bsc + existing.balance_eth + existing.balance_native)
        and
        (0 == (delta.balance_bsc ?: 0) + (delta.balance_eth ?: 0) + (delta.balance_native ?: 0))
        and
        not (null == delta.balance_bsc and null == delta.balance_eth and null == delta.balance_native)
    ) {
        // Clear the withdrawal request
        update staker_withdrawal_request @ {.staker == staker } (used = true);
    }
}

function _staking_init_staker_state(staker: ft4.accounts.account) {
    create staker_state(
        staker_state_time = _staking_last_known_time(),
        previous_staker_state_time = 0,
        staker = staker,
        balance_native = 0,    
        previous_balance_native = 0,
        balance_bsc = 0,
        previous_balance_bsc = 0,
        balance_eth = 0,
        previous_balance_eth = 0,
        cutover_time = _staking_last_known_time(),
        new_provider = get_null_account(),
        old_provider = get_null_account(),
        latest = true
    );
}

function _staking_cannot_change_before(): timestamp = _staking_last_known_time() + chain_context.args.staking_rate_change_delay_ms;

query staking_get_cannot_change_before(): timestamp = _staking_cannot_change_before();

// As per https://learn.chromia.com/courses/latest-known-time
function _staking_last_known_time() 
    = if (op_context.exists) op_context.last_block_time else block @ {} (@max .timestamp) ?: 0;

query staking_get_last_known_time() = _staking_last_known_time();

// As suggested by https://chromadev.zulipchat.com/#narrow/stream/316358-Protocols/topic/Little.20questions/near/421469052
function get_null_account() : pubkey { return "NULL".hash(); }