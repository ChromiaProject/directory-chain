@extend(remove_provider_handler)
function(
    provider_account
) = _staking_offboard_provider(
    provider_account
        .provider
        .pubkey
);

// It might be better for this to live in a table
enum network {
    BSC, ETH, CHR
}

object _staking_state {
    mutable last_update: integer = 0;
}
entity staker_withdrawal_request {
    index finish_at: timestamp;
    index staker_state;
    index mutable active: boolean;
}

entity provider_change_request {
    index finish_at: timestamp;
    index staker_state;
    index mutable active: boolean;
    provider;
}

entity staker_state {
    key ft4.accounts.account, network;
    mutable balance: integer;
    mutable last_update: timestamp;
    mutable pending_token_time: integer;
}

entity staker_state_to_provider {
    timestamp;
    index staker_state;
    provider;
}

@log
entity reward_rate {
    rate: decimal;
}

function __staking_begin_block(height: integer) {
    val week = integer(_staking_last_known_time() / (604800000));
    if (week > _staking_state.last_update) {
        _staking_distribute_rewards();
        _staking_distribute_withdrawals();
        _staking_state.last_update = week;
    }
}


operation staking_deposit_native(amount: integer, delegateTo: pubkey? = null) {
    require(amount > 0, "Can't deposit nothing (or less)!");

    val staker = ft4.auth.authenticate();

    // Pull in the CHR
    require(amount < get_account_balance(staker), "Insufficent funds to deposit.");
    ft4.assets.Unsafe.transfer(staker, get_deposit_account(), get_asset(), amount);

    val _provider = provider @? { .pubkey == delegateTo };

    var ss = staker_state @? { .account == staker and .network == network.CHR };
    if (exists(ss)) {
        _update_pending_token_time(ss);
        ss.balance += amount;
        if (exists(_provider))
            create staker_state_to_provider (
                timestamp = _staking_last_known_time(),
                ss,
                _provider
            );
    } else {
        require(_provider, "Must delegate to a provider");
        ss = create staker_state (
            staker,
            network.CHR,
            balance = amount,
            last_update = _staking_last_known_time(),
            pending_token_time = 0
        );
        create staker_state_to_provider ( timestamp = _staking_last_known_time(), ss, _provider );
    }
}

function _staking_update_evm_state(staker: ft4.accounts.account, network, new_balance: integer) {
    var ss = staker_state @? { .account == staker and .network == network };
    if (exists(ss)) {
        _update_pending_token_time(ss);
        ss.balance = new_balance;
    } else {
        val _provider = provider @ { .pubkey == get_null_account() };
        ss = create staker_state (
            staker,
            network,
            balance = new_balance,
            last_update = _staking_last_known_time(),
            pending_token_time = 0
        );
        create staker_state_to_provider ( timestamp = _staking_last_known_time(), ss, _provider );
    }
}


function _update_pending_token_time(staker_state) {
    update staker_state (
        pending_token_time = .balance * (_staking_last_known_time() - .last_update),
        last_update = _staking_last_known_time()
    );
}

function _update_pending_token_time_all() {
    update staker_state @* { } (
        pending_token_time = .balance * (_staking_last_known_time() - .last_update),
        last_update = _staking_last_known_time()
    );
}

function _staking_distribute_rewards() {
    var total_amount = 0;
    val rate = staking_get_current_rate() / millis_per_year;

    // Get a list of payouts
    _update_pending_token_time_all();
    val rewards = staker_state @* { } (
        @group account = .account,
        @sum amount = integer (
            (
            .pending_token_time
        ) * rate
        )
    );
    for (reward in rewards) {
        total_amount += reward.amount;
    }

    // Do not start what we cannot finish
    if (get_account_balance(get_pool_account()) < total_amount) {
        log("Cannot pay rewards. Insufficient funds.");
        return;
    }
    update staker_state @* { } ( .pending_token_time = 0 );

    // Do the payouts
    for ((account,amount) in rewards) {
        ft4.assets.Unsafe.transfer(get_pool_account(), account, get_asset(), amount);
        log("Paid out %s to %s", account, amount);
    }
}

operation staking_request_withdrawal() {
    val user = ft4.auth.authenticate();
    _staking_request_withdrawal(user, network.CHR);
}

function _staking_request_withdrawal(user: ft4.accounts.account, network) {
    val ss = staker_state @? { .account == user and .network == network };
    require(ss, "No staker state for %s".format(user));

    val active_withdraw_request = staker_withdrawal_request @? { ss, .active };
    require(not exists(active_withdraw_request), "Only one withdrawal request allowed at a time");
    require(ss.balance > 0, "Balance must be over 0");

    _staking_delegate(user, get_null_account());

    // Make a new request
    create staker_withdrawal_request (
        finish_at = _staking_last_known_time() + chain_context.args.staking_rate_change_delay_ms,
        ss,
        true
    );
}

function _staking_delegate(staker: ft4.accounts.account, provider_pubkey: pubkey) {
    // get all staker states of user, and all related withdraw requests
    val staker_states = staker_state @* { .account == staker };
    val withdraw_requests = staker_withdrawal_request @* { .active and .staker_state in staker_states };

    // deactivate chromia withdraw requests
    val withdraw_requests_chr = withdraw_requests @ { .staker_state.network == network.CHR };
    update withdraw_requests_chr ( .active = false );

    val staker_states_to_exclude = withdraw_requests @* { .staker_state.network != network.CHR } ( .staker_state );

    val new_provider = provider @ { provider_pubkey };

    // Update appropriate staker states with new provider
    val staker_states_to_update = staker_states @* {
        $ not in staker_states_to_exclude
    } (
        struct<staker_state_to_provider> (
            timestamp = _staking_last_known_time(),
            staker_state = $,
            provider = new_provider
        )
    );

    create staker_state_to_provider ( staker_states_to_update );
}

function get_null_account(): pubkey {
    return "NULL".hash();
}

function _staking_last_known_time() 
    = if (op_context.exists) op_context.last_block_time else block @ { } ( @max .timestamp ) ?: 0;


query staking_get_current_rate(): decimal {
    val current_rate = reward_rate @ { } ( .rate, @omit @sort_desc .transaction.block.timestamp ) limit 1;
    return current_rate;
}

function _staking_distribute_withdrawals() {
    val open_withdrawals = staker_withdrawal_request @* {
        .active and .staker_state.network == network.CHR and .finish_at < _staking_last_known_time()
    } ( account = .staker_state.account, balance = .staker_state.balance );

    for (withdrawal in open_withdrawals) {
        // Send the balance back to them through ft4
        ft4.assets.Unsafe.transfer(
                get_deposit_account(),
                withdrawal.account,
                get_asset(),
                withdrawal.balance
            );
    }
    update staker_withdrawal_request @* {
        .active and .staker_state.network == network.CHR and .finish_at < _staking_last_known_time()
    } ( .active = false );
}

function _staking_offboard_provider(pubkey) {
    val null_provider = provider @ { get_null_account() };

    // Update appropriate staker states with new provider TODO FIX THIS
    val updated_relationships = staker_state_to_provider @* { .provider.pubkey == pubkey } (
        struct<staker_state_to_provider> (
            timestamp = _staking_last_known_time(),
            staker_state = .staker_state,
            provider = null_provider
        )
    );

    create staker_state_to_provider ( updated_relationships );
}

operation staking_delegate(pubkey) {
    val staker = ft4.auth.authenticate();
    _staking_delegate(staker, pubkey);
}

query staking_get_current_delegate_on_network(account_id: byte_array, network) {
    val _provider_pubkey = staker_state_to_provider @ {
        .staker_state.account.id == account_id and .staker_state.network == network and  
        (_staking_last_known_time() - chain_context.args.staking_rate_change_delay_ms) > .timestamp
    } ( @omit @sort_desc .timestamp, .provider.pubkey ) limit 1;
    return _provider_pubkey;
}

query staking_get_current_delegate(
    account_id: byte_array
) = staking_get_current_delegate_on_network(account_id, network.CHR);

query staking_get_balance(
    account_id: byte_array
) = staker_state @ { 
    .account.id == account_id 
} ( 
    @sum .balance 
) limit 1;

query staking_get_total_delegation_to(pubkey, network? = null) {
    return when (exists(network)) {
        true -> ( s1: staker_state_to_provider) @* {
            .provider.pubkey == pubkey and .staker_state.network == network and not exists(
            (s2:staker_state_to_provider) @* { 
                s2.staker_state ==s1.staker_state,
                (s2.timestamp>s1.timestamp) or 
                (s2.timestamp==s1.timestamp and s2 < s1) 
            }
        )
        } ( @sum .staker_state.balance )[0];
        else -> ( s1: staker_state_to_provider) @* {
        .provider.pubkey == pubkey and not exists(
            (s2:staker_state_to_provider) @* { 
                s2.staker_state ==s1.staker_state,
                (s2.timestamp>s1.timestamp) or 
                (s2.timestamp==s1.timestamp and s2 < s1) 
            }
        )
        } ( @sum .staker_state.balance )[0];
    };
}
