// Rate management

function _staking_set_rate_at_impl(reward_rate: decimal, provider_rate: decimal, time: timestamp) {
    require_initialized();
    require_admin();
    require(time >= _staking_cannot_change_before(), "Cannot change rate before " + _staking_cannot_change_before());
   _staking_set_rate_at(reward_rate, time);
}

function _staking_set_rate_at(reward_rate: decimal, time: timestamp) {
    create reward_rate(time, reward_rate);
}

function _staking_set_rate_impl(reward_rate: decimal) {
    require_admin();
   _staking_set_rate_at(reward_rate, _staking_cannot_change_before());
}

function _staking_get_current_rate(): decimal {
    val current_rate = reward_rate @ {
        .reward_rate_time <= _staking_last_known_time()
    } (
        .reward_rate,
        @omit @sort_desc .reward_rate_time
    ) limit 1;
    return current_rate;
}


// Provider management

function _staking_offboard_provider(provider_account) {
    // Unwind delegations immediately
    // Find all the latest delegations involving removed provider
    // eg. latest AND new_provider is going
    val removed_delegations = staker_state @* { .new_provider == provider_account and .latest } (@group .staker);
    // then for each :-
    for (removed_delegation in removed_delegations) {
        // Apply undelegation to all networks
        for (n in network.values()) {
            val delta = staker_state_delta(
                network = n,
                cutover_time = staking_get_last_known_time(),
                new_provider = get_null_provider_account(),
                old_provider = _staking_get_current_delegate(removed_delegation),
                balance = null
            );
            _staking_apply_staker_state_delta(removed_delegation, delta);
        }
    }
}


// Deposits and balances

function _staking_deposit_native_impl(amount: integer, delegateTo: pubkey? = null) {
    require_initialized();
    require(amount > 0, "Can't deposit nothing (or less)!");

    val staker = ft4.auth.authenticate();

    // Pull in the CHR
    require(amount < get_account_balance(staker), "Insufficent funds to deposit.");
    ft4.assets.Unsafe.transfer(staker, get_deposit_account(), get_asset(), amount);

    val existing = staker_state @? { .staker == staker and .latest and .network == network.CHR };
    val delta = staker_state_delta(
        network = network.CHR,
        balance = if (null != existing) existing.balance + amount else amount,
        cutover_time = null, new_provider = null, old_provider = null
    );
    _staking_apply_staker_state_delta(staker, delta);

    if (exists(delegateTo)) {
        val delegateToAccount = provider_account @ {.provider.pubkey == delegateTo};
        require(_staking_is_active_provider(delegateToAccount), "Must be active provider.");
        // Below check is duplicated, but less overhead than 2 wrapping functions.
        _staking_delegate(staker, delegateToAccount);
    }
}

function _staking_get_balance(staker: ft4.accounts.account) = _staking_get_balance_by_network(staker, network.CHR) + _staking_get_balance_by_network(staker, network.ETH) + _staking_get_balance_by_network(staker, network.BSC) ;
function _staking_get_balance_by_network(staker: ft4.accounts.account, network) = staker_state @? { .staker == staker and .latest and .network == network } ( .balance ) ?: 0;


// Legacy EVM events imports

function _staking_update_from_evm(staker: ft4.accounts.account, new_balance: integer, network) {
    require_initialized();
    val delta = staker_state_delta(
        network,
        balance = new_balance,
        cutover_time = null, new_provider = null, old_provider = null
    );
    _staking_apply_staker_state_delta(staker, delta);
}



// Withdrawals

function _staking_request_withdrawal_impl() {
    require_initialized();
    val staker = ft4.auth.authenticate();
    require(null == _staking_get_withdrawal_time(staker, network.CHR), "Only one withdrawal request at a time.");
    require(_staking_get_balance_by_network(staker, network.CHR) > 0, "Need something to withdraw.");
    _staking_request_withdrawal(staker, network.CHR);
}

// This operation needs to be called when an address was created by means others than ras_staking
// registration strategy.
// note: network_id is important only for smart contract stakers, for EOA stakers it is ignored
// should become irrelevant once we have hooks in eif hbridge
operation staking_import_evm_balance(address: byte_array, network_id: integer) {
    require_initialized();
    val staker = ft4.auth.authenticate();

    val account = eif.hbridge.find_ft4_account_for_address(address, network_id);
    require(exists(account), "No account link established for this address.");
    require(account == staker, "Address does not belong to the authenticated account.");

    flush_provisional_stake_balance(staker, address);
}

function _staking_request_withdrawal(staker: ft4.accounts.account, network) {
    _staking_delegate(staker, get_null_provider_account());

    // Make a new request
    require(_staking_last_known_time() > 0, "Require an actual time");
    create staker_withdrawal_request(network, staker_withdrawal_request_time=_staking_last_known_time(), staker=staker, false);
}

function _staking_cancel_withdrawal_impl() {
    require_initialized();
    val staker = ft4.auth.authenticate();
    update staker_withdrawal_request @? {not .used and .staker == staker} (used = true);
}

function _staking_withdraw_all() {
    require_initialized();

    val open_withdrawals = staker_withdrawal_request @* {
            not .used
        and .network == network.CHR
        and (.staker_withdrawal_request_time + chain_context.args.staking_withdrawal_delay_ms) < _staking_last_known_time()
    } ( $.to_struct() );

    for (withdrawal in open_withdrawals) {
        // Send the balance back to them through ft4
        ft4.assets.Unsafe.transfer(get_deposit_account(), withdrawal.staker, get_asset(), _staking_get_balance(withdrawal.staker));

        // Apply change
        val delta = staker_state_delta(
            network = network.CHR,
            cutover_time = _staking_last_known_time(),
            balance = 0,
            new_provider = null, old_provider = null
        );
        _staking_apply_staker_state_delta(withdrawal.staker, delta);
    }
}

function _staking_get_withdrawal_time(staker: ft4.accounts.account, network = network.CHR): timestamp? {
    val valid_request = staker_withdrawal_request @? {.staker == staker and not .used and .network == network};
    return
        if (null != valid_request)
            valid_request.staker_withdrawal_request_time + chain_context.args.staking_withdrawal_delay_ms
        else
            null
        ;
}

function _staking_is_active_provider(provider_account) = exists(provider @? {.pubkey == provider_account.provider.pubkey and .active});

function _staking_get_total_delegation_to(provider_account, _network: network): integer {
    return
        // Look at the full staker state 
        (s: staker_state) @ {
            .network == _network
            // consider only the latest state
            and s.latest
            // restricted to those currently on this provider according to the cut off date
            and (
                ( s.new_provider == provider_account and s.cutover_time <= _staking_last_known_time() )
                or
                ( s.old_provider == provider_account and s.cutover_time > _staking_last_known_time() )
            )
        } (
            // sum the balances
            @sum s.balance
        )
    ;
}

function _staking_delegate_impl(pubkey) {
    require_initialized();
    val provider_account = _staking_pubkey_to_provider(pubkey);
    require(_staking_is_active_provider(provider_account), "Must be active provider.");
    val staker = ft4.auth.authenticate();
    _staking_delegate(staker, provider_account);
}

function _staking_undelegate_impl() {
    require_initialized();
    val delegator = ft4.auth.authenticate();
    for(n in network.values()) {
        _staking_delegate_by_network(delegator, get_null_provider_account(), n);
    }
}

// Rewards

function _staking_rewards_claimable_for(staker: ft4.accounts.account, network): integer {
    val since = (staker_payout @? {} (@max .staker_payout_time)) ?: 0;
    return _staking_rewards_claimable_since(staker, network, since);
}

function _staking_rewards_claimable_since(staker: ft4.accounts.account, network, since: integer): integer {

    // We are going to limit ourselves here by simply calculating the reward as of the last payout date at the
    // prevailing reward rate. This will give a "wrong" answer as a portion of the reward will be paid at the
    // new rate when it should have been on the old. This will not be significant.
    // The author would like to have done something more fun here tbh. Hopefully this will get easier as Rell
    // approaches its final form of a modern Tutorial D :)
    // TODO extend this query to handle the above accurately

    // So what we will do is consider all of the states, but we will cap the previous and current stake times
    // at the last payout date, which will cause periods enterly before the payout date to collapse to zero
    // duration, and the state during which the payout happened to be truncated to the payout date.
    // Each row also potentially needs to be cut in two, as the delegate could change to NO_ONE during it, we do
    // this by first considering the time before the cutoff date, and then the time afterwards (if any). 
    // We also need to recognise the last row, and for this row only, include the *present* balance extended to
    // the present date. In effect a last virtual row. (If we could UPSERT, we could cheaply create this row rather
    // than interpolating it.)

    val total_token_time = staker_state @ {
        .staker == staker and .network == network
    } (
        @sum(
            // Real and concluded states truncated by the last payment date
            (
                (
                    max(.staker_state_time, since) - max(.previous_staker_state_time, since)
                ) * (.previous_balance)
            )
            // TODO We need to consider the cutoff time
            +
            // Interpolated last row from latest row
            (
                when (.latest) {
                    true -> (_staking_last_known_time() - max(.staker_state_time, since)) * .balance;
                    else -> 0;
                }
            )
        )
    );

    val rate = _staking_get_current_rate() / millis_per_year;

    val token_reward = total_token_time * rate;
    return integer(token_reward); // Can only transfer whole minor units
}

function _staking_delegate(staker: ft4.accounts.account, provider_account) {
    require(_staking_get_balance(staker) > 0, "Must have a stake to delegate somewhere.");
    for(n in network.values()) {
        _staking_delegate_by_network(staker, provider_account, n);
    }
}

function _staking_get_current_delegate(staker: ft4.accounts.account, network = network.CHR) {
    val current_state = staker_state @? { .staker == staker and .latest and .network == network };
    return
        if  (empty(current_state)) get_null_provider_account()
    else if ( staking_get_last_known_time() >= current_state.cutover_time ) current_state.new_provider
    else    current_state.old_provider;
}

function _staking_delegate_by_network(delegator: ft4.accounts.account, provider: provider_account, _network: network) : boolean {

    // Is there an active withdrawal request for an EVM chain
    if ( [network.ETH, network.BSC].contains(_network)
            and exists (staker_withdrawal_request @? {not .used and .staker == delegator and .network == _network})
    ) {
        log("Quietly skip as we cannot cancel the withdrawal request from here.");
        return false;
    }

    // Clear any withdrawal request
    update staker_withdrawal_request @? {not .used and .staker == delegator and .network == _network} (used = true);

    // Get the values before messing with the flag
    val current_provider = _staking_get_current_delegate(delegator);

    // Apply change
    val delta = staker_state_delta(
        network = _network,
        cutover_time = _staking_cannot_change_before(),
        new_provider = provider,
        old_provider = current_provider,
        balance = null
    );
    _staking_apply_staker_state_delta(delegator, delta);

    return true;
}

function _staking_claim_rewards_impl() {
    require_initialized();
    require_admin();
    _staking_claim_rewards();
}

function _staking_claim_rewards() {
    var payout_list: list<(ft4.accounts.account, integer)> = [];
    var total_amount = 0;

    // Get a list of payouts
    for(staker in staker_state @* {} (@group .staker) ) {
        // Find the amounts
        val payout_amount = _staking_rewards_claimable_for(staker, network.CHR) + _staking_rewards_claimable_for(staker, network.BSC) + _staking_rewards_claimable_for(staker, network.ETH);
        payout_list.add((staker, payout_amount));
        total_amount += payout_amount;
    }

    // Do not start what we cannot finish
    if (get_account_balance(get_pool_account()) < total_amount) {
        log("Cannot pay rewards. Insufficient funds.");
        return;
    }

    // Do the payouts
    for(payment in payout_list) {
        val (staker, payout_amount) = payment;
        if(payout_amount > 0) {
            _pay_to(staker, payout_amount);
            log("Paid out %s to account id %s".format(payout_amount, staker.id));
        }
    }

    // Record payout
    create staker_payout(staker_payout_time = _staking_last_known_time());
}


// Shared rewards (triggered by a hook in the rewards logic)

function _staking_shared_rewards(pay_reward_result) {
    // We ignore reward debt here as it will flow through the reward term after the pool is refreshed
    val total_shared_reward = chain_context.args.rewards_share * pay_reward_result.payed_reward;

    // Find provider pubkey
    val provider_account = provider_account @? {pay_reward_result.payed_to};

    // In some edge cases during testing a public key may be absent
    if(empty(provider_account)) {
        log("Not provider public key for id: %s".format(pay_reward_result.payed_to.id));
        return;
    }

    // Find all the delegations
    val delegating_to =
        (s: staker_state) @* {
            // consider only the latest state
            s.latest
            // restricted to those currently on this provider according to the cut off date
            and (
                ( s.new_provider == provider_account and s.cutover_time <= _staking_last_known_time() )
                or
                ( s.old_provider == provider_account and s.cutover_time > _staking_last_known_time() )
            )
        } (
            @group staker = s.staker,
            @sum balance = s.balance
        )
    ;

    // Get total and divide through
    val total_delegation = delegating_to @ {} (@sum .balance);

    // Zero delegation check (should not occur in normal useage.)
    if (total_delegation == 0) return;

    // Run through and payout by share of delegation
    for (reward_share in delegating_to) {
        val share_amount = integer(total_shared_reward * (reward_share.balance / total_delegation));
        _pay_to(reward_share.staker, share_amount);
        log("Paid reward share of %s to %s. Based on a delegation of %s CHR.".format(share_amount, reward_share.staker.id, reward_share.balance));
    }
}
