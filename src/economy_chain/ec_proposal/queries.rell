
struct ec_proposal_voting_results {
    positive_votes: integer;
    negative_votes: integer;
    max_votes: integer;
    threshold: integer;
    voting_result;
}

struct ec_proposal_voter {
    provider: byte_array;
    vote: boolean;
}

query get_proposals_range(from: timestamp, until: timestamp, only_pending: boolean) {
    return proposal @* {
        .timestamp >= from,
        .timestamp <= until,
        not(only_pending) or .state == proposal_state.PENDING
    } (.rowid, proposal_type = .ec_proposal_type, .state);
}

query get_relevant_proposals(from: timestamp, until: timestamp, only_pending: boolean, my_pubkey: pubkey) {
    return (proposal, voter_set_member) @* {
        voter_set_member.voter_set == proposal.voter_set,
        voter_set_member.provider.pubkey == my_pubkey,
        proposal.timestamp >= from,
        proposal.timestamp <= until,
        not(only_pending) or proposal.state == proposal_state.PENDING
    } (proposal.rowid, proposal_type = proposal.ec_proposal_type, proposal.state);
}

query get_proposal(id: rowid?): (id: rowid, timestamp: integer, type: ec_proposal_type, proposed_by: pubkey, description: text, state: proposal_state)? {
    val result = if (id == null) proposal @? {} (@sort_desc @omit .rowid, $) limit 1 else proposal @? { id };
    if (result == null) return null;
    return (
        id = result.rowid,
        timestamp = result.timestamp,
        type = result.ec_proposal_type,
        proposed_by = result.proposed_by.pubkey,
        description = result.description,
        state = result.state
    );
}

query get_proposal_voting_results(rowid): ec_proposal_voting_results {
    val proposal = require_proposal(rowid);
    require(proposal.state == proposal_state.PENDING, "This proposal is closed as %s. For info about voting use get_proposal_voter_info query.".format(proposal.state));
    val positive_votes = positive_votes(proposal);
    val negative_votes = negative_votes(proposal);
    val max_votes = max_votes(proposal.voter_set);
    val threshold = proposal.voter_set.threshold;
    val status = _compute_voting_result(positive_votes, negative_votes, max_votes, threshold);
    return ec_proposal_voting_results(positive_votes, negative_votes, max_votes, threshold, status);
}

query get_proposal_voter_info(rowid): list<ec_proposal_voter> {
    val proposal = require_proposal(rowid);
    return vote @* { .proposal.rowid == rowid } (ec_proposal_voter(.provider.pubkey, .vote));
}

query get_provider_votes(from: timestamp, until: timestamp, provider_key: pubkey) {
    return (proposal, vote) @* {
        vote.provider.pubkey == provider_key,
        vote.proposal == proposal,
        proposal.timestamp >= from,
        proposal.timestamp <= until
    } ( .proposal, .vote );
}
