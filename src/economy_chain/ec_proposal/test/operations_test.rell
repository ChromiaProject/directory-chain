@test module;

import ^^.*;
import ^^^.*;
import ^^^.test.helper_functions.*;
import ^.helper_functions.*;

val alice = rell.test.keypairs.alice;
val bob = rell.test.keypairs.bob;

function test_make_vote() {
    create_provider_and_proposal(alice, ec_proposal_type.cluster_create);

    rell.test.tx().op(
        make_vote(alice.pub, get_latest_proposal_id(), true)
    ).sign(alice).run();
}

function test_make_vote_fail_due_to_not_member_of_voter_set() {

    create_provider_and_proposal(alice, ec_proposal_type.cluster_create);
    add_provider(bob.pub, true);

    rell.test.tx().op(
        make_vote(bob.pub, get_latest_proposal_id(), true)
    ).sign(bob).run_must_fail("Provider is not a member of voter set voter-set");
}

function test_make_vote_fail_due_to_not_system_provider() {

    add_provider(alice.pub, false);

    rell.test.tx().op(
        make_vote(alice.pub, rowid(1), true))
        .sign(alice)
        .run_must_fail("Expected system provider pubkey");
}

function test_revoke_proposal() {

    create_provider_and_proposal(alice, ec_proposal_type.cluster_create);

    rell.test.tx().op(
        revoke_proposal(alice.pub, get_latest_proposal_id()))
        .sign(alice)
        .run();

    val proposal = proposal @ { .proposed_by.pubkey == alice.pub };
    assert_equals(proposal.state, proposal_state.REVOKED);
}

function test_revoke_proposal_fail_due_to_not_my_proposal() {

    create_provider_and_proposal(alice, ec_proposal_type.cluster_create);
    add_provider(bob.pub, true);

    rell.test.tx().op(
        revoke_proposal(bob.pub, get_latest_proposal_id()))
        .sign(bob)
        .run_must_fail("It is only allowed to revoke own proposals");
}
