function calculate_rewards(cluster: cluster, node_availability_report: node_availability_report) {
    val pool = get_pool_account();
    var pool_balance = get_account_balance(pool);

    val cluster_nodes = cluster_node @* { cluster } .node;

    for (cluster_node in cluster_nodes) {

        val provider = cluster_node.provider;
        val pa = provider_account @ { provider };

        val reward = calculate_reward(node_availability_report, cluster_node);
        val debt = pa.reward_debt;
        if (debt > 0) pa.reward_debt = 0;

        val total = reward + debt;
        if (total > 0) {
            if (pool_balance >= total) {
                if (transfer_reward(pool, pa, total)) {
                    pool_balance -= total;
                } else {
                    pa.reward_debt = total;
                }
            } else if (pool_balance <= 0) { // No funds to pay reward
                log("Reward pool is empty!");
                pa.reward_debt = total;
            } else { // Missing funds to pay full reward
                log("Reward pool does not have enough funds to transfer full reward.");
                if (transfer_reward(pool, pa, pool_balance)) {
                    pa.reward_debt = total - pool_balance;
                    pool_balance = 0;
                } else {
                    pa.reward_debt = total;
                }
            }
        }
    }
}

function calculate_reward(node_availability_report: node_availability_report, cluster_node: node): big_integer {

    val availability_factor = node_availability_report.node_availability[cluster_node.pubkey];

    // TODO calculate the rewards
    // Missing occupancy rate + cluster SCU cost
    // Should be a harmonic mean over all three factors
    val reward = 0;
    return reward.to_big_integer();
}

function transfer_reward(pool: ft4.accounts.account, pa: provider_account, amount: big_integer): boolean {
    log("Transfer reward %s to provider %s".format(amount, pa.provider.pubkey));
    val success = try_call(try_transfer_reward(pool, pa, amount, *));
    if (not success) {
        log("Unable to transfer reward to provider %s".format(pa.provider.pubkey));
    }
    return success;
}

function try_transfer_reward(pool: ft4.accounts.account, pa: provider_account, amount: big_integer) {
    ft4.assets.Unsafe.transfer(get_pool_account(), pa.account, get_asset(), amount);
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "transfer_to_pool",
    flags = ["T"],
    message = transfer_to_pool_auth_message(*)
);

function transfer_to_pool_auth_message(gtv): text {
    val args = struct<transfer_to_pool>.from_gtv(gtv);

    return "Please sign the message\nto transfer %s %s from account {account_id} \nto pool account.".format(
        ft4.assets.format_amount_with_decimals(args.amount, chain_context.args.asset_decimals),
        chain_context.args.asset_symbol);
}

function transfer_to_pool_impl(amount: big_integer) {
    require_initialized();

    val account = ft4.auth.authenticate();
    require(user @? { account }, "No user for account %s".format(account.id));

    ft4.assets.Unsafe.transfer(account, get_pool_account(), get_asset(), amount);
}