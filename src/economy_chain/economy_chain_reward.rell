function pay_rewards(cluster: cluster, node_availability_report: node_availability_report) {

    val is_system_cluster = cluster.name == system_cluster_name;
    val node_reward = if (is_system_cluster)
            calculate_system_cluster_rewards(cluster, node_availability_report)
        else
            calculate_dapp_cluster_rewards(cluster, node_availability_report);

    pay_out_node_rewards(node_reward);

    if (is_system_cluster){
        pay_out_chromia_foundation_reward();
    }
}

function calculate_system_cluster_rewards(system_cluster: cluster, node_availability_report: node_availability_report): map<node, big_integer> {
    val system_cluster_nodes = cluster_node @* { .cluster == system_cluster} .node;

    val number_of_nodes_in_system_cluster = system_cluster_nodes.size();
    val sum_total_max_revenue_per_dapp_cluster = sum_total_max_revenue_per_dapp_cluster();

    val system_provider_cost_share_per_node = (sum_total_max_revenue_per_dapp_cluster * economy_constants.system_provider_fee_share) / number_of_nodes_in_system_cluster;
    val max_system_provider_reward_per_node = max(economy_constants.total_cost_system_providers * (1 - economy_constants.system_provider_risk_share) + system_provider_cost_share_per_node * economy_constants.system_provider_risk_share, system_provider_cost_share_per_node) * economy_constants.chr_per_usd * units_per_asset;

    val system_node_reward = map<node, big_integer>();
    for (system_cluster_node in system_cluster_nodes) {
        val availability_factor = adjusted_availability_factor(node_availability_report.node_availability[system_cluster_node.pubkey]);
        val system_provider_reward_per_node = max_system_provider_reward_per_node * availability_factor;
        log("Reward calculated for node %s in system cluster based on total_cost_system_providers: %s, system_provider_risk_share: %s, system_provider_cost_share_per_node: %s, system_provider_risk_share: %s, availability_factor: %s, chr_per_usd: %s, units_per_asset: %s, system_provider_fee_share: %s, system_provider_reward_per_node: %s"
            .format(system_cluster_node.pubkey, economy_constants.total_cost_system_providers, economy_constants.system_provider_risk_share, system_provider_cost_share_per_node, economy_constants.system_provider_risk_share, availability_factor, economy_constants.chr_per_usd, units_per_asset, economy_constants.system_provider_fee_share, system_provider_reward_per_node));
        system_node_reward[system_cluster_node] = system_provider_reward_per_node.to_big_integer();
    }
    return system_node_reward;
}

function calculate_dapp_cluster_rewards(cluster: cluster, node_availability_report: node_availability_report): map<node, big_integer> {
    val cluster_nodes = cluster_node @* { cluster } .node;

    val occupancy_rate = occupancy_rate(cluster);
    val dapp_cluster_value = dapp_cluster_value(cluster);
    val number_of_nodes_per_dapp_cluster = cluster_nodes.size();

    val max_dapp_provider_reward_per_node = ((dapp_cluster_value * (1 - economy_constants.dapp_provider_risk_share) + dapp_cluster_value * occupancy_rate * economy_constants.dapp_provider_risk_share) / number_of_nodes_per_dapp_cluster) * economy_constants.chr_per_usd * units_per_asset;
    val node_reward = map<node, big_integer>();
    for (cluster_node in cluster_nodes) {
        val availability_factor = adjusted_availability_factor(node_availability_report.node_availability[cluster_node.pubkey]);
        val dapp_provider_reward_per_node = max_dapp_provider_reward_per_node * availability_factor;
        log("Reward calculated for node %s in cluster %s based on dapp_cluster_value: %s, dapp_provider_risk_share: %s, dapp_cluster_value: %s, occupancy_rate: %s, number_of_nodes_per_dapp_cluster: %s, availability_factor: %s, chr_per_usd: %s, units_per_asset: %s, system_provider_fee_share: %s, staking_reward_fee_share: %s, chromia_foundation_fee_share: %s, resource_pool_margin_fee_share: %s, dapp_provider_reward_per_node: %s"
            .format(cluster_node.pubkey, cluster.name, dapp_cluster_value, economy_constants.dapp_provider_risk_share, dapp_cluster_value, occupancy_rate, number_of_nodes_per_dapp_cluster, availability_factor, economy_constants.chr_per_usd, units_per_asset, economy_constants.system_provider_fee_share, economy_constants.staking_reward_fee_share, economy_constants.chromia_foundation_fee_share, economy_constants.resource_pool_margin_fee_share, dapp_provider_reward_per_node));
        node_reward[cluster_node] = dapp_provider_reward_per_node.to_big_integer();
    }
    return node_reward;
}

function pay_out_chromia_foundation_reward() {
    val sum_total_max_revenue_per_dapp_cluster = sum_total_max_revenue_per_dapp_cluster();
    val chromia_foundation_reward = (sum_total_max_revenue_per_dapp_cluster * economy_constants.chromia_foundation_fee_share * economy_constants.chr_per_usd * units_per_asset).to_big_integer();
    log("Reward calculated for chromia foundation based on sum_total_max_revenue_per_dapp_cluster: %s, chromia_foundation_fee_share: %s, chr_per_usd: %s, units_per_asset: %s is chromia_foundation_reward: %s"
        .format(sum_total_max_revenue_per_dapp_cluster, economy_constants.chromia_foundation_fee_share, economy_constants.chr_per_usd, units_per_asset, chromia_foundation_reward));

    val pool = get_pool_account();
    var pool_balance = get_account_balance(pool);
    val chromia_foundation_account = get_chromia_foundation_account();

    val pay_reward_result = pay_reward(pool, pool_balance, chromia_foundation_account, chromia_foundation.reward_debt, chromia_foundation_reward, "Chromia Foundation");

    chromia_foundation.reward_debt = pay_reward_result.reward_debt;
}

function pay_out_node_rewards(node_reward: map<node, big_integer>) {

    val pool = get_pool_account();
    var pool_balance = get_account_balance(pool);

    for ((node, reward) in node_reward) {
        val provider = node.provider;
        val pa = provider_account @ { provider };

        val pay_reward_result = pay_reward(pool, pool_balance, pa.account, pa.reward_debt, reward, "provider %s".format(pa.provider.pubkey));

        create_or_update_node_payed_reward(node.pubkey, pay_reward_result.payed_reward);
        pa.reward_debt = pay_reward_result.reward_debt;
        pool_balance = pay_reward_result.pool_balance;
    }
}

function pay_reward(pool: ft4.accounts.account, pool_balance: big_integer, account: ft4.accounts.account, reward_debt:big_integer,  reward: big_integer, identity: text): pay_reward_result {
    var total_pool_balance = pool_balance;
    var total_reward_debt = reward + reward_debt;

    var amount_to_transfer = 0L;
    if (total_reward_debt > 0) {
        if (pool_balance >= total_reward_debt) {
            amount_to_transfer = total_reward_debt;
        } else if (pool_balance <= 0) { // No funds to pay reward
            log("Reward pool is empty!");
            amount_to_transfer = 0;
        } else { // Missing funds to pay full reward
            log("Reward pool does not have enough funds to transfer full reward.");
            amount_to_transfer = pool_balance;
        }
        if (amount_to_transfer > 0) {
            log("Transfer reward %s to %s".format(amount_to_transfer, identity));
            if (transfer_reward(pool, account, amount_to_transfer)) {
                total_reward_debt -= amount_to_transfer;
                total_pool_balance -= amount_to_transfer;
            } else {
                log("Unable to transfer reward to %s".format(identity));
            }
        }
    }
    return pay_reward_result(payed_reward = amount_to_transfer, pool_balance = total_pool_balance, reward_debt = total_reward_debt);
}


function sum_total_max_revenue_per_dapp_cluster(): decimal {
    var sum_total_max_revenue_per_dapp_cluster = 0.0;
    val clusters = cluster @* { .name != system_cluster_name };
    for (cluster in clusters) {
        sum_total_max_revenue_per_dapp_cluster += total_max_revenue_per_dapp_cluster(cluster);
    }
    return sum_total_max_revenue_per_dapp_cluster;
}

function total_max_revenue_per_dapp_cluster(cluster: cluster): decimal = (total_available_scus(cluster.cluster_units) - standard_cluster_unit.system_container_units) * cluster.tag.scu_price + cluster.tag.extra_storage_price * (cluster.extra_storage / 1024);

function dapp_provider_fee_share(): decimal = 1 - economy_constants.chromia_foundation_fee_share - economy_constants.resource_pool_margin_fee_share - economy_constants.system_provider_fee_share;

function dapp_cluster_value(cluster: cluster): decimal = total_max_revenue_per_dapp_cluster(cluster) * dapp_provider_fee_share() / (1 + economy_constants.staking_reward_fee_share);

function occupied_scus(cluster: cluster): integer = lease @ { cluster, not .expired } ( @sum .container_units );

function total_available_scus(cluster_units: integer): integer = cluster_units * standard_cluster_unit.container_units;

function occupancy_rate(cluster): decimal = decimal(occupied_scus(cluster)) / (total_available_scus(cluster.cluster_units) - standard_cluster_unit.system_container_units);

function adjusted_availability_factor(availability_factor: decimal): decimal = max(0, availability_factor - 0.9) * 10;

function transfer_reward(pool: ft4.accounts.account, account: ft4.accounts.account, amount: big_integer): boolean {
    return try_call(try_transfer_reward(pool, account, amount, *));
}

function try_transfer_reward(pool: ft4.accounts.account, account: ft4.accounts.account, amount: big_integer) {
    ft4.assets.Unsafe.transfer(get_pool_account(), account, get_asset(), amount);
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "transfer_to_pool",
    flags = ["T"],
    message = transfer_to_pool_auth_message(*)
);

function transfer_to_pool_auth_message(gtv): text {
    val args = struct<transfer_to_pool>.from_gtv(gtv);

    return "Please sign the message\nto transfer %s %s from account {account_id} \nto pool account.".format(
        ft4.assets.format_amount_with_decimals(args.amount, chain_context.args.asset_decimals),
        chain_context.args.asset_symbol);
}

function transfer_to_pool_impl(amount: big_integer) {
    require_initialized();

    val account = ft4.auth.authenticate();
    require(user @? { account }, "No user for account %s".format(account.id));

    ft4.assets.Unsafe.transfer(account, get_pool_account(), get_asset(), amount);
}

function create_or_update_node_payed_reward(node: byte_array, value: big_integer){
    val node_payed_reward = node_payed_reward @? { node };
    if (node_payed_reward == null) {
        create node_payed_reward(node, value, op_context.last_block_time);
    } else {
        update node_payed_reward @ { node } (value, op_context.last_block_time);
    }
}