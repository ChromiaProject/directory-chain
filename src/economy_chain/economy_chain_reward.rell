function pay_rewards(cluster: cluster, node_availability_report: node_availability_report) {

    val node_reward = if (cluster.name == system_cluster_name)
            calculate_system_cluster_rewards(cluster, node_availability_report)
        else
            calculate_dapp_cluster_rewards(cluster, node_availability_report);

    pay_out_node_rewards(node_reward);
}

function calculate_system_cluster_rewards(system_cluster: cluster, node_availability_report: node_availability_report): map<node, big_integer> {
    val system_cluster_nodes = cluster_node @* { .cluster == system_cluster} .node;

    val number_of_nodes_in_system_cluster = system_cluster_nodes.size();
    val sum_total_max_revenue_per_dapp_cluster = sum_total_max_revenue_per_dapp_cluster(system_cluster);

    val system_provider_cost_share_per_node = (sum_total_max_revenue_per_dapp_cluster * economy_constants.system_provider_fee_share) / number_of_nodes_in_system_cluster;
    val max_system_provider_reward_per_node = max(economy_constants.total_cost_system_providers * (1 - economy_constants.system_provider_risk_share) + system_provider_cost_share_per_node * economy_constants.system_provider_risk_share, system_provider_cost_share_per_node) * economy_constants.chr_per_usd * units_per_asset;

    val system_node_reward = map<node, big_integer>();
    for (system_cluster_node in system_cluster_nodes) {
        val availability_factor = adjusted_availability_factor(node_availability_report.node_availability[system_cluster_node.pubkey]);
        val system_provider_reward_per_node = max_system_provider_reward_per_node * availability_factor;
        log("Reward calculated for node %s in system cluster based on total_cost_system_providers: %s, system_provider_risk_share: %s, system_provider_cost_share_per_node: %s, system_provider_risk_share: %s, availability_factor: %s, chr_per_usd: %s, units_per_asset: %s, system_provider_fee_share: %s, system_provider_reward_per_node: %s"
            .format(system_cluster_node.pubkey, economy_constants.total_cost_system_providers, economy_constants.system_provider_risk_share, system_provider_cost_share_per_node, economy_constants.system_provider_risk_share, availability_factor, economy_constants.chr_per_usd, units_per_asset, economy_constants.system_provider_fee_share, system_provider_reward_per_node));
        system_node_reward[system_cluster_node] = system_provider_reward_per_node.to_big_integer();
    }
    return system_node_reward;
}

function calculate_dapp_cluster_rewards(cluster: cluster, node_availability_report: node_availability_report): map<node, big_integer> {
    val cluster_nodes = cluster_node @* { cluster } .node;

    val occupancy_rate = occupancy_rate(cluster);
    val dapp_cluster_value = dapp_cluster_value(cluster);
    val number_of_nodes_per_dapp_cluster = cluster_nodes.size();

    val max_dapp_provider_reward_per_node = ((dapp_cluster_value * (1 - economy_constants.dapp_provider_risk_share) + dapp_cluster_value * occupancy_rate * economy_constants.dapp_provider_risk_share) / number_of_nodes_per_dapp_cluster) * economy_constants.chr_per_usd * units_per_asset;
    val node_reward = map<node, big_integer>();
    for (cluster_node in cluster_nodes) {
        val availability_factor = adjusted_availability_factor(node_availability_report.node_availability[cluster_node.pubkey]);
        val dapp_provider_reward_per_node = max_dapp_provider_reward_per_node * availability_factor;
        log("Reward calculated for node %s in cluster %s based on dapp_cluster_value: %s, dapp_provider_risk_share: %s, dapp_cluster_value: %s, occupancy_rate: %s, number_of_nodes_per_dapp_cluster: %s, availability_factor: %s, chr_per_usd: %s, units_per_asset: %s, system_provider_fee_share: %s, staking_reward_fee_share: %s, chromia_foundation_fee_share: %s, resource_pool_margin_fee_share: %s, dapp_provider_reward_per_node: %s"
            .format(cluster_node.pubkey, cluster.name, dapp_cluster_value, economy_constants.dapp_provider_risk_share, dapp_cluster_value, occupancy_rate, number_of_nodes_per_dapp_cluster, availability_factor, economy_constants.chr_per_usd, units_per_asset, economy_constants.system_provider_fee_share, economy_constants.staking_reward_fee_share, economy_constants.chromia_foundation_fee_share, economy_constants.resource_pool_margin_fee_share, dapp_provider_reward_per_node));
        node_reward[cluster_node] = dapp_provider_reward_per_node.to_big_integer();
    }
    return node_reward;
}

function pay_out_node_rewards(node_reward: map<node, big_integer>) {

    val pool = get_pool_account();
    var pool_balance = get_account_balance(pool);

    for ((node, reward) in node_reward) {
        val provider = node.provider;
        val pa = provider_account @ { provider };

        val debt = pa.reward_debt;
        if (debt > 0) pa.reward_debt = 0;

        val total = reward + debt;
        if (total > 0) {
            if (pool_balance >= total) {
                if (transfer_reward(pool, pa, total)) {
                    create_or_update_node_payed_reward(node.pubkey, total);
                    pool_balance -= total;
                } else {
                    pa.reward_debt = total;
                }
            } else if (pool_balance <= 0) { // No funds to pay reward
                log("Reward pool is empty!");
                pa.reward_debt = total;
            } else { // Missing funds to pay full reward
                log("Reward pool does not have enough funds to transfer full reward.");
                if (transfer_reward(pool, pa, pool_balance)) {
                    create_or_update_node_payed_reward(node.pubkey, pool_balance);
                    pa.reward_debt = total - pool_balance;
                    pool_balance = 0;
                } else {
                    pa.reward_debt = total;
                }
            }
        }
    }
}

function sum_total_max_revenue_per_dapp_cluster(system_cluster: cluster): decimal {
    var sum_total_max_revenue_per_dapp_cluster = 0.0;
    val clusters = cluster @* { $ != system_cluster };
    for (cluster in clusters) {
        sum_total_max_revenue_per_dapp_cluster += total_max_revenue_per_dapp_cluster(cluster);
    }
    return sum_total_max_revenue_per_dapp_cluster;
}

function total_max_revenue_per_dapp_cluster(cluster: cluster): decimal = (total_available_scus(cluster.cluster_units) - standard_cluster_unit.system_container_units) * cluster.tag.scu_price + cluster.tag.extra_storage_price * (cluster.extra_storage / 1024);

function dapp_provider_fee_share(): decimal = 1 - economy_constants.chromia_foundation_fee_share - economy_constants.resource_pool_margin_fee_share - economy_constants.system_provider_fee_share;

function dapp_cluster_value(cluster: cluster): decimal = total_max_revenue_per_dapp_cluster(cluster) * dapp_provider_fee_share() / (1 + economy_constants.staking_reward_fee_share);

function occupied_scus(cluster: cluster): integer = lease @ { cluster, not .expired } ( @sum .container_units );

function total_available_scus(cluster_units: integer): integer = cluster_units * standard_cluster_unit.container_units;

function occupancy_rate(cluster): decimal = decimal(occupied_scus(cluster)) / (total_available_scus(cluster.cluster_units) - standard_cluster_unit.system_container_units);

function adjusted_availability_factor(availability_factor: decimal): decimal = max(0, availability_factor - 0.9) * 10;

function transfer_reward(pool: ft4.accounts.account, pa: provider_account, amount: big_integer): boolean {
    log("Transfer reward %s to provider %s".format(amount, pa.provider.pubkey));
    val success = try_call(try_transfer_reward(pool, pa, amount, *));
    if (not success) {
        log("Unable to transfer reward to provider %s".format(pa.provider.pubkey));
    }
    return success;
}

function try_transfer_reward(pool: ft4.accounts.account, pa: provider_account, amount: big_integer) {
    ft4.assets.Unsafe.transfer(get_pool_account(), pa.account, get_asset(), amount);
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "transfer_to_pool",
    flags = ["T"],
    message = transfer_to_pool_auth_message(*)
);

function transfer_to_pool_auth_message(gtv): text {
    val args = struct<transfer_to_pool>.from_gtv(gtv);

    return "Please sign the message\nto transfer %s %s from account {account_id} \nto pool account.".format(
        ft4.assets.format_amount_with_decimals(args.amount, chain_context.args.asset_decimals),
        chain_context.args.asset_symbol);
}

function transfer_to_pool_impl(amount: big_integer) {
    require_initialized();

    val account = ft4.auth.authenticate();
    require(user @? { account }, "No user for account %s".format(account.id));

    ft4.assets.Unsafe.transfer(account, get_pool_account(), get_asset(), amount);
}

function create_or_update_node_payed_reward(node: byte_array, value: big_integer){
    val node_payed_reward = node_payed_reward @? { node };
    if (node_payed_reward == null) {
        create node_payed_reward(node, value, op_context.last_block_time);
    } else {
        update node_payed_reward @ { node } (value, op_context.last_block_time);
    }
}