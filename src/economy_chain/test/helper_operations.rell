module;

import ^^.*;
import ^^.ec_proposal.test.helper_operations.*;

operation icmf_message_op(sender: byte_array, topic: text, body: gtv) {
    handle_icmf_message(sender, topic, body);
}

operation empty_account_op(ft4.accounts.account) {
    val balance = get_account_balance(account);
    ft4.assets.Unsafe.transfer(account, get_pool_account(), get_asset(), balance);
}

operation mint_to_pool(amount: big_integer) {
    ft4.assets.Unsafe.mint(get_pool_account(), get_asset(), amount);
}

operation create_pending_cluster(cluster_name: text, tag_name: text, status: pending_cluster_status = pending_cluster_status.PENDING_APPROVAL) {

    val tag = create_or_return_tag(tag_name);
    val proposal = create_proposal(ec_proposal_type.cluster_create);

    create pending_cluster(
        name = cluster_name,
        tag,
        proposer_pubkey = x"",
        governor_voter_set_name = "governor_voter_set_name",
        voter_set_name = "voter_set_name",
        cluster_units = 1,
        extra_storage = 1,
        proposal,
        status
    );
}

operation create_pending_tag_operation(name: text, scu_price: integer = -1, extra_storage_price: integer = -1) {

    val proposal = create_proposal(ec_proposal_type.tag_create);
    create pending_tag_operation(
        name,
        proposal,
        scu_price = scu_price,
        extra_storage_price = extra_storage_price
    );
}

operation create_pending_cluster_change_tag(cluster_name: text, current_tag_name: text, new_tag_name: text) {

    val current_tag = create_or_return_tag(current_tag_name);
    val new_tag = create_or_return_tag(new_tag_name);
    val proposal = create_proposal(ec_proposal_type.cluster_create);

    val cluster = create cluster(cluster_name, true, cluster_units = 1, extra_storage = 1, anchoring_chain = x"", current_tag);
    create pending_cluster_change_tag(cluster, proposal, new_tag);
}

operation create_test_cluster(cluster_name: text, tag_name: text = "test-tag") {
    val tag = create tag(tag_name, scu_price = 1, extra_storage_price = 1);
    create cluster(name = cluster_name, operational = true, cluster_units = 1, extra_storage = 1, anchoring_chain = x"", tag = tag);
}

operation create_lease(container_name: text, container_units: integer, account: ft4.accounts.account, cluster: cluster, expired: boolean) {
    create lease(
        container_name = container_name,
        account = account,
        container_units = container_units,
        cluster = cluster,
        start_time = 0,
        duration_millis = 0,
        expired = expired,
        auto_renew = false,
        extra_storage_gib = 0
    );
}

operation pay_rewards_op(cluster: cluster, node_availability_report: node_availability_report) {
    pay_rewards(cluster, node_availability_report);
}

operation set_reward_debt_op(provider_pubkey: pubkey, reward_debt: big_integer) {
    val pa = provider_account @ { provider @ { provider_pubkey } };
    pa.reward_debt = reward_debt;
}

operation receive_create_cluster_error_message_op(cluster_name: text, error_message: text) {
    receive_create_cluster_error_message(create_cluster_error_message(name = cluster_name, error_message = error_message).to_gtv());
}

operation receive_cluster_update_message_op(message: cluster_update_message) {
    receive_cluster_update_message(message.to_gtv());
}

operation create_cluster_node_op(cluster, node) {
    create cluster_node(cluster, node);
}

operation save_node_availability_op(report: node_availability_report) {
    save_node_availability(report);
}

operation create_or_update_node_payed_reward_op(node: byte_array, value: big_integer) {
    create_or_update_node_payed_reward(node, value);
}

operation receive_provider_update_message_op(provider_update_message) {
    receive_provider_update_message(provider_update_message.to_gtv());
}

operation create_tag_removal_proposal_with_voter_set(voter_set_name: text) {

    create_proposal(ec_proposal_type.tag_remove, voter_set_name);
}

function create_or_return_tag(tag_name: text) {
    var tag = tag @? { tag_name };
    if (tag == null) {
        tag = create tag(tag_name, scu_price = 1, extra_storage_price = 1);
    }
    return tag;
}

function create_or_return_provider(pubkey, system: boolean) {
    var provider = provider @? { pubkey };
    if (provider == null) {
        provider = create provider(pubkey, system = system, provider_tier.NODE_PROVIDER, active = true);
    }
    return provider;
}
