@test module;

import ^^.*;
import ^.helper_functions.*;

namespace ft4 {
    import lib.ft4.accounts;
    import lib.ft4.assets;
    import lib.ft4.auth;
    import test_utils: lib.ft4.test.utils;
}
import lib.auth;

struct module_args {
    auth_privkey: byte_array;
    admin_privkey: byte_array;
}

val auth_privkey = chain_context.args.auth_privkey;
val provider_key = rell.test.keypairs.bob;
val provider_pubkey = provider_key.pub;
val node_pubkey = rell.test.pubkeys.charlie;
val base_reward: big_integer = 1360015000; // SCU = 16, extra_storage = 1024, 5 CHR/USD
val system_node_reward: big_integer = 170000000; // system node reward = 34, 5 CHR/USD
val base_time = 10000000000000;


// TODO adapt to implementation when in place
//function test_asset_units() {
//    assert_equals(units_per_asset, 1000000);
//}
//
//function test_rewards_with_no_providers() {
//    rell.test.tx().op(init()).run();
//
//    add_assets_to_pool(20000000);
//    assert_equals(get_pool_balance(), 20000000);
//
//    rell.test.block().run();
//
//    assert_equals(get_pool_balance(), 20000000);
//}
//
//function test_provider_is_not_rewarded_due_to_node_not_in_cluster() {
//    reward_setup(base_reward, false);
//
//    rell.test.block().run();
//
//    val pa = provider_account @ { provider @ { provider_pubkey } };
//    assert_equals(get_account_balance(pa.account), 0);
//    assert_equals(pa.reward_debt, 0);
//    assert_equals(get_pool_balance(), base_reward);
//}
//
//function test_provider_is_rewarded() {
//    reward_setup(base_reward * 2);
//
//    rell.test.block().run();
//
//    val pa = provider_account @ { provider @ { provider_pubkey } };
//    assert_equals(get_account_balance(pa.account), base_reward);
//    assert_equals(pa.reward_debt, 0);
//    assert_equals(get_pool_balance(), base_reward);
//}
//
//function test_provider_is_rewarded_for_system_node() {
//    reward_setup(base_reward, false, true);
//
//    rell.test.block().run();
//
//    val pa = provider_account @ { provider @ { provider_pubkey } };
//    assert_equals(get_account_balance(pa.account), system_node_reward);
//    assert_equals(pa.reward_debt, 0);
//    assert_equals(get_pool_balance(), base_reward - system_node_reward);
//}
//
//function test_provider_is_rewarded_for_cluster_node_and_system_node() {
//    reward_setup(base_reward * 2, true, true);
//
//    rell.test.block().run();
//
//    val pa = provider_account @ { provider @ { provider_pubkey } };
//    assert_equals(get_account_balance(pa.account), base_reward + system_node_reward);
//    assert_equals(pa.reward_debt, 0);
//    assert_equals(get_pool_balance(), base_reward - system_node_reward);
//}
//
//function test_provider_is_rewarded_and_with_debt() {
//    val debt = 7000000;
//    reward_setup(base_reward - debt);
//
//    rell.test.block().run();
//
//    val pa = provider_account @ { provider @ { provider_pubkey } };
//    assert_equals(get_account_balance(pa.account), base_reward - debt);
//    assert_equals(pa.reward_debt, debt);
//    assert_equals(get_pool_balance(), 0);
//}
//
//function test_provider_is_not_rewarded_due_to_lack_of_funds() {
//    reward_setup(0);
//
//    rell.test.block().run();
//
//    val pa = provider_account @ { provider @ { provider_pubkey } };
//    assert_equals(get_account_balance(pa.account), 0);
//    assert_equals(pa.reward_debt, base_reward);
//    assert_equals(get_pool_balance(), 0);
//}
//
//function test_provider_is_rewarded_correct_amount_of_times() {
//    reward_setup(base_reward * 3);
//
//    rell.test.set_block_interval(millis_per_day / 2);
//    log ("Should transfer");
//    rell.test.block().run(); // 1 day has passed => Transfer reward
//    log ("Should NOT transfer");
//    rell.test.block().run(); // less then 1 day has passed => Do not transfer reward
//    log ("Should transfer");
//    rell.test.block().run(); // 1 day has passed => Transfer reward
//
//    val pa = provider_account @ { provider @ { provider_pubkey } };
//    assert_equals(get_account_balance(pa.account), base_reward * 2);
//    assert_equals(pa.reward_debt, 0);
//    assert_equals(get_pool_balance(), base_reward);
//}
//
//function test_transfer_to_pool() {
//    rell.test.tx().op(init()).run();
//
//    val alice = require(do_create_account(rell.test.keypairs.alice, auth_privkey));
//    val amount: big_integer = 10;
//
//    assert_equals(get_pool_balance(), 0);
//
//    rell.test.tx().op(
//        ft4.test_utils.evm_auth_operation_for(rell.test.privkeys.alice, "transfer_to_pool",
//            [amount.to_gtv()])
//    ).op(
//        transfer_to_pool(amount)
//    ).run();
//
//    assert_equals(get_pool_balance(), amount);
//}

///////////////////
// Helper functions

function reward_setup(pool_assets: big_integer = 0, add_cluster_node: boolean = true, add_to_system_cluster: boolean = false) {
    rell.test.tx().op(init()).run();

    val provider_key = rell.test.keypairs.bob;
    val provider_pubkey = provider_key.pub;
    val node_pubkey = rell.test.pubkeys.charlie;
    val cluster_name = "Bob's cluster";

    val provider = add_provider(provider_pubkey, false, provider_tier.NODE_PROVIDER, null);
    val node = ensure_node(provider_pubkey, node_pubkey, true, "SE", 1, 1024, false);
    val cluster = ensure_cluster(cluster_name, false, false, 1, 1024, "");
    if (add_cluster_node) add_cluster_node(cluster_name, node_pubkey, false);
    if (add_to_system_cluster) {
        ensure_cluster(system_cluster_name, false, true, 1, 0, "");
        add_cluster_node(system_cluster_name, node_pubkey, false);
    }

    assert_true(node.active);
    assert_equals(node.cluster_units, 1);
    assert_equals(node.extra_storage, 1024);

    if (pool_assets > 0) add_assets_to_pool(pool_assets);
    assert_equals(get_pool_balance(), pool_assets);

    rell.test.set_next_block_time(base_time);
    rell.test.tx().op(
        register_provider_account(provider_pubkey)
    ).sign(provider_key).run();

    // Set block interval and initiate with first block to run first check
    // which will do nothing except set last_reward_check to non-zero.
    rell.test.set_block_interval(millis_per_day);
    rell.test.block().run(); // First check => Do not transfer reward
}