@test module;

import ^^.*;
import ^.helper_functions.*;
import ^.helper_operations.*;

namespace ft4 {
    import lib.ft4.accounts;
    import lib.ft4.assets;
    import lib.ft4.auth;
    import test_utils: lib.ft4.test.utils;
}
import lib.auth;

function test_set_rates() {
    rell.test.tx().op(init()).run();

    rell.test.set_next_block_time_delta(staking_get_cannot_change_before());
    rell.test.tx().op(
        staking_set_rates(0.1, 0.4)
    ).run();

    val initial_rate = staking_get_current_rates();
    assert_equals(initial_rate.delegator_rate, 0.1);
    assert_equals(initial_rate.provider_rate, 0.4);

    rell.test.set_next_block_time_delta(staking_config.rate_change_delay_ms);
    rell.test.tx().op(
        staking_set_rates(0.5, 0.9)
    ).run();

    val second_rate = staking_get_current_rates();
    assert_equals(second_rate.delegator_rate, 0.5);
    assert_equals(second_rate.provider_rate, 0.9);

    rell.test.tx().op(
        staking_set_rates(0.05, 0.008) // Won't take effect
    ).run();

    val third_rate = staking_get_current_rates();
    assert_equals(third_rate.delegator_rate, 0.5);
    assert_equals(third_rate.provider_rate, 0.9);
}

function test_add_remove_providers() {
    rell.test.tx().op(init()).run();

    rell.test.tx().op(
        staking_set_rates(0.5, 0.9)
    ).run();

    assert_false(staking_is_active_provider(rell.test.pubkeys.charlie));

    rell.test.tx().op(
        staking_remove_provider(rell.test.pubkeys.charlie)
    ).run_must_fail("Provider not active.");

    rell.test.tx()
        .op(staking_add_provider('Charlie', rell.test.pubkeys.charlie))
        .op(staking_add_provider('Bob', rell.test.pubkeys.bob))
    .run();

    rell.test.tx().op(
        staking_add_provider('Charlie Too', rell.test.pubkeys.charlie)
    ).run_must_fail("Provider cannot be active.");

    assert_true(staking_is_active_provider(rell.test.pubkeys.charlie));

    // Add some delegation
    rell.test.tx()
        // Have A deposit and delegate to C
        .op(staking_deposit(rell.test.pubkeys.alice, 9999999))
        .op(staking_delegate(rell.test.pubkeys.alice, rell.test.pubkeys.charlie))
        // Have D deposit 11 and delagate to B
        .op(staking_deposit(rell.test.pubkeys.dave, 11))
        .op(staking_delegate(rell.test.pubkeys.dave, rell.test.pubkeys.bob))
    .run();

    // Wait for delegation to take effect
    rell.test.set_next_block_time_delta(staking_config.rate_change_delay_ms);
    rell.test.block().run();
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.charlie), 9999999);
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.bob), 11);

    rell.test.tx().op(
        staking_remove_provider(rell.test.pubkeys.charlie)
    ).run();

    assert_false(staking_is_active_provider(rell.test.pubkeys.charlie));

    // Ensure delegates have been removed
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.charlie), 0); // <- Removed immediately
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.bob), 11); // <- Unchanged

    // Should have earned something
    assert_true(staking_rewards_claimable_for(rell.test.pubkeys.alice) > 0);
}

function test_delegation() {
    rell.test.tx().op(init()).run();

    rell.test.tx().op(
        staking_set_rates(0.5, 0.9)
    ).run();

    rell.test.set_next_block_time_delta(staking_config.rate_change_delay_ms + 1);
    rell.test.block().run();

    assert_equals(staking_rewards_claimable_for(rell.test.pubkeys.alice), 0);
    assert_equals(staking_rewards_claimable_for(rell.test.pubkeys.bob), 0);

    rell.test.tx().op(
        staking_delegate(rell.test.pubkeys.alice, rell.test.pubkeys.charlie)
    ).run_must_fail("Must be active provider.");

    rell.test.tx()
        .op(staking_add_provider('Charlie', rell.test.pubkeys.charlie))
        .op(staking_deposit(rell.test.pubkeys.alice, 8000))
        .op(staking_delegate(rell.test.pubkeys.alice, rell.test.pubkeys.charlie))
    .run();

    rell.test.set_next_block_time_delta(staking_config.rate_change_delay_ms);
    rell.test.block().run();
    assert_equals(staking_get_current_delegate(rell.test.pubkeys.alice), rell.test.pubkeys.charlie);

    assert_true(staking_rewards_claimable_for(rell.test.pubkeys.alice) > 0);

    rell.test.tx().op(
        staking_undelegate(rell.test.pubkeys.alice)
    ).run();

    assert_equals(staking_get_current_delegate(rell.test.pubkeys.alice), rell.test.pubkeys.charlie); // No change now.

    rell.test.set_next_block_time_delta(staking_config.rate_change_delay_ms);
    rell.test.block().run();
    assert_equals(staking_get_current_delegate(rell.test.pubkeys.alice), NO_ONE); // Change in a week
}

function test_staking_deposit() {
    rell.test.tx().op(init()).run();

    assert_equals(staking_get_balance(rell.test.pubkeys.alice), 0);
    rell.test.tx().op(
        staking_deposit(rell.test.pubkeys.alice, 7777)
    ).run();
    assert_equals(staking_get_balance(rell.test.pubkeys.alice), 7777);
}

function test_withdrawal() {
    rell.test.tx().op(init()).run();

    // Need a deposit to withdraw it
    assert_equals(staking_get_balance(rell.test.pubkeys.alice), 0);
    rell.test.tx().op(
        staking_request_withdrawal(rell.test.pubkeys.alice)
    ).run_must_fail("Need something to withdraw.");

    // Cannot withdraw without withdrawal request
    rell.test.tx()
        .op(staking_deposit(rell.test.pubkeys.alice, 7777))
        .op(staking_withdraw(rell.test.pubkeys.alice))
    .run_must_fail("Need a withdrawal request.");

    rell.test.tx()
        .op(staking_deposit(rell.test.pubkeys.alice, 7777))
        .op(staking_request_withdrawal(rell.test.pubkeys.alice))
    .run();

    // Cannot withdraw without aged withdrawal request
    rell.test.tx().op(
        staking_withdraw(rell.test.pubkeys.alice)
    ).run_must_fail("Need to wait for withdrawal request.");
    assert_equals(staking_get_balance(rell.test.pubkeys.alice), 7777);

    // Simple withdraw
    rell.test.set_next_block_time_delta(staking_config.withdrawal_delay_ms);
    rell.test.block().run();

    rell.test.tx().op(
        staking_withdraw(rell.test.pubkeys.alice)
    ).run();
    assert_equals(staking_get_balance(rell.test.pubkeys.alice), 0);

    // Ensure that the withdrawal request is cancelled on re-delegation
    rell.test.tx()
        .op(staking_deposit(rell.test.pubkeys.alice, 7777))
        .op(staking_request_withdrawal(rell.test.pubkeys.alice))
    .nop().run();
    assert_false(null == staking_get_withdrawal_time(rell.test.pubkeys.alice));
    rell.test.tx()
        .op(staking_add_provider('Bob', rell.test.pubkeys.bob))
        .op(staking_delegate(rell.test.pubkeys.alice, rell.test.pubkeys.bob))
    .run();
    assert_true(null == staking_get_withdrawal_time(rell.test.pubkeys.alice));

    // Only one withdrawal request at a time
    rell.test.tx()
        .op(staking_deposit(rell.test.pubkeys.alice, 7777))
        .op(staking_request_withdrawal(rell.test.pubkeys.alice))
        .op(staking_request_withdrawal(rell.test.pubkeys.alice))
    .run_must_fail("Only one withdrawal request at a time.");
}

function test_staking_get_total_delegation_to() {
    rell.test.tx().op(init()).run();

    assert_false(staking_is_active_provider(rell.test.pubkeys.bob));
    rell.test.tx()
        // Add A to the provider list
        .op(staking_add_provider('Alice', rell.test.pubkeys.alice))
        // Add B to the provider list
        .op(staking_add_provider('Bob', rell.test.pubkeys.bob))
        // Have C deposit 9 and delegate to A
        .op(staking_deposit(rell.test.pubkeys.charlie, 9))
        .op(staking_delegate(rell.test.pubkeys.charlie, rell.test.pubkeys.alice))
        // Have D deposit 11 and delagate to B
        .op(staking_deposit(rell.test.pubkeys.dave, 11))
        .op(staking_delegate(rell.test.pubkeys.dave, rell.test.pubkeys.bob))
    .run();

    // Check the that neither A nor B has a balance delegated to them
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.alice), 0);
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.bob), 0);

    // Wait a period
    rell.test.set_next_block_time_delta(staking_config.rate_change_delay_ms);
    rell.test.block().run();

    // Check that A has 9 delegated to it
    // Check that B has 11 delegated to it
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.alice), 9);
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.bob), 11);

    // Have C deposit an additional 7
    rell.test.tx()
        .op(staking_deposit(rell.test.pubkeys.charlie, 7))
    .run();

    // Check that A has 16 delegated to it (adding stake is immediate)
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.alice), 16);

    // Have D change their their delegation to A
    rell.test.tx()
        .op(staking_delegate(rell.test.pubkeys.dave, rell.test.pubkeys.alice))
    .run();

    // Check that A has 16 delegated to it (changing delegation takes time)
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.alice), 16);

    // Wait a period
    rell.test.set_next_block_time_delta(staking_config.rate_change_delay_ms);
    rell.test.block().run();

    // Check that A has 27 delegated to it
    // Check that B has 0 delegated to it
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.alice), 27);
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.bob), 0);

    // Have D undelegate
    rell.test.tx()
        .op(staking_undelegate(rell.test.pubkeys.dave))
    .run();

    // Wait a period
    rell.test.set_next_block_time_delta(staking_config.rate_change_delay_ms);
    rell.test.block().run();

    // Check that A has 16 delegated to it
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.alice), 16);
    assert_equals(staking_get_total_delegation_to(rell.test.pubkeys.bob), 0);
}