query get_tags(): list<tag_data> = tag @* {} (tag_data(.name, .scu_price, .extra_storage_price));

query get_tag_by_name(name): tag_data? = tag @? { name } (tag_data(.name, .scu_price, .extra_storage_price));

query get_pool_balance(): big_integer = get_account_balance(get_pool_account());

query get_create_container_ticket_by_transaction(tx_rid: byte_array): container_ticket_data? =
        create_container_ticket @? { .ticket.transaction.tx_rid == tx_rid }
            (container_ticket_data(.ticket.rowid.to_integer(), .ticket.type, .ticket.state, error_message = .ticket.error_message, container_name = .container_name));

query get_create_container_ticket_by_id(ticket_id: integer): container_ticket_data? =
        create_container_ticket @? { .ticket.rowid == rowid(ticket_id) }
            (container_ticket_data(.ticket.rowid.to_integer(), .ticket.type, .ticket.state, error_message = .ticket.error_message, container_name = .container_name));

query get_upgrade_container_ticket_by_transaction(tx_rid: byte_array): container_ticket_data? =
        upgrade_container_ticket @? { .ticket.transaction.tx_rid == tx_rid }
            (container_ticket_data(.ticket.rowid.to_integer(), .ticket.type, .ticket.state, error_message = .ticket.error_message, container_name = .container_name));

query get_upgrade_container_ticket_by_id(ticket_id: integer): container_ticket_data? =
        upgrade_container_ticket @? { .ticket.rowid == rowid(ticket_id) }
            (container_ticket_data(.ticket.rowid.to_integer(), .ticket.type, .ticket.state, error_message = .ticket.error_message, container_name = .container_name));

query get_leases_by_account(account_id: byte_array): list<lease_data> =
        lease @* { .account.id == account_id } (lease_data(container_name = .container_name, cluster_name = .cluster.name, container_units = .container_units, extra_storage_gib = .extra_storage_gib, expire_time_millis = .start_time + .duration_millis, .expired, .auto_renew));

query get_lease_by_container_name(container_name: text): lease_data? =
        lease @? { container_name } (lease_data(container_name = .container_name, cluster_name = .cluster.name, container_units = .container_units, extra_storage_gib = .extra_storage_gib, expire_time_millis = .start_time + .duration_millis, .expired, .auto_renew));

query get_min_lease_duration(): integer = economy_constants.min_lease_time_weeks;

query get_max_lease_duration(): integer = economy_constants.max_lease_time_weeks;

query get_chr_asset() = ft4.assets.map_asset(get_asset());

query get_balance(account_id: byte_array): big_integer {
    val account = require(ft4.accounts.account @? { account_id }, "Account %s not found".format(account_id));
    return get_account_balance(account);
}

query get_provider_account_id(provider_pubkey: pubkey): byte_array? {
    val provider = require(provider @? { provider_pubkey }, "No provider found with pubkey %s".format(provider_pubkey));
    val account = provider_account @? { provider }.account;
    return account?.id;
}

query get_economy_constants(): economy_constants_data = economy_constants_data(
    min_lease_time_weeks = economy_constants.min_lease_time_weeks,
    max_lease_time_weeks = economy_constants.max_lease_time_weeks,
    chr_per_usd = economy_constants.chr_per_usd,
    total_cost_system_providers = economy_constants.total_cost_system_providers,
    system_provider_fee_share = economy_constants.system_provider_fee_share,
    staking_reward_fee_share = economy_constants.staking_reward_fee_share,
    chromia_foundation_fee_share = economy_constants.chromia_foundation_fee_share,
    resource_pool_margin_fee_share = economy_constants.resource_pool_margin_fee_share,
    system_provider_risk_share = economy_constants.system_provider_risk_share,
    dapp_provider_risk_share = economy_constants.dapp_provider_risk_share
);

query get_clusters(): list<cluster_data> {
    return cluster @* {} (
        cluster_data(
            name = .name,
            tag_name = .tag.name
        ));
}

query get_cluster_by_name(name): cluster_data? = cluster @? { name } (
    cluster_data(
        name = .name,
        tag_name = .tag.name
    )
);

query get_cluster_creation_status(name): cluster_creation_status {
    var status = cluster_creation_status.SUCCESS;
    val cluster = cluster @? { name };
    if (cluster == null) {
        val pending_cluster = pending_cluster @? { name };
        if (pending_cluster == null) {
            status = cluster_creation_status.UNKNOWN;
        } else if (pending_cluster.status == pending_cluster_status.PENDING_APPROVAL) {
            status = cluster_creation_status.PENDING_APPROVAL;
        } else if (pending_cluster.status == pending_cluster_status.PENDING_CREATION) {
            status = cluster_creation_status.PENDING_CREATION;
        } else if (pending_cluster.status == pending_cluster_status.FAILURE) {
            status = cluster_creation_status.FAILURE;
        }
    }
    return status;
}

query get_economy_metrics(pubkey): economy_metrics {
    val provider = require_provider(pubkey);
    val provider_nodes = node @* { provider };
    val last_block_time = block @ {} (@max .timestamp) ?: 0;

    val average_availability_on_a_providers_nodes = get_average_availability_on_a_providers_nodes(provider_nodes, last_block_time);
    val total_number_of_nodes_per_provider = get_total_number_of_nodes_per_provider(provider_nodes);
    val total_number_of_scus_per_provider = get_total_number_of_scus_per_provider(provider_nodes);
    val average_occupancy_rate_of_a_providers_scus = get_average_occupancy_rate_of_a_providers_scus(provider_nodes);
    val amount_of_the_last_reward_payout = get_amount_of_the_last_reward_payout(provider_nodes, last_block_time);

    return economy_metrics(
        average_availability_on_a_providers_nodes,
        total_number_of_nodes_per_provider,
        total_number_of_scus_per_provider,
        average_occupancy_rate_of_a_providers_scus,
        amount_of_the_last_reward_payout
    );
}

function get_average_availability_on_a_providers_nodes(provider_nodes: list<node>, last_block_time: integer): decimal {
    var number_of_nodes = 0;
    var total_availability = 0.0;
    for (node in provider_nodes) {
        val node_availability = node_availability @? { .node == node.pubkey };
        if (node_availability != null and last_block_time - node_availability.end_time <= millis_per_day) {
            number_of_nodes++;
            total_availability += node_availability.availability;
        }
    }
    return if (number_of_nodes != 0 ) total_availability / number_of_nodes  else 0.0;
}

function get_total_number_of_nodes_per_provider(provider_nodes: list<node>): integer {
    return provider_nodes.size();
}

function get_total_number_of_scus_per_provider(provider_nodes: list<node>): integer {
    var provider_nodes_total_cluster_units = 0;
    for (node in provider_nodes) {
        provider_nodes_total_cluster_units += node.cluster_units;
    }
    return provider_nodes_total_cluster_units * standard_cluster_unit.container_units;
}

function get_average_occupancy_rate_of_a_providers_scus(provider_nodes: list<node>): decimal {
    var occupancy_rate = 0.0;
    for (node in provider_nodes) {
        val cluster = cluster_node @ { node } ( .cluster );
        occupancy_rate += occupancy_rate(cluster);
    }
    return occupancy_rate / provider_nodes.size();
}

function get_amount_of_the_last_reward_payout(provider_nodes: list<node>, last_block_time: integer) {
    var total_reward = 0L;
    for (node in provider_nodes) {
        val node_payed_reward = node_payed_reward @? { node.pubkey };
        if (node_payed_reward != null and last_block_time - node_payed_reward.time <=  millis_per_day) {
            total_reward += node_payed_reward.value;
        }
    }
    return total_reward;
}

query get_tag_proposal(proposal_id: rowid): tag_data {

    val proposal = require_proposal(proposal_id);
    val pending_tag_operation = require(pending_tag_operation @? { proposal }, "Proposal is of different type: %s".format(proposal.ec_proposal_type));

    return tag_data(name = pending_tag_operation.name, scu_price = pending_tag_operation.scu_price, extra_storage_price = pending_tag_operation.extra_storage_price);
}

query get_cluster_create_proposal(proposal_id: rowid): pending_cluster_data {

    val proposal = require_proposal(proposal_id);
    val pending_cluster = pending_cluster @ { proposal };

    return pending_cluster_data(
        name = pending_cluster.name,
        tag = pending_cluster.tag.name,
        proposer_pubkey = pending_cluster.proposer_pubkey,
        governor_voter_set_name = pending_cluster.governor_voter_set_name,
        voter_set_name = pending_cluster.voter_set_name,
        cluster_units = pending_cluster.cluster_units,
        extra_storage = pending_cluster.extra_storage,
        status = pending_cluster.status
    );
}

query get_cluster_change_tag_proposal(proposal_id: rowid) {

    val proposal = require_proposal(proposal_id);
    val pending_cluster_change_tag = pending_cluster_change_tag @ { proposal };

    return pending_cluster_change_tag_data(
        cluster = pending_cluster_change_tag.cluster.name,
        current_tag = pending_cluster_change_tag.cluster.tag.name,
        new_tag = pending_cluster_change_tag.tag.name
    );
}
