// Rates

query staking_get_current_rate(): decimal = _staking_get_current_rate();


// Delegations

query staking_get_current_delegate_on_network(account_id: byte_array, network): pubkey? {
    val account = ft4.accounts.Account(account_id);
    val current_delegation = _staking_get_current_delegate(account, network);
    return when(current_delegation) {get_null_provider_account() -> null; else -> current_delegation.provider.pubkey;};
}

query staking_get_current_delegate(account_id: byte_array): pubkey? {
    val account = ft4.accounts.Account(account_id);
    val current_delegation = _staking_get_current_delegate(account, network.CHR);
    return when(current_delegation) {get_null_provider_account() -> null; else -> current_delegation.provider.pubkey;};
}

query staking_get_next_delegation_change(account_id: byte_array) : (pubkey: pubkey, time: integer)? {
    val staker = ft4.accounts.Account(account_id);
    val existing = staker_state @ {.latest and .staker == staker and .network == network.CHR} ( (pubkey = .new_provider.provider.pubkey, time = .cutover_time) );
    return if (_staking_last_known_time() <= existing.time) existing else null;
}

query staking_get_total_delegation_to(pubkey) {
    val provider_account = provider_account @ {.provider.pubkey == pubkey};
    return _staking_get_total_delegation_to(provider_account, network.CHR) + _staking_get_total_delegation_to(provider_account, network.BSC) + _staking_get_total_delegation_to(provider_account, network.ETH);
}

query staking_get_provider_stake(pubkey) {
    val provider = _staking_pubkey_to_provider(pubkey);
    val provider_id = provider.account.id;
    return if (pubkey == staking_get_current_delegate(provider_id) ?: get_null_provider_account().provider.pubkey)
        staking_get_balance(provider_id)
        else 0;
}


// Withdrawals

query staking_get_withdrawal_time(account_id: byte_array): timestamp? {
    val staker = ft4.accounts.Account(account_id);
    return _staking_get_withdrawal_time(staker);
}


// Rewards

query staking_rewards_claimable_for(account_id: byte_array): integer {
    val staker = ft4.accounts.Account(account_id);
    return _staking_rewards_claimable_for(staker, network.CHR) + _staking_rewards_claimable_for(staker, network.BSC) + _staking_rewards_claimable_for(staker, network.ETH);
}

query staking_rewards_for(account_id: byte_array) {
    val staker = ft4.accounts.Account(account_id);
    return _staking_rewards_claimable_since(staker, network.CHR, 0) + _staking_rewards_claimable_since(staker, network.BSC, 0) + _staking_rewards_claimable_since(staker, network.ETH, 0);
}

query staking_get_rewards_paid(account_id: byte_array) {
    val account = ft4.accounts.Account(account_id);
    val total_since_zero = _staking_rewards_claimable_since(account, network.CHR, 0) +  _staking_rewards_claimable_since(account, network.ETH, 0) + _staking_rewards_claimable_since(account, network.BSC, 0);
    val unclaimed = _staking_rewards_claimable_for(account, network.CHR) + _staking_rewards_claimable_for(account, network.BSC) + _staking_rewards_claimable_for(account, network.ETH);
    return total_since_zero - unclaimed;
}


// Balances

query staking_get_balance(account_id: byte_array) {
    val account = ft4.accounts.Account(account_id);
    return _staking_get_balance(account);
}

query staking_get_native_balance(account_id: byte_array) {
    val account = ft4.accounts.Account(account_id);
    return _staking_get_balance_by_network(account, network.CHR);
}


// Statistics

query staking_total_stake() = staker_state @ { .latest } (@sum .balance);
query staking_total_accounts() = staker_state @ { .latest and .network == network.CHR } (@sum 1);


// Date utilites

query staking_get_cannot_change_before(): timestamp = _staking_cannot_change_before();
query staking_get_last_known_time() = _staking_last_known_time();
