query staking_get_current_rate(): decimal {
    val current_rate = reward_rate @* {
        .timestamp<=_staking_last_known_time()
    } (
        .rate,
        @omit @sort_desc .timestamp
    ) limit 1;
    return current_rate[0];
}

query staking_get_current_delegate_on_network(account_id: byte_array, network): byte_array? {
    val _provider_pubkey = staker_state_to_provider @? {
        .staker_state.account.id == account_id and .staker_state.network == network and  
        (_staking_last_known_time() - chain_context.args.staking_rate_change_delay_ms) >= .timestamp
    } ( @omit @sort_desc .timestamp, .provider.pubkey ) limit 1;
    if (not exists(_provider_pubkey)) return null;
    return if (_provider_pubkey == get_null_account()) null else _provider_pubkey;
}
query staking_get_current_delegate(
    account_id: byte_array
) = staking_get_current_delegate_on_network(account_id, network.CHR);

query staking_get_next_delegation_change(account_id: byte_array): (pubkey: pubkey, time: integer)? {
    val staker = ft4.accounts.Account(account_id);
    val upcoming_delegations = staker_state_to_provider @* {
        .staker_state.account == staker and .timestamp > (_staking_last_known_time()-chain_context.args.staking_rate_change_delay_ms)
    } (
        @omit @sort_desc .timestamp,
        pubkey = .provider.pubkey,
        time = .timestamp + chain_context.args.staking_rate_change_delay_ms
    ) limit 1;
    return if (exists(
        upcoming_delegations
    )) (upcoming_delegations[0]) else null;
}

query staking_get_total_delegation_to(pubkey, network? = null) {
    return ( s1: staker_state_to_provider) @* {
        .provider.pubkey == pubkey and (s1.timestamp<=(_staking_last_known_time()-chain_context.args.staking_rate_change_delay_ms)) and 
            (not exists(network) or .staker_state.network == network) and 
            not exists((s2:staker_state_to_provider) @* { 
                s2.staker_state ==s1.staker_state,
                ((s2.timestamp<=(_staking_last_known_time()-chain_context.args.staking_rate_change_delay_ms)) and (s2.timestamp>s1.timestamp)) 
                or (s2.timestamp==s1.timestamp and s2 < s1) 
            }
        )
    } ( @sum .staker_state.balance )[0];
}

// TODO staking_get_provider_stake

query staking_get_withdrawal_time(account_id: byte_array, network = network.CHR): timestamp? {
    return staker_withdrawal_request @? {
        .staker_state.account.id == account_id and .active and .staker_state.network == network
    } (
        .finish_at
    );
}

query staking_rewards_claimable_for(account_id: byte_array) {
    val rate = staking_get_current_rate() / millis_per_year;
    val staker = ft4.accounts.Account(account_id);
    val ss = staker_state @* { .account == staker } ( .balance, .last_update, .pending_token_time );
    var total_pending_token_time = 0;
    for (s in ss) {
        total_pending_token_time += s.pending_token_time + s.balance * (_staking_last_known_time() - s.last_update);
    }
    return integer(total_pending_token_time * rate);
}

// TODO staking_rewards_for

// TODO staking_get_rewards_paid

// TODO staking_get_native_balance

query staking_get_balance(
    account_id: byte_array
) = staker_state @ { 
    .account.id == account_id 
} ( 
    @sum .balance 
) limit 1;


query staking_total_stake() = staker_state @* { } ( @sum .balance )[0];

query staking_total_accounts() = staker_state @* { } ( @sum 1 )[0];

query staking_get_cannot_change_before(): timestamp = _staking_last_known_time() + chain_context
    .args
    .staking_rate_change_delay_ms;
