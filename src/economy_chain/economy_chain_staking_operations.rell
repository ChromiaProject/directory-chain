

operation staking_set_rate_at(reward_rate: decimal, provider_rate: decimal, time: timestamp) {
    _staking_set_rate_at_impl(reward_rate, provider_rate, time);
}

operation staking_set_rate(reward_rate: decimal) {
    _staking_set_rate_impl(reward_rate);
}


// Deposit operations

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "staking_deposit_native",
    flags = ["T"],
    message = staking_deposit_auth_message(*)
);

function staking_deposit_auth_message(gtv): text {
    val args = struct<staking_deposit_native>.from_gtv(gtv);

    return "Please sign the message\nto transfer %s %s from account {account_id} \nto deposit account.".format(
        ft4.assets.format_amount_with_decimals(args.amount, chain_context.args.asset_decimals),
        chain_context.args.asset_symbol);
}

/**
/* Draws FT4 CHR tokens from the user's account on the Economy Chain into the staking deposit account
/* controlled by the staking logic. It can only be withdrawn later after a delay.
/* @param amount CHR in minor tokens
/* @param pubkey Optional public key of the active provider to delegate immediately on deposit
**/
operation staking_deposit_native(amount: integer, delegateTo: pubkey? = null) {
    _staking_deposit_native_impl(amount, delegateTo);
}


// Rewards

/**
/* Manually claim user rewards
**/
operation staking_claim_rewards() {
    _staking_claim_rewards_impl();
}


// Withdrawals

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "staking_request_withdrawal",
    flags = [],
    message = staking_request_withdrawal_auth_message(*)
);

function staking_request_withdrawal_auth_message(gtv): text {
    val args = struct<staking_request_withdrawal>.from_gtv(gtv);
    return "Please sign the message to request a withdrawal.";
}

/**
/* Requests the return of any of the user's FT4 CHR tokens from the staking account to their account.
/* This will happen automatically after the withdrawal delay time. No staking reward will be earned
/* waiting for a withdrawal.
*/
operation staking_request_withdrawal() {
    _staking_request_withdrawal_impl();
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "staking_cancel_withdrawal",
    flags = [],
    message = staking_cancel_withdrawal_auth_message(*)
);

function staking_cancel_withdrawal_auth_message(gtv): text {
    val args = struct<staking_cancel_withdrawal>.from_gtv(gtv);
    return "Please sign the message to cancel withdrawal.";
}

/**
/* Cancel any unaction withdrawal request. This cancellation will allow rewards to continue accumulating.
*/
operation staking_cancel_withdrawal() {
    _staking_cancel_withdrawal_impl();
}


// Staker delegation

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "staking_delegate",
    flags = [],
    message = staking_delegate_auth_message(*)
);

function staking_delegate_auth_message(gtv): text {
    val args = struct<staking_delegate>.from_gtv(gtv);
    // TODO Indicate which provider?
    return "Please sign the message to set the provider.";
}

/**
/* Delegate the user's stake to a provider identified by public key.
/*
/* @param pubkey Public key of a provider registered and active in the Directory Chain.
*/
operation staking_delegate(pubkey) {
    _staking_delegate_impl(pubkey);
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "staking_undelegate",
    flags = [],
    message = staking_undelegate_auth_message(*)
);

function staking_undelegate_auth_message(gtv): text {
    val args = struct<staking_undelegate>.from_gtv(gtv);
    return "Please sign the message to undelegate.";
}

/**
/* Remove delegation from the user's stake. This will not withdraw their stake.
/* Undelegated stakes do not earn rewards.
*/
operation staking_undelegate() {
    _staking_undelegate_impl();
}


// EVM Bridge

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "staking_import_evm_balance",
    flags = [],
    message = staking_import_evm_balance_auth_message(*)
);

function staking_import_evm_balance_auth_message(gtv): text {
    val args = struct<staking_import_evm_balance>.from_gtv(gtv);
    return "Please sign the message to bridge from EVM.";
}

/**
/* This operation needs to be called when an address was created by means others than ras_staking
/* registration strategy.
/*
/* @param address EVM address to import
/* @param network_id Important only for smart contract stakers, for EOA stakers it is ignored. Should become irrelevant once we have hooks in eif hbridge.
*/
operation staking_import_evm_balance(address: byte_array, network_id: integer) {
    _staking_import_evm_balance_impl(address, network_id);
}
