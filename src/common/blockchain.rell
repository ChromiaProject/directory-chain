function allow_blockchain_dependencies() = chain_context.args.allow_blockchain_dependencies;

function add_blockchain(raw_configuration: byte_array, signers: byte_array, name: text, container, system: boolean = false): byte_array {
    val blockchain_rid = map<text, gtv>.from_gtv(gtv.from_bytes(raw_configuration)).hash();
    val blockchain = create blockchain(blockchain_rid, name, system);
    create blockchain_configuration(blockchain, 0, raw_configuration);
    create blockchain_configuration_signers(blockchain, 0, signers);
    create blockchain_added(blockchain, op_context.transaction);
    create container_blockchain(container, blockchain);
    add_dependencies(raw_configuration, blockchain_rid, 0);
    return blockchain_rid;
}

function add_dependencies(data: byte_array, me_brid: byte_array, height: integer) {
    val config_map = map<text, gtv>.from_gtv(gtv.from_bytes(data));
    if (config_map.contains("dependencies")) {
        require(allow_blockchain_dependencies(), "Blockchain dependencies are not allowed");
        val deps = list<(text, byte_array)>.from_gtv(config_map["dependencies"]);   // Returns e.g.  [brid0, brid22, ..]
        val me = blockchain @ {me_brid};
        val my_container = container_blockchain @ { me }.container;
        for ((_, dep) in deps) {
            val dependent_on = blockchain @? { dep };
            if (exists(dependent_on)) {
                require(me_brid != dep);
                require(container_blockchain @ { dependent_on }.container == my_container, 
                    "Blockchain dependencies are only allowed within the same container");
                create blockchain_dependency(
                    me,
                    dependent_on,
                    height = height);
            }
        }
    }
}

function require_no_dependencies_on_me(blockchain) {
    require (empty(blockchain_dependency @* { .dependent_on == blockchain}));
}

function get_last_height(blockchain): integer {
    if (blockchain.rid == chain_context.blockchain_rid) {
        return op_context.block_height;
    } else {
        return (anchored_block @? { blockchain } (@sort_desc .height) limit 1) ?: -1;
    }
}

function get_blockchain_signer_nodes(blockchain: blockchain): list<node> {
    return (cluster_node, container_blockchain) @* {
        container_blockchain.blockchain == blockchain,
        cluster_node.cluster == container_blockchain.container.cluster
    } ( .node );
}

// Cannot use function get_last_height, since it uses an op_context.
// Deprecated: relies on legacy anchoring which will be removed
function deprecated_get_blockchain_last_height(blockchain_rid: byte_array): integer {
    if (blockchain_rid == chain_context.blockchain_rid) {
        return (block @? {} (@sort_desc .block_height) limit 1) ?: -1;
    } else {
        return (anchored_block @? { blockchain @ { blockchain_rid } } (@sort_desc .height) limit 1) ?: -1;
    }
}

function get_signers_for_configuration(blockchain, height: integer): gtv {
    val raw_signers = blockchain_configuration_signers @ { blockchain, .height <= height }
        (@omit @sort_desc .height, .signers) limit 1;
    return gtv.from_bytes(raw_signers);
}

function isAlive(blockchain): boolean {
    return blockchain.state == blockchain_state.RUNNING or blockchain.state == blockchain_state.PAUSED;
}

@extendable function before_delete_blockchain(blockchain) {}