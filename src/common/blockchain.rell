function allow_blockchain_dependencies() = chain_context.args.allow_blockchain_dependencies;

function add_blockchain(
    base_configuration: byte_array,
    signers: list<pubkey>,
    name: text, 
    container,
    system: boolean = false,
    state: blockchain_state = blockchain_state.RUNNING
): blockchain {
    val blockchain_rid = calculate_configuration_hash(base_configuration, signers);
    val blockchain = create blockchain(blockchain_rid, name, system, state);
    create blockchain_configuration(blockchain, 0, base_configuration);
    create blockchain_configuration_signers(blockchain, 0, signers.to_gtv().to_bytes());
    create container_blockchain(container, blockchain);
    add_dependencies(base_configuration, blockchain_rid, 0);
    return blockchain;
}

function add_dependencies(raw_config: byte_array, brid: byte_array, height: integer) {
    val config_map = map<text, gtv>.from_gtv(gtv.from_bytes(raw_config));
    if (config_map.contains("dependencies")) {
        require(allow_blockchain_dependencies(), "Blockchain dependencies are not allowed");
        val dependencies = list<(text, byte_array)>.from_gtv(config_map["dependencies"]);   // Returns e.g.  [brid0, brid22, ..]
        val blockchain = blockchain @ { brid };
        val container = container_blockchain @ { blockchain }.container;
        for ((_, dependency_brid) in dependencies) {
            val dependency_blockchain = blockchain @? { dependency_brid };
            if (exists(dependency_blockchain)) {
                require(brid != dependency_brid);
                require(container_blockchain @ { dependency_blockchain }.container == container,
                    "Blockchain dependencies are only allowed within the same container");
                create blockchain_dependency(
                    me = blockchain,
                    dependent_on = dependency_blockchain,
                    height = height);
            }
        }
    }
}

function get_blockchain_signer_nodes(blockchain: blockchain): list<node> {
    return (cluster_node, container_blockchain) @* {
        container_blockchain.blockchain == blockchain,
        cluster_node.cluster == container_blockchain.container.cluster
    } ( .node );
}

function get_signers_for_configuration(blockchain, height: integer): gtv {
    val raw_signers = blockchain_configuration_signers @ { blockchain, .height <= height }
        (@omit @sort_desc .height, .signers) limit 1;
    return gtv.from_bytes(raw_signers);
}

function isAlive(blockchain): boolean {
    return blockchain.state == blockchain_state.RUNNING or blockchain.state == blockchain_state.PAUSED;
}

function calculate_configuration_hash(base_config: byte_array, signers: list<pubkey>): byte_array {
    val full_config = map<text, gtv>.from_gtv(gtv.from_bytes(base_config));
    full_config["signers"] = signers.to_gtv();
    return full_config.to_gtv().hash();    
}

function get_blockchain_configuration(blockchain_rid: byte_array, height: integer):
    (base_config: byte_array, signers: list<pubkey>, config_hash: byte_array)?
{
    val bc = require_blockchain(blockchain_rid, include_removed = true);
    // Find configuration height -- the latest height up to given height.
    // If conf_h exist, so does signer_h, thus no need to check both.
    val base_config = blockchain_configuration @? { bc, .height <= height } (@omit @sort_desc .height, .data) limit 1;
    if (base_config != null) {
        // Checking that signers.size() is non-zero is done when population blockchain_configuration_signers.
        val signers = require(blockchain_configuration_signers @? { bc, .height <= height }
            (@omit @sort_desc .height, list<pubkey>.from_gtv(gtv.from_bytes(.signers))) limit 1,
            "No signers configuration for blockchain %s for height %d".format(blockchain_rid, height)
        );
        return (
            base_config = base_config,
            signers = signers,
            config_hash = calculate_configuration_hash(base_config, signers)
        );
    } else {
        return null;
    }
}

@extendable function before_delete_blockchain(blockchain) {}
