query get_blockchain(rid: byte_array) = blockchain @ { rid };

query get_blockchain_signers(blockchain_rid: byte_array): list<(byte_array, text, integer, boolean, integer)> {
    val blockchain = require_blockchain(blockchain_rid, true);
    return get_blockchain_signer_nodes(blockchain) @* {} (
            @sort _ = .pubkey,
            _ = .host,
            _ = .port,
            _ = .active,
            _ = .last_updated
        );
}

query get_blockchain_replicas(blockchain_rid: byte_array) {
    return blockchain_replica_node @* { .blockchain.rid == blockchain_rid } (
        @sort .node.pubkey,
        .node.host,
        .node.port,
        .node.active,
        .node.last_updated
    );
}

// Cannot use function get_last_height, since it uses an op_context.
// Deprecated: relies on legacy anchoring which will be removed
query get_blockchain_last_height(blockchain_rid: byte_array): integer {
    return deprecated_get_blockchain_last_height(blockchain_rid);
}

query get_blockchains(include_inactive: boolean): list<struct<blockchain>> {
    if (include_inactive) {
        return blockchain @* {} ($.to_struct());
    }
    return blockchain @* { .state == blockchain_state.RUNNING } ($.to_struct());
}

query get_added_blockchain_rid(tx_rid: byte_array) {
    return blockchain_added @ { transaction @ { tx_rid } }.blockchain.rid;
}

// Will return RUNNING and PAUSED if include_inactive == true
function get_blockchains_with_container(include_inactive: boolean) {
    if (include_inactive) {
        return (b: blockchain, c: container_blockchain) @* { c.blockchain == b } (blockchain=b, c.container) ;
    } else {
        return (b: blockchain, c: container_blockchain) @* { c.blockchain == b and b.state == blockchain_state.RUNNING } (blockchain = b, c.container);
    }
}

// Will return RUNNING, PAUSED and REMOVED if include_inactive == true
query get_blockchain_info_list(include_inactive: boolean): list<(rid: byte_array, name: text, state: blockchain_state, container: name?, cluster: name?)> {
    var bc_infos = list<(blockchain: blockchain, container: container?)>();
    if (include_inactive) {
        val connected_blockchains = container_blockchain @* {} (.blockchain, .container);
        val removed_blockchains = blockchain @* {
            blockchain not in connected_blockchains @* {}.blockchain
        } (blockchain = blockchain, container = null);
        bc_infos.add_all(connected_blockchains);
        bc_infos.add_all(removed_blockchains);
    } else {
        bc_infos.add_all((b: blockchain, c: container_blockchain) @* { c.blockchain == b and b.state == blockchain_state.RUNNING } (blockchain = b, c.container));
    }
    
    val result = list<(rid: byte_array, name: text, state: blockchain_state, container: name?, cluster: name?)>();
    for (bc in bc_infos) {
        result.add((
            rid = bc.blockchain.rid,
            name = bc.blockchain.name,
            state = bc.blockchain.state,
            container = bc.container?.name,
            cluster = bc.container?.cluster?.name
        ));
    }
    return result;
}

query get_blockchain_cluster(blockchain_rid: byte_array) = cm_get_blockchain_cluster(blockchain_rid);

query get_blockchain_api_urls(blockchain_rid: byte_array) = cm_get_blockchain_api_urls(blockchain_rid);

