
function set_cluster_anchoring_config(config: byte_array) {
    map<text, gtv>.from_gtv(gtv.from_bytes(config)); // Validate that config is a map
    cluster_anchoring_config.raw_config = config;
}

@extend(after_cluster_operational) function activate_cluster_anchoring_chain(cluster) {
    val config_map = map<text,gtv>.from_gtv(gtv.from_bytes(cluster_anchoring_config.raw_config));

    // feature toggle
    if (not(exists(cluster_anchoring_chain @? { cluster } (.blockchain))) and config_map.size() > 0) {
        require(empty(cluster_anchoring_chain @? { cluster }), "Anchoring chain already exists for cluster " + cluster.name);

        config_map["cluster"] = cluster.name.to_gtv();
        val unique_config = config_map.to_gtv_pretty();
        val blockchain_rid = unique_config.hash();
        val blockchain = create blockchain(blockchain_rid, blockchains.cluster_anchoring_prefix + cluster.name, system = true, .state = blockchain_state.RUNNING);
        create blockchain_configuration(blockchain, 0, unique_config.to_bytes());

        val system_container = container @ { .name == system_container_name(cluster.name), cluster };

        create container_blockchain(system_container, blockchain);
        create cluster_anchoring_chain(blockchain, cluster);

        val cluster_signers = cluster_node @* { cluster } (@sort .node.pubkey).to_gtv().to_bytes();
        create blockchain_configuration_signers(blockchain, 0, cluster_signers);

        if (cluster.name != clusters.system) {
            // Add replication of this chain to all system nodes
            val system_cluster_nodes = cluster_node @* { .cluster.name == clusters.system  } ( .node );
            for (node in system_cluster_nodes) {
                create blockchain_replica_node(blockchain, node);
            }
        }
    }
}

@extend(before_system_container_removal) function remove_cluster_anchoring_chain(cluster) {
    val anchor = cluster_anchoring_chain @? { cluster } (.blockchain);
    if (exists(anchor)) {
        anchor.state = blockchain_state.REMOVED;
        delete container_blockchain @* { anchor };
        delete cluster_anchoring_chain @ { anchor };
        delete blockchain_replica_node @* { anchor };
    }
}

@extend(after_node_added_to_cluster) function replicate_cluster_anchor_chain_on_system_node(cluster, node) {
    if (cluster.name == clusters.system) {
        val cluster_anchoring_chains = cluster_anchoring_chain @* { .cluster.name != clusters.system } ( .blockchain );
        for (blockchain in cluster_anchoring_chains) {
            if (not(exists(blockchain_replica_node @? { blockchain, node }))) {
                create blockchain_replica_node(blockchain, node);
            }
        }
    }
}
