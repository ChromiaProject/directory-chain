operation register_node(my_pubkey: pubkey, node_pubkey: pubkey, host: text, port: integer, api_url: text, clusters:list<text> = list<text>()) {
    register_node_with_units_impl(my_pubkey, node_pubkey, host, port, api_url, clusters, 1);
}

operation register_node_with_units(my_pubkey: pubkey, node_pubkey: pubkey, host: text, port: integer, api_url: text, clusters:list<text> = list<text>(), cluster_units: integer) {
    register_node_with_units_impl(my_pubkey, node_pubkey, host, port, api_url, clusters, cluster_units);
}

function register_node_with_units_impl(my_pubkey: pubkey, node_pubkey: pubkey, host: text, port: integer, api_url: text, clusters:list<text> = list<text>(), cluster_units: integer) {
    log("------------- Register-Node: %s --------------".format(node_pubkey));
    val provider = require_provider(my_pubkey);
    require_provider_auth_with_rate_limit(provider);
    require_pubkey(node_pubkey);
    add_node_internal(provider, node_pubkey, host, port, api_url, clusters, cluster_units);
    log("Added node information for node: " + node_pubkey);
    log("-----------------------------------");
}

operation replace_node(my_pubkey: pubkey, old_node_key: pubkey, new_node_key: pubkey, new_host: text?, new_port: integer?, new_api_url: text?) {
    replace_node_with_units_impl(my_pubkey, old_node_key, new_node_key, new_host, new_port, new_api_url, 1);
}

operation replace_node_with_units(my_pubkey: pubkey, old_node_key: pubkey, new_node_key: pubkey, new_host: text?, new_port: integer?, new_api_url: text?, cluster_units: integer) {
    replace_node_with_units_impl(my_pubkey, old_node_key, new_node_key, new_host, new_port, new_api_url, cluster_units);
}

function replace_node_with_units_impl(my_pubkey: pubkey, old_node_key: pubkey, new_node_key: pubkey, new_host: text?, new_port: integer?, new_api_url: text?, new_cluster_units: integer) {
    log("------------- Replace-Node: %s --------------".format(old_node_key));
    val me = require_is_provider_with_rate_limit(my_pubkey);
    require_is_signer(old_node_key);
    require_is_signer(new_node_key);
    val old_node = node @ { old_node_key };
    require(old_node.provider == me, "Node must be owned by provider");
    val old_cluster_units_used = get_used_cluster_units_for_node(old_node);
    require(new_cluster_units >= old_cluster_units_used, "Node must have at least %d cluster_units".format(old_cluster_units_used));

    val host = new_host ?: old_node.host;
    val port = new_port ?: old_node.port;
    val api_url = new_api_url ?: old_node.api_url;

    val cluster_names = cluster_node @* { old_node }.cluster.name;
    delete cluster_node @* { old_node };
    val clusters_replicated_by_node = cluster_replica_node @* { old_node } (.cluster);
    delete cluster_replica_node @* { old_node };
    val blockchains_replicated_by_node = blockchain_replica_node @* { old_node } (.blockchain);
    delete blockchain_replica_node @* { old_node };

    delete old_node;
    add_node_internal(me, new_node_key, host, port, api_url, cluster_names, new_cluster_units);

    val new_node = node @ { new_node_key };
    for (cl in clusters_replicated_by_node) {
        _add_replica_node_to_cluster_internal(cl, new_node);
    }

    for (blockchain in blockchains_replicated_by_node) {
        if (not(exists(blockchain_replica_node @? { blockchain, new_node }))) {
            create blockchain_replica_node(blockchain, new_node);
        }
    }

    node_list.last_update = op_context.last_block_time;
    log("---------------------------------------");
}

operation enable_node(my_pubkey: pubkey, node_pubkey: pubkey) {
    log("------------- Enable-Node: %s --------------".format(node_pubkey));
    val provider = require_is_provider_with_rate_limit(my_pubkey);
    val node = require_node(node_pubkey);
    require(node.provider == provider, "Node must be owned by provider: " + node_pubkey);
    require(not(node.active), "Node is already active: " + node_pubkey);
    node.active = true;
    after_node_added(node);
    log("-----------------------------------");
}


operation disable_node(my_pubkey: pubkey, node_pubkey: pubkey) {
    val provider = require_provider(my_pubkey);
    require_provider_auth_with_rate_limit(provider);
    val node_to_disable = require_node(node_pubkey);

    if (provider != node_to_disable.provider) {
        require(roles.has_system_access(provider), "Non system provider is only allowed to disable own nodes");
        require(
            node_to_disable.provider.tier == provider_tier.NODE_PROVIDER and not(node_to_disable.provider.system),
            "System provider is only allowed to disable nodes of non system provider");
    }

    node_to_disable.active = false;

    // cluster nodes
    if (pcu_enabled()) {
        val clusters = cluster_node @* { node_to_disable } .cluster;
        delete cluster_node @* { node_to_disable };
        for (cl in clusters) {
            pcu_update_configuration_signers(cl, node_to_disable);
        }
    } else {
        val clusters = cluster_node @* { node_to_disable } .cluster;
        delete cluster_node @* { node_to_disable };
        for (cl in clusters) {
            // Disabling the last node of a cluster is not allowed:
            require(not(empty(cluster_node @* { cl })), "Cannot disable the last node of a cluster " + cl.name);
            update_configuration_signers(cl);
        }
    }

    // cluster replica nodes
    delete cluster_replica_node @* { .node.pubkey == node_pubkey };
    // blockchain replica nodes
    delete blockchain_replica_node @* { .node.pubkey == node_pubkey };

    // updating node list timestamp
    node_list.last_update = op_context.last_block_time;
}

operation remove_node(my_pubkey: pubkey, node_pubkey: pubkey) {
    log("------------- Remove-Node: %s --------------".format(node_pubkey));
    val provider = require_provider(my_pubkey);
    require_provider_auth_with_rate_limit(provider);
    val node_to_remove = require_node(node_pubkey);
    require(provider == node_to_remove.provider, "It is only allowed to remove own nodes: " + node_pubkey);
    require(not(node_to_remove.active), "Can't remove active nodes: " + node_pubkey);
    delete node_to_remove;
    log("---------------------------------------");
}

operation update_node(my_pubkey: pubkey, node_pubkey: pubkey, host: text? = null, port: integer? = null, api_url: text? = null) {
    update_node_with_units_impl(my_pubkey, node_pubkey, host, port, api_url, null);
}

operation update_node_with_units(my_pubkey: pubkey, node_pubkey: pubkey, host: text? = null, port: integer? = null, api_url: text? = null, cluster_units: integer? = null) {
    update_node_with_units_impl(my_pubkey, node_pubkey, host, port, api_url, cluster_units);
}

function update_node_with_units_impl(my_pubkey: pubkey, node_pubkey: pubkey, host: text?, port: integer?, api_url: text?, cluster_units: integer?) {
    val node = require_node_provider(node_pubkey, my_pubkey);
    if (host != null) node.host = host;
    if (port != null) node.port = port;
    if (api_url != null) node.api_url = api_url;
    if (host != null or port != null or api_url != null) node.last_updated = op_context.last_block_time;
    if (host != null or port != null) node_list.last_update = op_context.last_block_time;
    if (cluster_units != null) {
        require(cluster_units > 0, "Node must have at least 1 cluster_unit");
        val needed_cluster_units = get_used_cluster_units_for_node(node);
        require(cluster_units >= needed_cluster_units,
            "Can not update cluster units to %d since the node needs at least %d to support current clusters.".format(cluster_units, needed_cluster_units));
        node.cluster_units = cluster_units;
    }
}

operation update_node_capability(my_pubkey: pubkey, node_pubkey: pubkey, type: node_capability_type, add: boolean) {
    val node = require_node_provider(node_pubkey, my_pubkey);
    if (add) {
        require(node_capabilities @? { node, type } == null, "Node already has this cabability");
        create node_capabilities(node, type);
    } else {
        require(node_capabilities @? { node, type } != null, "Node does not have this capability");
        delete node_capabilities @ { node, type };
    }
}