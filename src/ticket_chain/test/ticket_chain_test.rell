@test module;

import ^^.*;
import ^.helpers.*;

namespace ft4 {
    import acc: lib.ft4.accounts;
    import acc_ext: lib.ft4.accounts.external;
    import lib.ft4.assets;
    import lib.ft4.auth;
    import lib.ft4.version;
    import test_utils: lib.ft4.test.utils;
}
import lib.auth;

struct module_args {
    auth_privkey: byte_array;
    admin_privkey: byte_array;
}

function test_init() {
    rell.test.tx().op(
        claim_test_chr()
    ).run_must_fail("Ticket chain is not initialized");

    rell.test.tx().op(
        init()
    ).run();

    val asset = get_chr_asset();
    assert_equals(asset.symbol, "tCHR");

    get_pool_account();

    rell.test.tx().op(
        init()
    ).nop().run_must_fail("Ticket chain is already initialized");
}

function test_create_accounts() {
    rell.test.tx().op(init()).run();

    val alice = require(do_create_account(rell.test.keypairs.alice));
    assert_gt(get_account_balance(alice), 0);

    val bob = require(do_create_account(rell.test.keypairs.bob));
    assert_gt(get_account_balance(bob), 0);

    assert_not_equals(alice.id, bob.id);
}

function test_admin_register_account() {
    rell.test.tx().op(init()).run();

    rell.test.tx().op(
        register_account(rell.test.pubkeys.alice)
    ).sign(chain_context.args.admin_privkey).run();

    val account_ids = ft4.acc.external.get_accounts_by_participant_id(rell.test.pubkeys.alice);
    assert_equals(account_ids.size(), 1);

    assert_not_null(user @? { .account.id == account_ids[0] });
}

function test_create_account_requires_init() {
    do_create_account(rell.test.keypairs.alice, "Ticket chain is not initialized");
}

function test_create_account_duplicate() {
    rell.test.tx().op(init()).run();
    do_create_account(rell.test.keypairs.alice);
    do_create_account(rell.test.keypairs.alice, "duplicate key value violates unique constraint");
}

function test_claim_test_chr_success() {
    rell.test.tx().op(init()).run();
    val alice = require(do_create_account(rell.test.keypairs.alice));
    val initial_balance = get_account_balance(alice);
    rell.test.set_next_block_time_delta(millis_per_week + 1);
    rell.test.block().run();
    rell.test.tx().op(
        ft4.test_utils.evm_auth_operation_for(rell.test.privkeys.alice, "claim_test_chr", [])
    ).op(
        claim_test_chr()
    ).run();
    val new_balance = get_account_balance(alice);
    assert_gt(new_balance, initial_balance);
    assert_equals(get_balance(alice.id), new_balance);
}

function test_claim_test_chr_failure() {
    rell.test.tx().op(init()).run();
    val alice = require(do_create_account(rell.test.keypairs.alice));
    rell.test.set_next_block_time_delta(millis_per_week - rell.test.DEFAULT_BLOCK_INTERVAL - 1);
    rell.test.block().run();
    rell.test.tx().op(
        ft4.test_utils.evm_auth_operation_for(rell.test.privkeys.alice, "claim_test_chr", [])
    ).op(
        claim_test_chr()
    ).run_must_fail("You have already claimed");
}

function test_create_container_success() {
    rell.test.tx().op(init()).run();
    val alice = require(do_create_account(rell.test.keypairs.alice));
    val container_name = do_create_container(alice, rell.test.keypairs.alice, success = true, block_height = 2, ticket_id = 16, container_units = 2);

    val expected_lease = lease_data(
        container_name = container_name,
        container_units = 2,
        extra_storage_gib = 0,
        expire_time_millis = rell.test.DEFAULT_FIRST_BLOCK_TIME + rell.test.DEFAULT_BLOCK_INTERVAL*2 + millis_per_week,
        expired = false
    );

    val leases2 = get_leases_by_account(alice.id);
    assert_equals(leases2.size(), 1);
    assert_equals(leases2[0], expected_lease);
}

function test_create_container_failure() {
    rell.test.tx().op(init()).run();
    val alice = require(do_create_account(rell.test.keypairs.alice));
    do_create_container(alice, rell.test.keypairs.alice, success = false, block_height = 2, ticket_id = 16);
}

function test_create_container_no_auth() {
    rell.test.tx().op(init()).run();
    rell.test.tx().op(
        create_container(rell.test.pubkeys.alice, 2, "", integer.MAX_VALUE, 0)
    ).run_must_fail("make sure that you included auth operation");
}

function test_create_container_insufficient_funds() {
    rell.test.tx().op(init()).run();
    val alice = require(do_create_account(rell.test.keypairs.alice));
    rell.test.tx().op(
        ft4.test_utils.evm_auth_operation_for(rell.test.privkeys.alice, "create_container",
            [rell.test.pubkeys.alice.to_gtv(), (100).to_gtv(), "".to_gtv(), (100).to_gtv(), (0).to_gtv()])
    ).op(
        create_container(rell.test.pubkeys.alice, 100, "", 100, 0)
    ).run_must_fail("Balance is too low");
}

function test_expire_lease() {
    rell.test.tx().op(init()).run();
    val alice = require(do_create_account(rell.test.keypairs.alice));
    val container_name = do_create_container(alice, rell.test.keypairs.alice, success = true, block_height = 2, ticket_id = 16);

    assert_false(lease @ { container_name } (.expired));
    rell.test.set_next_block_time_delta(millis_per_week + 1);
    rell.test.block().run();
    rell.test.block().run();
    assert_true(lease @ { container_name } (.expired));
    assert_events(("icmf_message", (
        topic = stop_container_topic,
        body = stop_container_message(container_name).to_gtv(),
        block_height = 5).to_gtv_pretty()
    ));
}

function test_not_expire_lease() {
    rell.test.tx().op(init()).run();
    val alice = require(do_create_account(rell.test.keypairs.alice));
    val container_name = do_create_container(alice, rell.test.keypairs.alice, success = true, block_height = 2, ticket_id = 16);

    assert_false(lease @ { container_name } (.expired));
    rell.test.set_next_block_time_delta(millis_per_week - 60000);
    rell.test.block().run();
    rell.test.block().run();
    assert_false(lease @ { container_name } (.expired));
    assert_events(); // assert no ICMF messages sent
}

function test_prolong_non_expired_container() {
    rell.test.tx().op(init()).run();
    val alice = require(do_create_account(rell.test.keypairs.alice));
    val container_name = do_create_container(alice, rell.test.keypairs.alice, success = true, block_height = 2, ticket_id = 16);

    val alice_balance = get_account_balance(alice);
    val pool_balance = get_pool_balance();

    assert_equals(lease @ { container_name } (.duration_millis), 1 * millis_per_week);
    rell.test.tx().op(
        ft4.test_utils.evm_auth_operation_for(rell.test.privkeys.alice, "prolong_container",
            [container_name.to_gtv(), (1).to_gtv()])
    ).op(
        prolong_container(container_name, 1)
    ).run();
    assert_lt(get_account_balance(alice), alice_balance);
    assert_gt(get_pool_balance(), pool_balance);
    assert_equals(lease @ { container_name } (.duration_millis), 2 * millis_per_week);
    assert_false(lease @ { container_name } (.expired));
    assert_events(); // assert no ICMF messages sent
}

function test_prolong_expired_container() {
    rell.test.tx().op(init()).run();
    val alice = require(do_create_account(rell.test.keypairs.alice));
    val container_name = do_create_container(alice, rell.test.keypairs.alice, success = true, block_height = 2, ticket_id = 16);

    val alice_balance = get_account_balance(alice);
    val pool_balance = get_pool_balance();

    rell.test.set_next_block_time_delta(millis_per_week + 1);
    rell.test.block().run();
    rell.test.block().run();
    assert_true(lease @ { container_name } (.expired));

    rell.test.tx().op(
        ft4.test_utils.evm_auth_operation_for(rell.test.privkeys.alice, "prolong_container",
            [container_name.to_gtv(), (1).to_gtv()])
    ).op(
        prolong_container(container_name, 1)
    ).run();
    assert_lt(get_account_balance(alice), alice_balance);
    assert_gt(get_pool_balance(), pool_balance);
    assert_equals(lease @ { container_name } (.duration_millis), 2 * millis_per_week);
    assert_false(lease @ { container_name } (.expired));
    assert_events(("icmf_message", (
        topic = restart_container_topic,
        body = restart_container_message(container_name).to_gtv(),
        block_height = 6).to_gtv_pretty()
    ));
}

function test_prolong_container_insufficient_funds() {
    rell.test.tx().op(init()).run();
    val alice = require(do_create_account(rell.test.keypairs.alice));
    val container_name = do_create_container(alice, rell.test.keypairs.alice, success = true, block_height = 2, ticket_id = 16);

    rell.test.tx().op(
        ft4.test_utils.evm_auth_operation_for(rell.test.privkeys.alice, "prolong_container",
            [container_name.to_gtv(), (10000).to_gtv()])
    ).op(
        prolong_container(container_name, 10000)
    ).run_must_fail("Balance is too low");
}

function do_create_account(keypair: rell.test.keypair, failure: text? = null): ft4.acc.account? {
    val eth_address = ft4.test_utils.evm_address_from_privkey(keypair.priv);
    log("eth_address=%s".format(eth_address));
    val auth_descriptor = ft4.acc.single_sig_auth_descriptor(eth_address, set(["T"]));
    val signature = ft4.test_utils.evm_sign(auth.get_message_to_sign(), keypair.priv);

    val tx = rell.test.tx().op(
        auth.register_account(auth_descriptor, signature)
    ).nop().sign(chain_context.args.auth_privkey);

    if (failure != null) {
        tx.run_must_fail(failure);
        return null;
    } else {
        tx.run();
        return ft4.acc.account_by_id(auth_descriptor.hash());
    }
}

function do_create_container(ft4.acc.account, keypair: rell.test.keypair, success: boolean, block_height: integer, ticket_id: integer, container_units: integer = 2): text {
    val container_name = "container name";

    val cost = calculate_container_cost(1, container_units, 0);

    val initial_balance = get_account_balance(account);
    val initial_pool_balance = get_pool_balance();

    rell.test.tx().op(
        ft4.test_utils.evm_auth_operation_for(keypair.priv, "create_container", [keypair.pub.to_gtv(), container_units.to_gtv(), "".to_gtv(), (1).to_gtv(), (0).to_gtv()])
    ).op(
        create_container(keypair.pub, container_units, "", 1, 0)
    ).run();
    val tx_rid = transaction @ {} (@sort_desc @omit .rowid, .tx_rid) limit 1;

    assert_events(("icmf_message", (
        topic = create_container_topic,
        body = create_container_message(ticket_id = ticket_id, keypair.pub, container_units = container_units, cluster_class = "", extra_storage = 0).to_gtv(),
        block_height = block_height).to_gtv_pretty()
    ));

    val pending_ticket = create_container_ticket_data(ticket_id, ticket_type.CREATE_CONTAINER, ticket_state.PENDING, error_message = "", container_name = "");
    assert_equals(require(get_create_container_ticket_by_id(ticket_id)), pending_ticket);
    assert_equals(require(get_create_container_ticket_by_transaction(tx_rid)), pending_ticket);

    assert_equals(get_account_balance(account), initial_balance - cost);
    assert_equals(get_pool_balance(), initial_pool_balance + cost);

    rell.test.tx().op(
        icmf_message_op(x"", ticket_result_topic, ticket_result_message(ticket_id = ticket_id, error_message = if (success) null else "error", container_name).to_gtv())
    ).run();
    val done_ticket = create_container_ticket_data(
        ticket_id = ticket_id,
        type = ticket_type.CREATE_CONTAINER,
        state = if (success) ticket_state.SUCCESS else ticket_state.FAILURE,
        error_message = if (success) "" else "error",
        container_name = if (success) container_name else ""
    );
    assert_equals(require(get_create_container_ticket_by_id(ticket_id)), done_ticket);
    assert_equals(require(get_create_container_ticket_by_transaction(tx_rid)), done_ticket);

    if (success) {
        assert_equals(get_account_balance(account), initial_balance - cost);
        assert_equals(get_pool_balance(), initial_pool_balance + cost);
    } else {
        assert_equals(get_account_balance(account), initial_balance);
        assert_equals(get_pool_balance(), initial_pool_balance);
    }

    return container_name;
}

function test_asset_units() {
    assert_equals(units_per_asset, 1000000);
}
