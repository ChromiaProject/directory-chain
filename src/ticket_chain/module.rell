module;

import messaging.ticketing.*;
import messaging.icmf.*;

import lib.auth;

namespace ft4 {
    import acc: lib.ft4.accounts;
    import acc_ext: lib.ft4.accounts.external;
    import lib.ft4.assets;
    import lib.ft4.auth;
    import lib.ft4.version;
}

// TODO: Revise when we have real pricing
val SCU_COST = 1;
val EXTRA_STORAGE_COST = 1;

struct module_args {
    asset_name: text;
    asset_symbol: text;
    asset_icon: text;
    asset_decimals: integer;
    amount_to_mint: big_integer;
    pool_account_pubkey: pubkey;
    admin_pubkey: pubkey;
}

val millis_per_week = 7 * 24 * 60 * 60 * 1000;

enum ticket_state {
    PENDING, SUCCESS, FAILURE
}

enum ticket_type {
    CREATE_CONTAINER
}

object state {
    mutable initialized: boolean = false;
}

entity lease {
    key pubkey, container_name: text;
    container_units: integer;
    extra_storage_gib: integer;
    start_time: integer;
    mutable duration_millis: integer;
    mutable expired: boolean = false;
}

entity ticket {
    index transaction = op_context.transaction;
    index type: ticket_type;
    account: ft4.acc.account;
    pubkey;
    mutable state: ticket_state = ticket_state.PENDING;
    mutable error_message: text = "";
}

entity create_container_ticket {
    key ticket;
    container_units: integer;
    extra_storage_gib: integer;
    duration_millis: integer;
    cost: integer;
}

struct ticket_data {
    ticket_id: integer;
    type: ticket_type;
    state: ticket_state;
    error_message: text;
}

struct lease_data {
    container_name: text;
    container_units: integer;
    extra_storage_gib: integer;
    expire_time_millis: integer;
    expired: boolean;
}

operation init() {
    require(state.initialized == false, "Ticket chain is already initialized");
    state.initialized = true;

    register_assets();

    create_pool_account();

    log("Ticket chain was initialized");
}

operation __begin_block(height: integer) {
    if (state.initialized) {
        expire_leases(op_context.last_block_time);
    }
}

function expire_leases(current_time_millis: integer) {
    for (lease in lease @* { current_time_millis > .start_time + .duration_millis, .expired == false }) {
        lease.expired = true;
        log("Lease for container %s has expired, stopping it".format(lease.container_name));
        send_message(stop_container_topic, stop_container_message(container_name = lease.container_name).to_gtv()); // fire-and-forget
    }
}

@extend(auth.before_account_registration) function(ft4.acc.auth_descriptor, ft4.auth.signature) {
    before_account_registration(auth_descriptor);
}

function before_account_registration(ft4.acc.auth_descriptor) {
    require_initialized();
}

@extend(auth.after_account_registration) function(ft4.acc.account, ft4.acc.auth_descriptor, ft4.auth.signature) {
    after_account_registration(account, auth_descriptor);
}

function after_account_registration(ft4.acc.account, ft4.acc.auth_descriptor) {
    log("Account created: %s".format(account.id));

    ft4.assets.Unsafe.mint(account, get_asset(), chain_context.args.amount_to_mint);
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "add_test_chr",
    flags = ["T"],
    message = add_test_chr_auth_message(*)
);

function add_test_chr_auth_message(gtv) =
    "Please sign the message\nto receive %s %s on account {account_id}".format(
        chain_context.args.amount_to_mint,
        chain_context.args.asset_symbol);

operation add_test_chr() {
    require_initialized();

    val account = ft4.auth.authenticate();

    ft4.assets.Unsafe.mint(account, get_asset(), chain_context.args.amount_to_mint);
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "create_container",
    flags = ["T"],
    message = create_container_auth_message(*)
);

function create_container_auth_message(gtv): text {
    val args = struct<create_container>.from_gtv(gtv);
    val cluster_class_message = if (args.cluster_class.empty()) "" else " of class %s".format(args.cluster_class);
    return "Please sign the message\nto lease container %s\nwith %s SCUs and %s GiB extra storage\nfor %s weeks\non account {account_id}".format(
        cluster_class_message,
        args.container_units,
        args.extra_storage_gib,
        args.duration_weeks);
}

operation create_container(pubkey, container_units: integer, cluster_class: text, duration_weeks: integer, extra_storage_gib: integer) {
    require_initialized();
    require_pubkey(pubkey);
    require(container_units > 0, "container_units must be positive");
    require(duration_weeks > 0, "duration_weeks must be positive");
    require(extra_storage_gib > -1, "extra_storage_gib must not be negative");

    val account = ft4.auth.authenticate();

    val cost = calculate_container_cost(duration_weeks, container_units, extra_storage_gib);
    ft4.assets.Unsafe.transfer(account, get_pool_account(), get_asset(), cost);

    val ticket = create ticket(type = ticket_type.CREATE_CONTAINER, account, pubkey);
    create create_container_ticket(ticket,
        container_units = container_units,
        extra_storage_gib = extra_storage_gib,
        duration_millis = duration_weeks * millis_per_week,
        cost = cost
    );
    send_message(create_container_topic, create_container_message(
        ticket_id = ticket.rowid.to_integer(),
        pubkey = pubkey,
        container_units = container_units,
        cluster_class = cluster_class,
        extra_storage = 1024 * extra_storage_gib
    ).to_gtv());
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "prolong_container",
    flags = ["T"],
    message = prolong_container_auth_message(*)
);

function prolong_container_auth_message(gtv): text {
    val args = struct<prolong_container>.from_gtv(gtv);
    return "Please sign the message\nto prolong lease of container %s\nfor %s weeks\non account {account_id".format(
        args.container_name,
        args.duration_weeks);
}

operation prolong_container(pubkey, container_name: text, duration_weeks: integer) {
    require_initialized();
    require_pubkey(pubkey);
    require(duration_weeks > 0, "duration_weeks must be positive");

    val account = ft4.auth.authenticate();

    val lease = require(lease @? { pubkey, container_name }, "No current lease for container %s".format(container_name));

    val cost = calculate_container_cost(duration_weeks, lease.container_units, lease.extra_storage_gib);
    ft4.assets.Unsafe.transfer(account, get_pool_account(), get_asset(), cost);
    lease.duration_millis += duration_weeks * millis_per_week;

    if (lease.expired) {
        log("Lease for container %s was expired, restarting it".format(lease.container_name));
        send_message(restart_container_topic, restart_container_message(container_name = lease.container_name).to_gtv()); // fire-and-forget
        // TODO what if restart fails?
        lease.expired = false;
    }
}

function calculate_container_cost(duration_weeks: integer, container_units: integer, extra_storage_gib: integer): integer =
    (container_units * SCU_COST + extra_storage_gib * EXTRA_STORAGE_COST) * duration_weeks * 4;

operation __icmf_message(sender: byte_array, topic: text, body: gtv) {
    require_initialized();

    if (not try_call(receive_icmf_message(sender, topic, body, *))) {
        log("Error while processing ICMF message in topic %s".format(topic));
    }
}

function receive_icmf_message(sender: byte_array, topic: text, body: gtv) {
    if (topic != ticket_result_topic) {
        log("Unexpected ICMF topic %s".format(topic));
        return;
    }

    // No need to validate sender since we use a local ICMF receiver

    val message = ticket_result_message.from_gtv(body);
    val ticket = ticket @? { .rowid == rowid(message.ticket_id) };
    if (ticket == null) {
        log("ticket_id %s not found".format(message.ticket_id));
        return;
    }
    ticket.state = if (message.error_message == null) ticket_state.SUCCESS else ticket_state.FAILURE;
    ticket.error_message = message.error_message ?: "";

    when (ticket.type) {
        ticket_type.CREATE_CONTAINER -> {
            val specific_ticket = create_container_ticket @ { ticket };
            when (ticket.state) {
                ticket_state.SUCCESS -> {
                    log("Successfully created container for ticket %s".format(message.ticket_id));
                    create lease(
                        pubkey = ticket.pubkey,
                        container_name = message.container_name!!,
                        container_units = specific_ticket.container_units,
                        extra_storage_gib = specific_ticket.extra_storage_gib,
                        start_time = op_context.last_block_time,
                        duration_millis = specific_ticket.duration_millis
                    );
                }
                ticket_state.FAILURE -> {
                    log("Failed to create container for ticket %s".format(message.ticket_id));

                    ft4.assets.Unsafe.transfer(get_pool_account(), ticket.account, get_asset(), specific_ticket.cost);
                }
            }
        }
    }
}

query get_ticket_by_transaction(tx_rid: byte_array): ticket_data? =
    ticket @? { .transaction.tx_rid == tx_rid } (ticket_data(.rowid.to_integer(), .type, .state, .error_message));

query get_ticket_by_id(ticket_id: integer): ticket_data? =
    ticket @? { .rowid == rowid(ticket_id) } (ticket_data(.rowid.to_integer(), .type, .state, .error_message));

query get_leases_by_pubkey(pubkey): list<lease_data> =
    lease @* { pubkey } (lease_data(.container_name, container_units = .container_units, extra_storage_gib = .extra_storage_gib, expire_time_millis = .start_time + .duration_millis, .expired));

function require_initialized() {
    require(state.initialized == true, "Ticket chain is not initialized");
}

function require_pubkey(pubkey) {
    require(pubkey.size() == 33 or pubkey.size() == 65 or pubkey.size() == 1336, "Value is not pubkey: " + pubkey);
}

function register_assets() {
    ft4.assets.Unsafe.register_asset(
            chain_context.args.asset_name,
            chain_context.args.asset_symbol,
            chain_context.args.asset_decimals,
            chain_context.blockchain_rid,
            chain_context.args.asset_icon
        );
}

function get_asset(): ft4.assets.asset {
    val asset_id = (chain_context.args.asset_name, chain_context.blockchain_rid).hash();
    return ft4.assets.asset @ { .id == asset_id };
}

function create_pool_account(): ft4.acc.account {
    return ft4.acc.account_by_id(ft4.acc.Unsafe.create_account_with_auth(get_pool_account_auth_descriptor()));
}

function get_pool_account() = ft4.acc.account_by_id(get_pool_account_auth_descriptor().hash());

function get_pool_account_auth_descriptor() = ft4.acc.single_sig_auth_descriptor(chain_context.args.pool_account_pubkey, set(["A", "T"]));
