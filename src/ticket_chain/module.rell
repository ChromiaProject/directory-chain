module;

import messaging.ticketing.*;
import messaging.icmf.*;

import lib.auth;

namespace ft4 {
    import lib.ft4.accounts;
    import lib.ft4.assets;
    import lib.ft4.auth;
    import lib.ft4.version;
}

// TODO: Revise when we have real pricing
val SCU_COST = 1;
val EXTRA_STORAGE_COST = 1;

struct module_args {
    asset_name: text;
    asset_symbol: text;
    asset_icon: text;
    asset_decimals: integer;
    amount_to_mint: big_integer;
    pool_account_pubkey: pubkey;
    admin_pubkey: pubkey;
}

// Rell does not have a power function/operator
val units_per_asset = integer("1" + "0".repeat(chain_context.args.asset_decimals));

val millis_per_week = 7 * 24 * 60 * 60 * 1000;

enum ticket_state {
    PENDING, SUCCESS, FAILURE
}

enum ticket_type {
    CREATE_CONTAINER, UPGRADE_CONTAINER
}

object state {
    mutable initialized: boolean = false;
}

entity user {
    key ft4.accounts.account;
    mutable last_refill_millis: integer;
}

entity lease {
    key container_name: text;
    index ft4.accounts.account;
    container_units: integer;
    extra_storage_gib: integer;
    cluster_class: text;
    start_time: integer;
    mutable duration_millis: integer;
    mutable expired: boolean = false;
    mutable auto_renew: boolean = false;
}

entity ticket {
    index transaction = op_context.transaction;
    index type: ticket_type;
    account: ft4.accounts.account;
    mutable state: ticket_state = ticket_state.PENDING;
    mutable error_message: text = "";
}

entity create_container_ticket {
    key ticket;
    container_units: integer;
    extra_storage_gib: integer;
    duration_millis: integer;
    cluster_class: text;
    cost: integer;
    auto_renew: boolean = false;
    mutable container_name: text = "";
}

entity upgrade_container_ticket {
    key ticket;
    container_name: text;
    container_units: integer;
    extra_storage_gib: integer;
    cluster_class: text;
    cost: integer;
}

struct container_ticket_data {
    ticket_id: integer;
    type: ticket_type;
    state: ticket_state;
    error_message: text;
    container_name: text;
}

struct lease_data {
    container_name: text;
    container_units: integer;
    extra_storage_gib: integer;
    expire_time_millis: integer;
    expired: boolean;
    auto_renew: boolean;
}

operation init() {
    require(state.initialized == false, "Ticket chain is already initialized");
    state.initialized = true;

    register_assets();

    create_pool_account();

    log("Ticket chain was initialized");
}

operation __begin_block(height: integer) {
    if (state.initialized) {
        expire_leases(op_context.last_block_time);
    }
}

function expire_leases(current_time_millis: integer) {
    for (lease in lease @* { current_time_millis > .start_time + .duration_millis, .expired == false }) {
        // Don't touch leases for containers that are currently being upgraded
        if (not has_pending_upgrade(lease.container_name)) {
            maybe_expire_lease(lease);
        }
    }
}

function maybe_expire_lease(lease) {
    if (lease.auto_renew) {
        log("Auto-renewing lease for container %s".format(lease.container_name));
        val success = try_call(renew_container_lease(lease.account, lease, 1, *));
        if (not success) {
            log("Unable to auto-renew lease for container %s".format(lease.container_name));
            expire_lease(lease);
        }
    } else {
        expire_lease(lease);
    }
}

function expire_lease(lease) {
    lease.expired = true;
    log("Lease for container %s has expired, stopping it".format(lease.container_name));
    send_message(stop_container_topic, stop_container_message(container_name = lease.container_name).to_gtv()); // fire-and-forget
}

@extend(auth.before_account_registration) function(ft4.accounts.auth_descriptor, ft4.auth.signature) {
    before_account_registration(auth_descriptor);
}

function before_account_registration(ft4.accounts.auth_descriptor) {
    require_initialized();
}

@extend(auth.after_account_registration) function(ft4.accounts.account, ft4.accounts.auth_descriptor, ft4.auth.signature) {
    after_account_registration(account, auth_descriptor);
}

function after_account_registration(ft4.accounts.account, ft4.accounts.auth_descriptor) {
    log("Account created: %s".format(account.id));

    ft4.assets.Unsafe.mint(account, get_asset(), chain_context.args.amount_to_mint);

    create user(account = account, last_refill_millis = op_context.last_block_time);
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "claim_test_chr",
    flags = ["T"],
    message = claim_test_chr_auth_message(*)
);

function claim_test_chr_auth_message(gtv) =
    "Please sign the message\nto receive %s %s on account {account_id}".format(
        ft4.assets.format_amount_with_decimals(chain_context.args.amount_to_mint, chain_context.args.asset_decimals),
        chain_context.args.asset_symbol);

operation claim_test_chr() {
    require_initialized();

    val account = ft4.auth.authenticate();
    val user = require(user @? { account }, "No user for account %s".format(account.id));

    require(user.last_refill_millis + millis_per_week < op_context.last_block_time,
        "You have already claimed %s within the last 7 days, come back later".format(chain_context.args.asset_name));

    ft4.assets.Unsafe.mint(account, get_asset(), chain_context.args.amount_to_mint);
    user.last_refill_millis = op_context.last_block_time;
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "create_container",
    flags = ["T"],
    message = create_container_auth_message(*)
);

function create_container_auth_message(gtv): text {
    val args = struct<create_container>.from_gtv(gtv);
    val cluster_class_message = if (args.cluster_class.empty()) "" else " of class %s".format(args.cluster_class);
    val cost = calculate_container_cost(args.duration_weeks, args.container_units, args.extra_storage_gib);
    return "Please sign the message\nto lease container %s\nwith %s SCUs and %s GiB extra storage\nin cluster %s\nfor %s weeks\ncosting %s %s\n%son account {account_id}".format(
        cluster_class_message,
        args.container_units,
        args.extra_storage_gib,
        args.cluster_name,
        args.duration_weeks,
        ft4.assets.format_amount_with_decimals(cost, chain_context.args.asset_decimals),
        chain_context.args.asset_symbol,
        if (args.auto_renew) "with auto-renewal\n" else "");
}

operation create_container(
        provider_pubkey: pubkey,
        container_units: integer,
        cluster_class: text,
        duration_weeks: integer,
        extra_storage_gib: integer,
        cluster_name: text,
        auto_renew: boolean) {
    require_initialized();
    require_pubkey(provider_pubkey);
    require(container_units > 0, "container_units must be positive");
    require(duration_weeks > 0, "duration_weeks must be positive");
    require(extra_storage_gib > -1, "extra_storage_gib must not be negative");

    val account = ft4.auth.authenticate();
    require(user @? { account }, "No user for account %s".format(account.id));

    val cost = calculate_container_cost(duration_weeks, container_units, extra_storage_gib);
    ft4.assets.Unsafe.transfer(account, get_pool_account(), get_asset(), cost);

    val ticket = create ticket(type = ticket_type.CREATE_CONTAINER, account);
    create create_container_ticket(ticket,
        container_units = container_units,
        extra_storage_gib = extra_storage_gib,
        duration_millis = duration_weeks * millis_per_week,
        cluster_class = cluster_class,
        cost = cost,
        auto_renew = auto_renew
    );
    send_message(create_container_topic, create_container_message(
        ticket_id = ticket.rowid.to_integer(),
        provider_pubkey = provider_pubkey,
        container_units = container_units,
        cluster_class = cluster_class,
        extra_storage = 1024 * extra_storage_gib,
        cluster_name = cluster_name
    ).to_gtv());
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "upgrade_container",
    flags = ["T"],
    message = upgrade_container_auth_message(*)
);

function upgrade_container_auth_message(gtv): text {
    val args = struct<upgrade_container>.from_gtv(gtv);
    val lease = require_lease(args.container_name);
    val lease_duration_in_weeks = lease.duration_millis / millis_per_week;
    val cluster_class_message = if (args.upgraded_cluster_class.empty()) "" else " of class %s".format(args.upgraded_cluster_class);
    val cost = calculate_container_cost(lease_duration_in_weeks, args.upgraded_container_units, args.upgraded_extra_storage_gib);
    return "Please sign the message\nto upgrade container %s %s\nto have %s SCUs and %s GiB extra storage\nin cluster %s\nfor %s weeks\ncosting (before applying refund of current lease) %s %s\n%son account {account_id}".format(
        args.container_name,
        cluster_class_message,
        args.upgraded_container_units,
        args.upgraded_extra_storage_gib,
        lease_duration_in_weeks,
        ft4.assets.format_amount_with_decimals(cost, chain_context.args.asset_decimals),
        chain_context.args.asset_symbol
    );
}

operation upgrade_container(
        container_name: text,
        upgraded_container_units: integer,
        upgraded_cluster_class: text,
        upgraded_extra_storage_gib: integer,
        upgraded_cluster_name: text
) {
    require_initialized();
    val lease = require_lease(container_name);
    require(not has_pending_upgrade(container_name), "Container already has a pending upgrade");
    require(
        upgraded_container_units != lease.container_units or upgraded_extra_storage_gib != lease.extra_storage_gib or upgraded_cluster_class != lease.cluster_class,
        "New container specifications are identical to current lease"
    );
    require(upgraded_container_units >= lease.container_units, "new_container_units must be greater or equal to current lease");
    require(upgraded_extra_storage_gib >= lease.extra_storage_gib, "extra_storage_gib must be greater or equal to current lease");
    // TODO validate that upgraded_cluster_class >= cluster_class whenever we have that pricing logic

    val account = ft4.auth.authenticate();
    require(user @? { account }, "No user for account %s".format(account.id));
    require(lease.account == account, "Lease for container %s was not created by you".format(container_name));

    val cost = calculate_container_cost(lease.duration_millis / millis_per_week, upgraded_container_units, upgraded_extra_storage_gib)
        - if (lease.expired) 0 else calculate_remaining_lease_value(lease, op_context.last_block_time);
    ft4.assets.Unsafe.transfer(account, get_pool_account(), get_asset(), cost);

    val ticket = create ticket(type = ticket_type.UPGRADE_CONTAINER, account);
    create upgrade_container_ticket(ticket,
        container_name = container_name,
        container_units = upgraded_container_units,
        extra_storage_gib = upgraded_extra_storage_gib,
        cluster_class = upgraded_cluster_class,
        cost = cost
    );
    send_message(upgrade_container_topic, upgrade_container_message(
        ticket_id = ticket.rowid.to_integer(),
        container_name = container_name,
        container_units = upgraded_container_units,
        cluster_class = upgraded_cluster_class,
        extra_storage = 1024 * upgraded_extra_storage_gib,
        cluster_name = upgraded_cluster_name
    ).to_gtv());
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "renew_container",
    flags = ["T"],
    message = renew_container_auth_message(*)
);

function renew_container_auth_message(gtv): text {
    val args = struct<renew_container>.from_gtv(gtv);

    val lease = require_lease(args.container_name);
    val cost = calculate_container_cost(args.duration_weeks, lease.container_units, lease.extra_storage_gib);

    return "Please sign the message\nto renew lease of container %s\nfor %s weeks\ncosting %s %s\non account {account_id}".format(
        args.container_name,
        args.duration_weeks,
        ft4.assets.format_amount_with_decimals(cost, chain_context.args.asset_decimals),
        chain_context.args.asset_symbol);
}

operation renew_container(container_name: text, duration_weeks: integer) {
    require_initialized();
    require(duration_weeks > 0, "duration_weeks must be positive");

    val account = ft4.auth.authenticate();
    require(user @? { account }, "No user for account %s".format(account.id));

    val lease = require_lease(container_name);

    renew_container_lease(account, lease, duration_weeks);
    if (lease.expired) {
        restart_container(lease);
    }
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "auto_renew_container",
    flags = ["T"],
    message = auto_renew_container_auth_message(*)
);

function auto_renew_container_auth_message(gtv): text {
    val args = struct<auto_renew_container>.from_gtv(gtv);

    val lease = require_lease(args.container_name);
    val weekly_cost = calculate_container_cost(1, lease.container_units, lease.extra_storage_gib);

    return "Please sign the message\nto enable auto-renewal of container %s\ncosting %s %s per week\non account {account_id}".format(
        args.container_name,
        ft4.assets.format_amount_with_decimals(weekly_cost, chain_context.args.asset_decimals),
        chain_context.args.asset_symbol);
}

operation auto_renew_container(container_name: text) {
    require_initialized();

    val account = ft4.auth.authenticate();
    require(user @? { account }, "No user for account %s".format(account.id));

    val lease = require_lease(container_name);
    require(lease.account == account, "Lease for container %s was not created by you".format(container_name));
    require(lease.auto_renew == false, "Container %s is already auto-renewing".format(container_name));

    lease.auto_renew = true;

    if (lease.expired) {
        renew_container_lease(account, lease, 1);
        restart_container(lease);
    }
}

@extend(ft4.auth.auth_handler)
function () = ft4.auth.add_auth_handler(
    scope = "cancel_renew_container",
    flags = ["T"],
    message = cancel_renew_container_auth_message(*)
);

function cancel_renew_container_auth_message(gtv): text {
    val args = struct<cancel_renew_container>.from_gtv(gtv);

    val lease = require_lease(args.container_name);

    return "Please sign the message\nto cancel auto-renewal of container %s\non account {account_id}".format(
        args.container_name);
}

operation cancel_renew_container(container_name: text) {
    require_initialized();

    val account = ft4.auth.authenticate();
    require(user @? { account }, "No user for account %s".format(account.id));

    val lease = require_lease(container_name);
    require(lease.account == account, "Lease for container %s was not created by you".format(container_name));
    require(lease.auto_renew == true, "Container %s is not auto-renewing".format(container_name));

    lease.auto_renew = false;
}

function renew_container_lease(ft4.accounts.account, lease, duration_weeks: integer) {
    val cost = calculate_container_cost(duration_weeks, lease.container_units, lease.extra_storage_gib);
    ft4.assets.Unsafe.transfer(account, get_pool_account(), get_asset(), cost);
    lease.duration_millis += duration_weeks * millis_per_week;
}

function restart_container(lease) {
    log("Lease for container %s was expired, restarting it".format(lease.container_name));
    send_message(restart_container_topic, restart_container_message(container_name = lease.container_name).to_gtv()); // fire-and-forget
    // TODO what if restart fails?
    lease.expired = false;
}

// TODO: Consider cluster class in pricing (when we actually know how it should be calculated)!
function calculate_container_cost(duration_weeks: integer, container_units: integer, extra_storage_gib: integer): integer =
    (container_units * SCU_COST + extra_storage_gib * EXTRA_STORAGE_COST) * duration_weeks * 4 * units_per_asset;

function calculate_remaining_lease_value(lease, current_time: integer): integer {
    val lease_weekly_cost = calculate_container_cost(1, lease.container_units, lease.extra_storage_gib);
    val remaining_lease_time = lease.start_time + lease.duration_millis - current_time;
    val remaining_weeks = decimal(remaining_lease_time) / decimal(millis_per_week);
    val remaining_value = remaining_weeks * lease_weekly_cost;
    return remaining_value.round().to_integer();
}

function has_pending_upgrade(container_name: text): boolean {
    val upgrade_ticket = upgrade_container_ticket @? { container_name };
    return upgrade_ticket != null and upgrade_ticket.ticket.state == ticket_state.PENDING;
}

operation __icmf_message(sender: byte_array, topic: text, body: gtv) {
    require_initialized();

    if (not try_call(receive_icmf_message(sender, topic, body, *))) {
        log("Error while processing ICMF message in topic %s".format(topic));
    }
}

function receive_icmf_message(sender: byte_array, topic: text, body: gtv) {
    if (topic != ticket_result_topic) {
        log("Unexpected ICMF topic %s".format(topic));
        return;
    }

    // No need to validate sender since we use a local ICMF receiver

    val message = ticket_result_message.from_gtv(body);
    val ticket = ticket @? { .rowid == rowid(message.ticket_id) };
    if (ticket == null) {
        log("ticket_id %s not found".format(message.ticket_id));
        return;
    }
    ticket.state = if (message.error_message == null) ticket_state.SUCCESS else ticket_state.FAILURE;
    ticket.error_message = message.error_message ?: "";

    when (ticket.type) {
        ticket_type.CREATE_CONTAINER -> {
            val specific_ticket = create_container_ticket @ { ticket };
            when (ticket.state) {
                ticket_state.SUCCESS -> {
                    val container_name = message.container_name!!;
                    log("Successfully created container %s for ticket %s".format(container_name, message.ticket_id));
                    specific_ticket.container_name = container_name;
                    create lease(
                        container_name = container_name,
                        account = ticket.account,
                        container_units = specific_ticket.container_units,
                        extra_storage_gib = specific_ticket.extra_storage_gib,
                        cluster_class = specific_ticket.cluster_class,
                        start_time = op_context.last_block_time,
                        duration_millis = specific_ticket.duration_millis,
                        auto_renew = specific_ticket.auto_renew
                    );
                }
                ticket_state.FAILURE -> {
                    log("Failed to create container for ticket %s".format(message.ticket_id));

                    ft4.assets.Unsafe.transfer(get_pool_account(), ticket.account, get_asset(), specific_ticket.cost);
                }
            }
        }
        ticket_type.UPGRADE_CONTAINER -> {
            val specific_ticket = upgrade_container_ticket @ { ticket };
            when (ticket.state) {
                ticket_state.SUCCESS -> {
                    // Note: When we implement "move" the container name might change so we should check what name D1 returns
                    val upgraded_container_name = message.container_name!!;
                    log("Successfully upgraded container %s for ticket %s".format(upgraded_container_name, message.ticket_id));
                    val current_lease = lease @ { .container_name == specific_ticket.container_name };
                    val currently_auto_renewed = current_lease.auto_renew;
                    val current_duration = current_lease.duration_millis;
                    delete current_lease;
                    create lease(
                        container_name = upgraded_container_name,
                        account = ticket.account,
                        container_units = specific_ticket.container_units,
                        extra_storage_gib = specific_ticket.extra_storage_gib,
                        cluster_class = specific_ticket.cluster_class,
                        start_time = op_context.last_block_time,
                        duration_millis = current_duration,
                        auto_renew = currently_auto_renewed
                    );
                }
                ticket_state.FAILURE -> {
                    log("Failed to upgrade container for ticket %s".format(message.ticket_id));

                    ft4.assets.Unsafe.transfer(get_pool_account(), ticket.account, get_asset(), specific_ticket.cost);
                }
            }
        }
    }
}

query get_chr_asset() = ft4.assets.map_asset(get_asset());

query get_balance(account_id: byte_array): big_integer {
    val account = require(ft4.accounts.account @? { account_id }, "Account %s not found".format(account_id));
    return get_account_balance(account);
}

query get_pool_balance(): big_integer = get_account_balance(get_pool_account());

query get_create_container_ticket_by_transaction(tx_rid: byte_array): container_ticket_data? =
    create_container_ticket @? { .ticket.transaction.tx_rid == tx_rid }
        (container_ticket_data(.ticket.rowid.to_integer(), .ticket.type, .ticket.state, error_message = .ticket.error_message, container_name = .container_name));

query get_create_container_ticket_by_id(ticket_id: integer): container_ticket_data? =
    create_container_ticket @? { .ticket.rowid == rowid(ticket_id) }
        (container_ticket_data(.ticket.rowid.to_integer(), .ticket.type, .ticket.state, error_message = .ticket.error_message, container_name = .container_name));

query get_upgrade_container_ticket_by_transaction(tx_rid: byte_array): container_ticket_data? =
    upgrade_container_ticket @? { .ticket.transaction.tx_rid == tx_rid }
        (container_ticket_data(.ticket.rowid.to_integer(), .ticket.type, .ticket.state, error_message = .ticket.error_message, container_name = .container_name));

query get_upgrade_container_ticket_by_id(ticket_id: integer): container_ticket_data? =
    upgrade_container_ticket @? { .ticket.rowid == rowid(ticket_id) }
        (container_ticket_data(.ticket.rowid.to_integer(), .ticket.type, .ticket.state, error_message = .ticket.error_message, container_name = .container_name));

query get_leases_by_account(account_id: byte_array): list<lease_data> =
    lease @* { .account.id == account_id } (lease_data(.container_name, container_units = .container_units, extra_storage_gib = .extra_storage_gib, expire_time_millis = .start_time + .duration_millis, .expired, .auto_renew));

query get_lease_by_container_name(container_name: text): lease_data? =
    lease @? { container_name } (lease_data(.container_name, container_units = .container_units, extra_storage_gib = .extra_storage_gib, expire_time_millis = .start_time + .duration_millis, .expired, .auto_renew));

function require_initialized() {
    require(state.initialized == true, "Ticket chain is not initialized");
}

function require_pubkey(pubkey) {
    require(pubkey.size() == 33 or pubkey.size() == 65 or pubkey.size() == 1336, "Value is not pubkey: " + pubkey);
}

function require_lease(container_name: text) = require(lease @? { container_name }, "No current lease for container %s".format(container_name));

function register_assets() {
    ft4.assets.Unsafe.register_asset(
            chain_context.args.asset_name,
            chain_context.args.asset_symbol,
            chain_context.args.asset_decimals,
            chain_context.blockchain_rid,
            chain_context.args.asset_icon
        );
}

function get_account_balance(ft4.accounts.account): big_integer =
    (ft4.assets.balance @? { account, get_asset() }.amount) ?: 0L;

function get_asset(): ft4.assets.asset {
    val asset_id = (chain_context.args.asset_name, chain_context.blockchain_rid).hash();
    return ft4.assets.asset @ { .id == asset_id };
}

function create_pool_account(): ft4.accounts.account {
    return ft4.accounts.account_by_id(ft4.accounts.Unsafe.create_account_with_auth(get_pool_account_auth_descriptor()));
}

function get_pool_account() = ft4.accounts.account_by_id(get_pool_account_auth_descriptor().hash());

function get_pool_account_auth_descriptor() = ft4.accounts.single_sig_auth_descriptor(chain_context.args.pool_account_pubkey, set(["A", "T"]));
