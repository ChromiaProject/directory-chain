entity pending_configuration {
    key proposal;
    blockchain;
    data: byte_array;
}

@extend(apply_voting_result_handlers) function() = [proposal_type.configuration.name: apply_configuration(*)];

function apply_configuration(proposal) {
    val pc = pending_configuration @? { proposal };
    if (pc == null) return;
    val is_chain0 = pc.blockchain.rid == chain_context.blockchain_rid;

    if (is_chain0) {
        apply_configuration_chain0(pc);
    } else if (pcu_enabled()) {
        apply_configuration_pcu(pc);
    } else {
        apply_configuration_legacy(pc);
    }
}

@extend(delete_proposal_handlers) function(): map<text, (proposal) -> unit> = [proposal_type.configuration.name: delete_pending_configuration(*)];

function delete_pending_configuration(proposal) {
    delete pending_configuration @? { proposal };
}

function apply_configuration_chain0(pc: pending_configuration) {
    val apply_at_height = op_context.block_height + 1; // NB: compute_blockchain_info_list()/get_cluster_node_blockchains() relies on this
    log("Base configuration update chain0 at height %d".format(apply_at_height));
    require(empty(blockchain_configuration @? { pc.blockchain, apply_at_height }), "Configuration at height %d already exists".format(apply_at_height));
    val unique_base_config = make_config_unique(pc.data);
    create blockchain_configuration(pc.blockchain, apply_at_height, unique_base_config);
    add_dependencies(unique_base_config, pc.blockchain.rid, apply_at_height);
}

function apply_configuration_pcu(pc: pending_configuration) {
    val last_configuration_height = (blockchain_configuration @? { pc.blockchain } (@sort_desc .height) limit 1) ?: 0;
    val last_pending_configuration = pending_blockchain_configuration @? { pc.blockchain } (@sort_desc @omit .minimum_height, $) limit 1;
    val (minimum_height, signers) = if (last_pending_configuration != null)
        (last_configuration_height.max(last_pending_configuration.minimum_height) + 1,
         last_pending_configuration.signers)
     else
        (last_configuration_height + 1,
         blockchain_configuration_signers @ { pc.blockchain } (@omit @sort_desc .height, .signers) limit 1);
    log("Base configuration update with PCU for chain %s at minimum height %d".format(pc.blockchain.rid, minimum_height));
    val unique_base_config = make_config_unique(pc.data);
    val full_config = map<text, gtv>.from_gtv(gtv.from_bytes(unique_base_config));
    full_config["signers"] = gtv.from_bytes(signers);
    create pending_blockchain_configuration(
        pc.blockchain,
        minimum_height,
        config_hash = full_config.to_gtv().hash(),
        base_config = unique_base_config,
        signers
    );
}

function apply_configuration_legacy(pc: pending_configuration) {
    val apply_at_height = get_last_height(pc.blockchain) + 10;
    log("Base configuration update without PCU for chain %s at height %d".format(pc.blockchain.rid, apply_at_height));
    require(empty(blockchain_configuration @? { pc.blockchain, apply_at_height }), "Configuration at height %d already exists".format(apply_at_height));
    create blockchain_configuration(pc.blockchain, apply_at_height, pc.data);
    add_dependencies(pc.data, pc.blockchain.rid, apply_at_height);
}

operation propose_configuration(my_pubkey: pubkey, blockchain_rid: byte_array, config_data: byte_array, description: text = "") {
    val me = require_is_provider_with_rate_limit(my_pubkey);
    val blockchain = require_blockchain(blockchain_rid);
    val container = container_blockchain @ {blockchain} .container;
    require_container_deployer(container, me);
    val is_chain0 = blockchain.rid == chain_context.blockchain_rid;

    validate_blockchain_configuration(config_data, signers = not is_chain0, header_hash = pcu_enabled() and not is_chain0);

    val prop = create proposal(op_context.last_block_time, proposal_type.configuration, me, container.deployer, description);
    create pending_configuration(prop, blockchain, config_data);
    internal_vote(me, prop, true);
}

query get_configuration_proposal(rowid?): (
    current_conf:struct<blockchain_configuration>,
    proposed_conf:struct<pending_configuration>
)? {
    val proposal = get_latest_proposal(rowid, proposal_type.configuration);
    if (proposal == null) return null;
    val config = pending_configuration @? { require_proposal(proposal.rowid) };
    if (config == null) return null;

    val current = (blockchain_configuration @ { config.blockchain, .height < deprecated_get_blockchain_last_height(config.blockchain.rid) }
     (@omit @sort_desc .height, $) limit 1);

    return (
        current_conf = current.to_struct(),
        proposed_conf = config.to_struct()
    );
}