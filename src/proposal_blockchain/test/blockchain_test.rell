@test module;

import ^^.*;
import common.test.ops.*;
import common.test.setup.*;
import common.test.util.*;
import proposal.voting.test.ops.*;
import proposal_container.*;
import direct_container.*;

function setup() {
    setup_module();
    rell.test.tx().op(create_test_provider("bob", rell.test.pubkeys.bob)).run();
}

function test_propose_blockchain() {
    setup();

    val cl = system_cluster();
    val container = "container";
    val alice = provider @ { rell.test.pubkeys.alice };
    val bob = provider @ { rell.test.pubkeys.bob };
    rell.test.tx().op(add_test_member(system_p_voter_set(), bob)).run();

    var conf = ["config_consensus_strategy": "HEADER_HASH".to_gtv()];
    // proposing blockchain to a system container will fail
    rell.test.tx().op(
        propose_blockchain(alice.pubkey, conf.to_gtv().to_bytes(), "foo_chain", system_container_name(clusters.system))
    ).sign(rell.test.keypairs.alice).run_must_fail("Proposing blockchain to a system container is not allowed");
    // proposing blockchain to a non-system container
    rell.test.tx().op(
        create_container(alice.pubkey, container, clusters.system, 0, [alice.pubkey, bob.pubkey]),
        propose_blockchain(alice.pubkey, conf.to_gtv().to_bytes(), "foo_chain", container)
    ).sign(rell.test.keypairs.alice).run();
    val tx_rid = transaction @ {} (@sort_desc @omit .rowid, .tx_rid) limit 1;

    // Proposal is pending
    val prop = last_proposal();
    val config_proposal = get_blockchain_proposal(prop.rowid);
    assert_not_null(config_proposal);
    assert_equals(config_proposal.container, "container");
    assert_null(find_blockchain_rid(tx_rid));

    rell.test.tx().op(
        create_test_node(alice, rell.test.pubkeys.alice, cl)
    ).sign(rell.test.keypairs.alice).run_must_fail();

    // Bob votes
    bob_votes();

    // Asserting blockchain is running
    val bc = blockchain @ { .name == "foo_chain" };
    assert_equals(bc.state, blockchain_state.RUNNING);
    assert_equals(find_blockchain_rid(tx_rid), bc.rid);

    // 2. Proposing blockchain pause
    alice_proposes_action(bc, blockchain_action.pause);
    assert_action_proposed(blockchain_action.pause);
    bob_votes();
    assert_equals(bc.state, blockchain_state.PAUSED);

    // 3. Proposing blockchain resume
    alice_proposes_action(bc, blockchain_action.resume);
    assert_action_proposed(blockchain_action.resume);
    bob_votes();
    assert_equals(bc.state, blockchain_state.RUNNING);

    // 4. Proposing blockchain remove
    val brid = bc.rid;
    alice_proposes_action(bc, blockchain_action.remove);
    assert_action_proposed(blockchain_action.remove);
    bob_votes();
    assert_not_null( blockchain @? { .rid == brid } );
    assert_equals(bc.state, blockchain_state.REMOVED);
    assert_false(empty(blockchain_configuration @* { bc }));
    assert_false(empty(blockchain_configuration_signers @* { bc }));
}

function alice_proposes_action(bc: blockchain, action: blockchain_action) {
    rell.test.tx().op(
        propose_blockchain_action(rell.test.pubkeys.alice, bc.rid, action)
    ).sign(rell.test.keypairs.alice).run();
}

function bob_votes() {
    val bob = rell.test.pubkeys.bob;
    rell.test.tx().op(
        make_vote(bob, last_proposal().rowid.to_integer(), true)
    ).sign(rell.test.keypairs.bob).run();
}

function assert_action_proposed(action: blockchain_action) {
    assert_equals(
        pending_blockchain_action @ { last_proposal() } .action,
        action
    );
}

function test_propose_configuration_at() {
    setup_module();

    var conf = ["config_consensus_strategy": "HEADER_HASH".to_gtv()];
    rell.test.tx().op(
        create_container(initial_provider.pub, "container", clusters.system, 0, [initial_provider.pub])
    ).sign(initial_provider).run();

    // NB: Proposing config at a specific chain for non-chain0 can not be tested due to limitations of Rell Test Framework
    val c0 = blockchain @ { blockchains.directory_chain };

    // 1. force == false
    // 1.1. at height 10
    conf["nonce"] = (10).to_gtv();
    propose_config_at(c0.rid, conf, 10, false).run();
    assert_not_null(blockchain_configuration @? { c0, 10 });
    // 1.2. before 10
    conf["nonce"] = (8).to_gtv();
    propose_config_at(c0.rid, conf, 8, false).run();
    assert_not_null(blockchain_configuration @? { c0, 8 });

    // assert unique configurations
    assert_not_equals(
        blockchain_configuration @? { c0, 10 } (.data),
        blockchain_configuration @? { c0, 8 } (.data)
    );

    // 1.3. again 10
    propose_config_at(c0.rid, conf, 10, false).run_must_fail();
    // 1.4. height is null
    propose_config_at(c0.rid, conf, -1, false).run_must_fail();
    // 1.5. height is -2, to be less than last_height (-1)
    propose_config_at(c0.rid, conf, -2, false).run_must_fail();

    // 2. force == true
    var conf2 = ["config_consensus_strategy": "HEADER_HASH".to_gtv()];
    conf2["name"] = "conf2".to_gtv();
    propose_config_at(c0.rid, conf2, 8, true).run();
    val actual_config_bytes = blockchain_configuration @ { c0, 8 } (.data);
    val actual_config = map<text, gtv>.from_gtv(gtv.from_bytes(actual_config_bytes));
    assert_equals(actual_config["name"], "conf2".to_gtv());
    // NB: we can't test `height = -1` case
    // propose_config_at(c0.rid, conf, -1, false).run();
    // See kotlin test
}

function propose_config_at(brid: byte_array, conf: map<text, gtv>, height: integer, force: boolean) {
    return rell.test.tx().op(
        propose_configuration_at(initial_provider.pub, brid, conf.to_gtv().to_bytes(), height, force)
    ).sign(initial_provider);
}
