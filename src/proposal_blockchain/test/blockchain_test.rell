@test module;

import ^^.*;
import common.test.ops.*;
import common.test.setup.*;
import common.test.util.*;
import proposal.voting.test.ops.*;
import proposal_container.*;

function setup() {
    setup_module();
    rell.test.tx().op(create_test_provider("bob", rell.test.pubkeys.bob)).run();
}

function test_propose_blockchain() {
    setup();

    val cl = system_cluster();
    val co = system_container();
    val alice = provider @ { rell.test.pubkeys.alice };
    val bob = provider @ { rell.test.pubkeys.bob };
    rell.test.tx().op(add_test_member(system_p_voter_set(), bob)).run();

    var conf = ["config_consensus_strategy": "HEADER_HASH".to_gtv()];
    rell.test.tx().op(
        propose_blockchain(alice.pubkey, conf.to_gtv().to_bytes(), "foo_chain", co.name)
    ).sign(rell.test.keypairs.alice).run();

    // Proposal is pending
    val prop = last_proposal();
    val config_proposal = get_blockchain_proposal(prop.rowid);
    assert_not_null(config_proposal);
    assert_equals(config_proposal.container, system_container_name(cl.name));

    rell.test.tx().op(
        create_test_node(alice, rell.test.pubkeys.alice, cl)
    ).sign(rell.test.keypairs.alice).run_must_fail();

    // Bob votes
    bob_votes();

    // Asserting blockchain is running
    val bc = blockchain @ { .name == "foo_chain" };
    assert_equals(bc.state, blockchain_state.RUNNING);

    // 2. Proposing blockchain pause
    alice_proposes_action(bc, blockchain_action.pause);
    assert_action_proposed(blockchain_action.pause);
    bob_votes();
    assert_equals(bc.state, blockchain_state.PAUSED);

    // 3. Proposing blockchain resume
    alice_proposes_action(bc, blockchain_action.resume);
    assert_action_proposed(blockchain_action.resume);
    bob_votes();
    assert_equals(bc.state, blockchain_state.RUNNING);

    // 4. Proposing blockchain remove
    val brid = bc.rid;
    alice_proposes_action(bc, blockchain_action.remove);
    assert_action_proposed(blockchain_action.remove);
    bob_votes();
    assert_not_null( blockchain @? { .rid == brid } );
    assert_equals(bc.state, blockchain_state.REMOVED);
    assert_false(empty(blockchain_configuration @* { bc }));
    assert_false(empty(blockchain_configuration_signers @* { bc }));

    // Proposal(s) is removed
    assert_null(proposal @? {} limit 1);
}

function alice_proposes_action(bc: blockchain, action: blockchain_action) {
    rell.test.tx().op(
        propose_blockchain_action(rell.test.pubkeys.alice, bc.rid, action)
    ).sign(rell.test.keypairs.alice).run();
}

function bob_votes() {
    val bob = rell.test.pubkeys.bob;
    rell.test.tx().op(
        make_vote(bob, last_proposal().rowid.to_integer(), true)
    ).sign(rell.test.keypairs.bob).run();
}

function assert_action_proposed(action: blockchain_action) {
    assert_equals(
        pending_blockchain_action @ { last_proposal() } .action,
        action
    );
}

function test_propose_configuration_at() {
    setup_module();

    var conf = ["config_consensus_strategy": "HEADER_HASH".to_gtv()];
    rell.test.tx().op(
        propose_blockchain(initial_provider.pub, conf.to_gtv().to_bytes(), "foo_chain", system_container_name(clusters.system))
    ).sign(initial_provider).run();
    val bc = blockchain @? { conf.hash() };
    assert_not_null(bc);

    // 1. force == false
    // 1.1. at height 10
    propose_config(bc.rid, conf, 10, false).run();
    assert_not_null(blockchain_configuration @? { bc, 10 });
    // 1.2. before 10
    propose_config(bc.rid, conf, 8, false).run();
    assert_not_null(blockchain_configuration @? { bc, 8 });

    // assert unique configurations
    assert_not_equals(blockchain_configuration @? { bc, 10 } (.data), blockchain_configuration @? { bc, 8 } (.data));

    // 1.3. again 10
    propose_config(bc.rid, conf, 10, false).run_must_fail();
    // 1.4. height is null
    propose_config(bc.rid, conf, -1, false).run_must_fail();
    // 1.5. height is -2, to be less than last_height (-1)
    propose_config(bc.rid, conf, -2, false).run_must_fail();

    // 2. force == true
    var conf2 = ["config_consensus_strategy": "HEADER_HASH".to_gtv()];
    conf2["name"] = "conf2".to_gtv();
    propose_config(bc.rid, conf2, 8, true).run();
    val actual_config_bytes = blockchain_configuration @ { bc, 8 } (.data);
    val actual_config = map<text, gtv>.from_gtv(gtv.from_bytes(actual_config_bytes));
    assert_equals(actual_config["name"], "conf2".to_gtv());
    // NB: we can't test `height = -1` case
    // propose_config(bc.rid, conf, -1, false).run();
    // See kotlin test
}

function propose_config(brid: byte_array, conf: map<text, gtv>, height: integer, force: boolean) {
    return rell.test.tx().op(
        propose_configuration_at(initial_provider.pub, brid, conf.to_gtv().to_bytes(), height, force)
    ).sign(initial_provider);
}

function test_propose_import_blockchain() {
    setup_module();

    val conf = ["config_consensus_strategy": "HEADER_HASH".to_gtv(), "signers": [initial_provider.pub].to_gtv()];
    val brid = conf.hash();
    val conf_bytes = conf.to_gtv().to_bytes();
    val container = system_container_name(clusters.system);
    val configurations = map<integer, byte_array>();

    // proposing a config at height 10 for unknown blockchain
    configurations.clear();
    configurations[10] = conf.hash();
    rell.test.tx().op(
        propose_import_blockchain(initial_provider.pub, "foo_chain", brid, configurations, container)
    ).sign(initial_provider).run_must_fail("Initial configuration needed for non-existing blockchain");

    // proposing an initial config, blockchain will be created in PAUSED state
    configurations.clear();
    configurations[0] = conf.hash();
    rell.test.tx().op(
        propose_import_blockchain(initial_provider.pub, "foo_chain", brid, configurations, container)
    ).sign(initial_provider).run();
    val bc = blockchain @? { brid };
    assert_not_null(bc);
    assert_equals(bc.state, blockchain_state.PAUSED);
    assert_true(exists(blockchain_configuration_hash @? { bc, 0 }));
    assert_false(exists(blockchain_configuration @? { bc, 0 }));

    // proposing a new config
    configurations.clear();
    configurations[10] = conf.hash();
    rell.test.tx().op(
        propose_import_blockchain(initial_provider.pub, "foo_chain", brid, configurations, container)
    ).sign(initial_provider).run();
    assert_true(exists(blockchain_configuration_hash @? { bc, 10 }));
    assert_false(exists(blockchain_configuration @? { bc, 10 }));

    // activating blockchain
    rell.test.tx().op(
        propose_blockchain_action(initial_provider.pub, brid, blockchain_action.resume)
    ).sign(initial_provider).run();
    assert_equals(bc.state, blockchain_state.RUNNING);

    // proposing a new config import for a running blockchain
    configurations.clear();
    configurations[100] = conf.hash();
    rell.test.tx().op(
        propose_import_blockchain(initial_provider.pub, "foo_chain", brid, configurations, container)
    ).sign(initial_provider).run_must_fail("Can't import blockchain in a state other than PAUSED");

    // importing blockchain to a full container
    val limits = map<container_resource_limit_type, integer>();
    limits[container_resource_limit_type.max_blockchains] = 2;
    val conf2 = conf;
    conf2.put("name", "bar_chain".to_gtv());
    val brid2 = conf2.hash();
    val conf2_bytes = conf2.to_gtv().to_bytes();
    configurations.clear();
    configurations[0] = conf2.hash();
    rell.test.tx().op(
        propose_container_limits(initial_provider.pub, container, limits),
        propose_import_blockchain(initial_provider.pub, "bar_chain", brid2, configurations, container)
    ).sign(initial_provider).run_must_fail("Can't add blockchain, container system is full");
}
