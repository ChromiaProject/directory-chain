entity pending_blockchain_import {
    key proposal;
    name;
    blockchain_rid: byte_array;
    container;
}

entity pending_blockchain_configuration_hash {
    key proposal;
    height: integer;
    config_hash: byte_array;
}

@extend(apply_voting_result_handlers) function() = [proposal_type.blockchain_import.name: apply_blockchain_import(*)];
@extend(delete_proposal_handlers) function(): map<text, (proposal) -> unit> = [proposal_type.blockchain_import.name: delete_pending_blockchain_import(*)];

operation propose_import_blockchain(my_pubkey: pubkey, bc_name: text, blockchain_rid: byte_array, configurations: map<integer, byte_array>, container_name: text, description: text = "Propose import blockchain") {
    val me = require_is_provider_with_rate_limit(my_pubkey);
    val container = require_container(container_name);
    require_container_deployer(container, me);

    val blockchain = blockchain @? { blockchain_rid };
    if (exists(blockchain)) {
        require(blockchain.state == blockchain_state.PAUSED, "Can't import blockchain in a state other than " + blockchain_state.PAUSED);
    } else {
        require(configurations.contains(0), "Initial configuration needed for non-existing blockchain");

        // Require container resource limits are honored
        require_container_is_not_full(container);
    }

    // If already proposed, do not add again.
    if (empty(pending_blockchain_import @* { .blockchain_rid == blockchain_rid } limit 1)) {
        val prop = create proposal(op_context.last_block_time, proposal_type.blockchain_import, me, container.deployer, description);
        create pending_blockchain_import(prop, bc_name, blockchain_rid, container);
        for ((height, config_hash) in configurations) {
            create pending_blockchain_configuration_hash(prop, height, config_hash);
        }
        internal_vote(me, prop, true);
    }
}

function apply_blockchain_import(proposal) {
    val pbi = pending_blockchain_import @? { proposal };
    if (pbi == null) return;

    var blockchain = blockchain @? { pbi.blockchain_rid };
    if (empty(blockchain)) {
        require_not_empty(pending_blockchain_configuration_hash @? { proposal, 0 }, "Initial configuration needed for non-existing blockchain" + pbi.blockchain_rid);
        require_container_is_not_full(pbi.container);        
        blockchain = create blockchain(pbi.blockchain_rid, pbi.name, system = false, state = blockchain_state.PAUSED);
        create container_blockchain(pbi.container, blockchain);

        log("New blockchain imported: %s / %s".format(pbi.name, pbi.blockchain_rid));
    } else {
        require(blockchain.state == blockchain_state.PAUSED, "Can't import blockchain in a state other than " + blockchain_state.PAUSED);
        log("Existing blockchain imported: %s / %s".format(pbi.name, pbi.blockchain_rid));
    }
    for ((height, config_hash) in pending_blockchain_configuration_hash @* { proposal } ((.height, .config_hash))) {
        create blockchain_configuration_hash(blockchain, height, config_hash);
    }
}

function delete_pending_blockchain_import(proposal) {
    delete pending_blockchain_import @? { proposal };
    delete pending_blockchain_configuration_hash @* { proposal };
}

query get_blockchain_import_proposal(rowid?):
    (name: text, blockchain_rid: byte_array, configurations: list<(integer, byte_array)>, container: text)?
{
    val proposal = get_latest_proposal(rowid, proposal_type.blockchain_import);
    if (proposal == null) return null;
    return pending_blockchain_import @ { proposal } (
        name = .name,
        blockchain_rid = .blockchain_rid,
        configurations = pending_blockchain_configuration_hash @* { proposal } ((.height, .config_hash)),
        container = .container.name
    );
}
