entity pending_start_blockchain_import {
    key proposal;
    blockchain: blockchain;
}

@extend(apply_voting_result_handlers) function() = [proposal_type.start_blockchain_import.name: apply_start_blockchain_import(*)];
@extend(delete_proposal_handlers) function(): map<text, (proposal) -> unit> = [proposal_type.start_blockchain_import.name: delete_pending_start_blockchain_import(*)];

operation propose_start_import_blockchain(my_pubkey: pubkey, blockchain_rid: byte_array,
                                          description: text = "Propose start import blockchain") {
    val me = require_is_provider_with_rate_limit(my_pubkey);
    val blockchain = require_blockchain(blockchain_rid);
    val container = container_blockchain @ { blockchain }.container;
    require_container_deployer(container, me);
    require(pcu_enabled(), "Precise Configuration Update must be enabled");
    require(blockchain.state == blockchain_state.PAUSED, "Blockchain must be paused to start import");

    if (empty(pending_start_blockchain_import @* { blockchain, .proposal.state == proposal_state.PENDING } limit 1)) {
        val prop = create proposal(op_context.last_block_time, proposal_type.start_blockchain_import, me, container.deployer, description);
        create pending_start_blockchain_import(prop, blockchain);
        internal_vote(me, prop, true);
    }
}

function apply_start_blockchain_import(proposal) {
    val psbi = pending_start_blockchain_import @? { proposal };
    if (psbi == null) return;

    val container = container_blockchain @ { psbi.blockchain }.container;
    val nodes = cluster_node @* { container.cluster } (@sort .node.pubkey);
    require(nodes.size() > 0, "Cluster must have at least one node");
    require(pcu_enabled(), "Precise Configuration Update must be enabled");
    require(psbi.blockchain.state == blockchain_state.PAUSED, "Blockchain must be paused to start import");

    psbi.blockchain.state = blockchain_state.IMPORTING;

    log("Blockchain import started: %s".format(psbi.blockchain.rid));
}

function delete_pending_start_blockchain_import(proposal) {
    delete pending_start_blockchain_import @? { proposal };
}

query get_start_blockchain_import_proposal(rowid?):
    (blockchain_rid: byte_array)?
{
    val proposal = get_latest_proposal(rowid, proposal_type.blockchain_import);
    if (proposal == null) return null;
    return pending_start_blockchain_import @ { proposal } (
        blockchain_rid = .blockchain.rid
    );
}
