enum blockchain_action {
    pause,
    resume,
    remove,
    archive
}

entity pending_blockchain_action {
    key proposal;
    key blockchain;
    action: blockchain_action;
}

@extend(apply_voting_result_handlers) function() = [proposal_type.blockchain_action.name: apply_blockchain_action(*)];

function apply_blockchain_action(proposal) {
    val pba = pending_blockchain_action @? { proposal };
    if (pba == null) return;
    when (pba.action) {
        pause -> _apply_pause_blockchain(pba, proposal);
        resume -> _apply_resume_blockchain(pba, proposal);
        remove -> _apply_delete_blockchain(pba, proposal);
        archive -> _apply_archive_blockchain(pba, proposal);
    }
}

@extend(delete_proposal_handlers) function(): map<text, (proposal) -> unit> = [proposal_type.blockchain_action.name: delete_pending_blockchain_action(*)];

function delete_pending_blockchain_action(proposal) {
    delete pending_blockchain_action @? { proposal };
}

// Stop block production by inactivating bc, and keep replicas.
function _apply_pause_blockchain(action: pending_blockchain_action, proposal) {
    action.blockchain.state = blockchain_state.PAUSED;
    // Keep replicas
    for (signer in get_blockchain_signer_nodes(action.blockchain)) {
        create blockchain_replica_node(action.blockchain, signer);
    }
}

// Restart block production; block builders will be the ones in cluster_node.
function _apply_resume_blockchain(action: pending_blockchain_action, proposal) {
    action.blockchain.state = blockchain_state.RUNNING;
    // Removing replicas if they are cluster nodes
    val nodes = get_blockchain_signer_nodes(action.blockchain);
    for (node_info in nodes) {
        delete blockchain_replica_node @? { action.blockchain, node_info };
    }
}

// Delete everything about this bc except D1 information
function _apply_delete_blockchain(action: pending_blockchain_action, proposal) {
    val bc = action.blockchain;
    before_delete_blockchain(bc);
    bc.state = blockchain_state.REMOVED;
    delete container_blockchain @ { bc };
    delete blockchain_replica_node @* { bc };
    delete pending_blockchain_action @ { proposal };
    delete blockchain_dependency @* { .me == bc };
    delete inactive_blockchain @? { bc };
    create inactive_blockchain(bc, op_context.block_height);
}

function _apply_archive_blockchain(action: pending_blockchain_action, proposal) {
    action.blockchain.state = blockchain_state.ARCHIVED;
    delete blockchain_replica_node @* { action.blockchain };
    create inactive_blockchain(action.blockchain, op_context.block_height);
}

operation propose_blockchain_action(my_pubkey: pubkey, blockchain_rid: byte_array, action: blockchain_action, description: text = "") {
    val me = require_is_provider_with_rate_limit(my_pubkey);

    // blockchain state requirements
    val blockchain = require_blockchain(blockchain_rid, include_removed = true);
    val pending_proposal = pending_blockchain_action @? { blockchain, .proposal.state == proposal_state.PENDING };
    require(empty(pending_proposal), "Blockchain action already proposed: " + pending_proposal?.proposal);

    when (blockchain.state) {
        blockchain_state.RUNNING -> {
            require(action != blockchain_action.resume, "Blockchain is already running: " + blockchain.rid);
        }
        blockchain_state.PAUSED -> {
            require(action != blockchain_action.pause, "Blockchain is already paused: " + blockchain.rid);
        }
        blockchain_state.REMOVED -> {
            require(false, "Removed blockchain can't be %sd: %s".format(action.name, blockchain.rid));
        }
        blockchain_state.IMPORTING -> {
            require(false, "Importing blockchain can't be %sd: %s".format(action.name, blockchain.rid));
        }
        blockchain_state.ARCHIVED -> {
            require(action != blockchain_action.pause, "Archived blockchain can't be paused: " + blockchain.rid);
            require(action != blockchain_action.resume, "Archived blockchain can't be resumed: " + blockchain.rid);
            require(action != blockchain_action.archive, "Blockchain is already archived: " + blockchain.rid);
        }
    }

    // Moving complex state
    if (exists(pending_blockchain_move @? { blockchain }) or exists(blockchain_move_state @? { blockchain })) {
        require(false, "Moving blockchain can't be %sd: %s".format(action.name, blockchain.rid));
    }

    // action requirements
    if (action == blockchain_action.remove) {
        require(empty(blockchain_dependency @* { .dependent_on == blockchain }), "Blockchain can't be removed since other blockchains depend on it: " + blockchain.rid);
    }

    // container requirements
    val container = container_blockchain @ {blockchain} .container;
    require_container_deployer(container, me);

    val prop = create proposal(op_context.last_block_time, proposal_type.blockchain_action, me, container.deployer, description);
    create pending_blockchain_action(prop, blockchain, action);
    internal_vote(me, prop, true);
}

query get_blockchain_action_proposal(rowid) {
    val proposal = get_latest_proposal(rowid, proposal_type.blockchain_action);
    if (proposal == null) return null;
    val pba = pending_blockchain_action @ { proposal };
    return (
        blockchain = pba.blockchain.rid,
        blockchain_name = pba.blockchain.name,
        action = pba.action
    );
}