enum blockchain_action {
    pause,
    resume,
    remove
}

entity pending_blockchain_action {
    key proposal;
    key blockchain;
    action: blockchain_action;
}

@extend(apply_voting_result_handlers) function() = [proposal_type.blockchain_action.name: apply_blockchain_action(*)];

function apply_blockchain_action(proposal) {
    val pba = pending_blockchain_action @? { proposal };
    if (pba == null) return;
    when (pba.action) {
        pause -> _apply_pause_blockchain(pba, proposal);
        resume -> _apply_resume_blockchain(pba, proposal);
        remove -> _apply_delete_blockchain(pba, proposal);
    }
}

@extend(delete_proposal_handlers) function(): map<text, (proposal) -> unit> = [proposal_type.blockchain_action.name: delete_pending_blockchain_action(*)];

function delete_pending_blockchain_action(proposal) {
    delete pending_blockchain_action @? { proposal };
}

// Stop block production by inactivating bc, and keep replicas.
function _apply_pause_blockchain(action: pending_blockchain_action, proposal) {
    update blockchain @ { action.blockchain.rid } (.state = blockchain_state.PAUSED);
    // Keep replicas
    for (signer in get_blockchain_signer_nodes(action.blockchain)) {
        create blockchain_replica_node(action.blockchain, signer);
    }
}

// Restart block production; block builders will be the ones in cluster_node.
function _apply_resume_blockchain(action: pending_blockchain_action, proposal) {
    update blockchain @ { action.blockchain.rid } (.state = blockchain_state.RUNNING);
    // Removing replicas if they are cluster nodes
    val nodes = get_blockchain_signer_nodes(action.blockchain);
    for (node_info in nodes) {
        delete blockchain_replica_node @? { action.blockchain, node_info };
    }
}

// Delete everything about this bc except D1 information
function _apply_delete_blockchain(action: pending_blockchain_action, proposal) {
    val bc = action.blockchain;
    before_delete_blockchain(bc);
    bc.state = blockchain_state.REMOVED;
    delete container_blockchain @ { bc };
    delete blockchain_replica_node @* { bc };
    delete pending_blockchain_action @ { proposal };
    delete blockchain_dependency @* { .me == bc };
}

operation propose_blockchain_action(my_pubkey: pubkey, blockchain_rid: byte_array, action: blockchain_action, description: text = "") {
    val me = require_is_provider_with_rate_limit(my_pubkey);
    val blockchain = require_blockchain(blockchain_rid);
    val container = container_blockchain @ {blockchain} .container;
    require_container_deployer(container, me);
    if (action == blockchain_action.remove) require_no_dependencies_on_me(blockchain);
    val prop = create proposal(op_context.last_block_time, proposal_type.blockchain_action, me, container.deployer, description);
    create pending_blockchain_action(prop, blockchain, action);
    internal_vote(me, prop, true);
}

query get_blockchain_action_proposal(rowid) {
    val proposal = get_latest_proposal(rowid, proposal_type.blockchain_action);
    if (proposal == null) return null;
    val pba = pending_blockchain_action @ { proposal };
    return (
        blockchain = pba.blockchain.rid,
        blockchain_name = pba.blockchain.name,
        action = pba.action
    );
}