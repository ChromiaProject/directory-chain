// Proposed bc:s are put here while waiting for enough positive votes.
entity pending_blockchain {
    key proposal;
    name;
    data: byte_array;
    container;
}

@extend(is_container_available_for_removal) function(container) = 
        if (exists(pending_blockchain @* { container }))
            "Container %s has pending proposals and can't be deleted. Resolve proposals first".format(container.name)
        else null;

@extend(apply_voting_result_handlers) function() = [proposal_type.bc.name: apply_blockchain_proposal(*)];

// Initial signers of new bc are the ones in cluster_node table.
function apply_blockchain_proposal(proposal) {
    val bc = pending_blockchain @? {proposal};
    if (bc == null) return;
    val nodes = cluster_node @* { bc.container.cluster } (@sort .node.pubkey);
    // do not write new configuration when size is 0 since it's impossible to recover from that
    require(nodes.size() > 0, "Cluster must have at least one node");
    require_container_is_not_full(bc.container);

    val blockchain_rid = add_blockchain(bc.data, nodes.to_gtv().to_bytes(), bc.name, bc.container);
    log("Added blockchain", blockchain_rid);
}

@extend(delete_proposal_handlers) function(): map<text, (proposal) -> unit> = [proposal_type.bc.name: delete_pending_blockchain(*)];

function delete_pending_blockchain(proposal) {
    delete pending_blockchain @? { proposal };
}

/*
 * Proposes a new blockchain to a container.
 * NB: only the deployer voter set of the container can do this.
 */
//Who can propose a new blockchain? The container deployer voter set
operation propose_blockchain(my_pubkey: pubkey, config_data: byte_array, bc_name: text, container_name: text, description: text = "") {
    val me = require_is_provider_with_rate_limit(my_pubkey);
    val container = require_container(container_name);
    require_container_deployer(container, me);
    require(not container.system, "Proposing blockchain to a system container is not allowed");

    validate_blockchain_configuration(config_data, signers = true, header_hash = pcu_enabled());

    // Require container resource limits are honored
    require_container_is_not_full(container);

    require(empty(pending_blockchain @* { .data == config_data, .proposal.state == proposal_state.PENDING } limit 1), "Already proposed");
    val prop = create proposal(op_context.last_block_time, proposal_type.bc, me, container.deployer, description);
    create pending_blockchain(prop, bc_name, config_data, container);
    internal_vote(me, prop, true);
}

query get_blockchain_proposal(rowid): (data:byte_array, container:text)? {
    return pending_blockchain @? { require_proposal(rowid) } ( data = .data, container = .container.name );
}