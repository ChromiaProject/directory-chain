@test module;

import ^^.*;
import common.operations.*;
import common.test.ops.*;
import common.test.setup.*;
import common.test.util.*;
import proposal.voting.test.ops.*;
import proposal_blockchain.*;
import proposal_blockchain.test.utils.*;
import proposal_container.*;
import proposal_provider.*;
import direct_container.*;
import direct_cluster.*;

function test_blockchain_moving_between_containers_within_one_node_is_not_allowed() {
    // setup
    setup_module(provider_quota_max_containers = 2);
    val ip = provider @ { initial_provider.pub };
    var conf = ["config_consensus_strategy": "HEADER_HASH".to_gtv()];

    rell.test.tx().op(
        // s1 / c1
        create_cluster(initial_provider.pub, "s1", voter_sets.system_p, [initial_provider.pub]),
        create_container(initial_provider.pub, "c1a", "s1", 0, [initial_provider.pub]),
        create_container(initial_provider.pub, "c1b", "s1", 0, [initial_provider.pub]),
        update_node_with_units(initial_provider.pub, test_node.pubkey, cluster_units = 3),
        add_node_to_cluster(initial_provider.pub, test_node.pubkey, "s1"),
        // proposing blockchain to the c1a
        propose_blockchain(initial_provider.pub, conf.to_gtv().to_bytes(), "foo_chain", "c1a")
    ).sign(initial_provider).run();
    val foo_chain = blockchain @ { "foo_chain" };

    // asserting that bc moving from c1a to c1b is not allowed
    rell.test.tx().op(
        propose_blockchain_move(initial_provider.pub, foo_chain.rid, "c1b")
    ).sign(initial_provider).run_must_fail(
        "Moving blockchains between containers running on the same node is not allowed. Nodes belongs to clusters s1 and s1 are: [%s]"
        .format(test_node.pubkey)
    );
}

function test_blockchain_moving_between_containers_running_on_different_nodes() {
    // setup
    setup_module(provider_quota_max_containers = 3);
    val ip = provider @ { initial_provider.pub };
    val node0 = node @ { test_node.pubkey };
    var conf = ["config_consensus_strategy": "HEADER_HASH".to_gtv()];

    rell.test.tx().op(
        // s1 / c1
        create_cluster(initial_provider.pub, "s1", voter_sets.system_p, [initial_provider.pub]),
        create_container(initial_provider.pub, "c1", "s1", 0, [initial_provider.pub]),
        update_node_with_units(initial_provider.pub, node0.pubkey, cluster_units = 2),
        add_node_to_cluster(initial_provider.pub, node0.pubkey, "s1"),
        // s2 / c2, c3
        create_cluster(initial_provider.pub, "s2", voter_sets.system_p, [initial_provider.pub]),
        create_container(initial_provider.pub, "c2", "s2", 0, [initial_provider.pub]),
        create_container_with_resource_limits(initial_provider.pub, "c3", "s2", 0, [initial_provider.pub], [container_resource_limit_type.container_units : 1, container_resource_limit_type.max_blockchains : 1]),
        // proposing the blockchain to the c1
        propose_blockchain(initial_provider.pub, conf.to_gtv().to_bytes(), "foo_chain", "c1")
    ).sign(initial_provider).run();
    val foo_chain = blockchain @ { "foo_chain" };

    rell.test.tx().op(
        create_test_node(ip, rell.test.pubkeys.trudy, cluster @ { "s2" }),
        // proposing the blockchain to the c3 to make it full
        propose_blockchain(initial_provider.pub, conf.to_gtv().to_bytes(), "foo_chain", "c3")
    ).sign(initial_provider).run();
    val node1 = node @ { rell.test.pubkeys.trudy };

    // 1. start blockchain moving
    // Trying to move the blockchain to a full container c3 -- must fail
    rell.test.tx().op(
        propose_blockchain_move(initial_provider.pub, foo_chain.rid, "c3")
    ).sign(initial_provider).run_must_fail("Can't add blockchain, container c3 is full");

    // Moving to a proper container c2
    rell.test.tx().op(
        propose_blockchain_move(initial_provider.pub, foo_chain.rid, "c2")
    ).sign(initial_provider).run();
    val bc_move_state = blockchain_move_state @? { foo_chain, .destination.name == "c2", .finish_at_height == -1, .remove_on_nodes == x"" };
    assert_not_null(bc_move_state);
    // asserting that s2/c2 nodes are blockchain replicas
    assert_equals(blockchain_replica_node @* { foo_chain } ( .node ), [node1]);
    // asserting that blockchain still belongs to c1
    assert_equals(container_blockchain @ { foo_chain } ( .container.name ), "c1");

    // Trying to move blockchain that is already being moved -- must fail
    rell.test.tx().op(
        propose_blockchain_move(initial_provider.pub, foo_chain.rid, "c1") // c2 -> c1
    ).sign(initial_provider).run_must_fail("Blockchain 0x5c2e022c482853fdf9db276dd37e6235a7d81a679362a2446f468c83387cfef6 is being moved");

    // 2. finish blockchain moving
    rell.test.tx().op(
        propose_blockchain_move_finish(initial_provider.pub, foo_chain.rid, 123)
    ).sign(initial_provider).run();
    // asserting that src nodes are blockchain replicas and dst nodes are not
    assert_equals(blockchain_replica_node @* { foo_chain } ( .node ), [node0]);
    // asserting that blockchain belongs to c2
    assert_equals(container_blockchain @ { foo_chain } ( .container.name ), "c2");
    // asserting that a new signers config is present at the proposed height
    val bcs = blockchain_configuration_signers @? { foo_chain, 123 };
    assert_not_null(bcs);
    assert_equals(bcs.signers, [node1.pubkey].to_gtv().to_bytes());
    // asserting that bc_move_state has relevant .finish_at_height and .remove_on_nodes
    assert_equals(bc_move_state.finish_at_height, 123);
    assert_equals(bc_move_state.remove_on_nodes, [node0.pubkey].to_gtv().to_bytes());

    // Further code flow (i.e. ICMF messaging) and results currently can't be tested due to limitations of Rell Test Framework
}

function test_removed_blockchain_moving_is_not_allowed() {
    // setup
    setup_module(provider_quota_max_containers = 2);
    var conf = ["config_consensus_strategy": "HEADER_HASH".to_gtv()];

    rell.test.tx().op(
        create_container(initial_provider.pub, "c1", containers.system, 0, [initial_provider.pub]),
        create_container(initial_provider.pub, "c2", containers.system, 0, [initial_provider.pub]),
        propose_blockchain(initial_provider.pub, conf.to_gtv().to_bytes(), "foo_chain", "c1")
    ).sign(initial_provider).run();
    val foo_chain = blockchain @ { "foo_chain" };

    rell.test.tx().op(
        propose_blockchain_action(initial_provider.pub, foo_chain.rid, blockchain_action.remove)
    ).sign(initial_provider).run();
    log(foo_chain.to_struct());

    // asserting that moving of removed blockchain is not allowed
    rell.test.tx().op(
        propose_blockchain_move(initial_provider.pub, foo_chain.rid, "c2")
    ).sign(initial_provider).run_must_fail("Only blockchains in RUNNING | PAUSED states can be moved; current state of blockchain 0x5c2e022c482853fdf9db276dd37e6235a7d81a679362a2446f468c83387cfef6 is: REMOVED");
}

function test_blockchain_moving_is_not_allowed_due_to_pending_blockchain_action_proposal() {
    // setup
    setup_module();
    // adding system provider bob
    rell.test.tx().op(
        register_provider(initial_provider.pub, rell.test.pubkeys.bob, provider_tier.NODE_PROVIDER),
        propose_provider_is_system(initial_provider.pub, rell.test.pubkeys.bob, true)
    ).sign(initial_provider).run();
    // propose blockchain
    var conf = ["config_consensus_strategy": "HEADER_HASH".to_gtv()];
    rell.test.tx().op(
        create_container(initial_provider.pub, "c1", clusters.system, 0, [initial_provider.pub, rell.test.pubkeys.bob]),
        propose_blockchain(initial_provider.pub, conf.to_gtv().to_bytes(), "foo_chain", "c1")
    ).sign(initial_provider).run();
    bob_votes();
    val foo_chain = blockchain @ { "foo_chain" };

    // proposing blockchain action
    rell.test.tx().op(
        propose_blockchain_action(initial_provider.pub, foo_chain.rid, blockchain_action.pause)
    ).sign(initial_provider).run();
    // asserting that there is a pending proposal for the blockchain
    val pba = pending_blockchain_action @? { foo_chain };
    assert_not_null(pba);
    assert_equals(pba.proposal.state, proposal_state.PENDING);

    // asserting that blockchain_moving is not allowed due to the pending blockchain action proposal
    rell.test.tx().op(
        propose_blockchain_move(initial_provider.pub, foo_chain.rid, "c2")
    ).sign(initial_provider).run_must_fail(
        "Blockchain %s cannot be moved due to a pending proposal %s related to it"
        .format(foo_chain.rid, pba.proposal)
    );
}
