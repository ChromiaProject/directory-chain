module;

val iccf_op_name = "iccf_proof";
val num_intra_network_iccf_op_args = 6;

/**
 * Requires the presented transaction to be proved and extracts an argument from the specified operation
 * 
 * @param gtx_transaction The transaction to verify
 * @param op_name Name of the operation to extract
 * @param require_intra_network_iccf_op Whether or not this transaction was done within the same cluster or not
 * @param verify_signers Whether or not the signers must match current transaction signatures
 */
function extract_operation_arg(
    gtx_transaction,
    op_name: text,
    arg: integer,
    require_intra_network_iccf_op: boolean = false,
    verify_signers: boolean = true
): gtv {
    val args = extract_operation_args(gtx_transaction, op_name, require_intra_network_iccf_op, verify_signers);
    require(
        args.size() >= arg,
        "Argument number %d not found on operation %s. %d arguments found"
            .format(arg, op_name, args.size())
    );
    return args[arg];
}

/**
 * Requires the presented transaction to be proved and extracts arguments of the specified operation
 * 
 * @param gtx_transaction The transaction to verify
 * @param op_name Name of the operation to extract
 * @param require_intra_network_iccf_op Whether or not this transaction was done within the same cluster or not
 * @param verify_signers Whether or not the signers must match current transaction signatures
 */
function extract_operation_args(
    gtx_transaction,
    op_name: text,
    require_intra_network_iccf_op: boolean = false,
    verify_signers: boolean = true
): list<gtv> {
    return require_operation(gtx_transaction, op_name, require_intra_network_iccf_op, verify_signers).args;
}

/**
 * Requires the presented transaction to be proved and extracts the specified operation
 * 
 * @param gtx_transaction The transaction to verify
 * @param op_name Name of the operation to extract
 * @param require_intra_network_iccf_op Whether or not this transaction was done within the same cluster or not
 * @param verify_signers Whether or not the signers must match current transaction signatures
 */
function require_operation(
    gtx_transaction,
    op_name: text,
    require_intra_network_iccf_op: boolean = false,
    verify_signers: boolean = true
): gtx_operation {
    require_valid_proof(gtx_transaction, require_intra_network_iccf_op, verify_signers);
    return require(
        gtx_transaction.body.operations @? { .name == op_name },
        "Operation with name %s not found in transaction %s".format(op_name, gtx_transaction)
    );
}

/**
 * Requires the presented transaction to be proved
 * 
 * @param gtx_transaction The transaction to verify
 * @param require_intra_network_iccf_op Whether or not this transaction was done within the same cluster or not
 * @param verify_signers Whether or not the signers must match current transaction signatures
 */
function require_valid_proof(
    gtx_transaction,
    require_intra_network_iccf_op: boolean = false,
    verify_signers: boolean = true
) {
    val tx_hash = gtx_transaction.to_gtv().hash();
    require(_has_proof(gtx_transaction, require_intra_network_iccf_op), "No proof operation present for TX");
    if (verify_signers) {
        require(
            _has_signers(gtx_transaction),
            "Proof TX has to be signed by all the signers that signed the source TX"
        );
    }
    return gtx_transaction.body.operations;
}

/**
 * Checks whether or not the current transaction is signed by the same signers as the given transaction
 * 
 * @param gtx_transaction The transaction to verify signers against
 */
function _has_signers(gtx_transaction): boolean {
    val proof_signers = gtx_transaction.body.signers @* { } ( byte_array.from_gtv($) );
    val signers = op_context.get_signers();
    return signers.contains_all(proof_signers);
}

/**
 * Checks whether the current transaction contains a `iccf_proof` operation corresponding to the givven transaction.
 * 
 * @param gtx_transaction The transaction to check
 * @param require_intra_network_iccf_op Whether or not this transaction was done within the same cluster or not
 */
function _has_proof(
    gtx_transaction,
    require_intra_network_iccf_op: boolean = false
): boolean {
    val blockchain_rid = gtx_transaction.body.blockchain_rid;
    val tx_hash = gtx_transaction.to_gtv().hash();
    val proof_operation = op_context.get_all_operations() @? {
        .name == iccf_op_name,
        byte_array.from_gtv(.args[0]) == blockchain_rid,
        byte_array.from_gtv(.args[1]) == tx_hash,
        not require_intra_network_iccf_op or .args.size() == num_intra_network_iccf_op_args
    };
    return exists(proof_operation);
}

/**
 * Prevents this transaction to be proved multiple times by storing the hash
 * 
 * @param gtx_transaction The transaction to make unique
 */
function make_transaction_unique(gtx_transaction) {
    require(
        not(exists(
            iccf_verified_transaction @? {
                .hash == gtx_transaction.hash()
            }
        )),
        "Transaction has already been processed"
    );
    create iccf_verified_transaction ( gtx_transaction.hash() );
}

@log
entity iccf_verified_transaction {
    key hash: byte_array;
}
