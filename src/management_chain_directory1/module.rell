module;

import common.*;
import common.init.*;
import common.operations.*;
import common.queries.*;
import direct_cluster.*;
import direct_container.*;
import legacy_anchoring.integrated.*;
import nm_api.*;
import proposal.*;
import proposal_blockchain.*;
import proposal_blockchain_import.*;
import proposal_cluster.*;
import proposal_cluster_anchoring.*;
import proposal_container.proposal_container_limits.*;
import proposal_provider.*;
import proposal_voter_set.*;
import version;

/*
 * Directory1 is an enterprise dapp where the d1 dapp manages and controls creating and deleting clusters, containers and blockchains.
 * To run this dapp postchain must be started in managed mode and preferably using master/subnode configuration.
 */
operation update_provider(my_pubkey: pubkey, name?, url: text?) {
    val me = require_provider(my_pubkey);
    require_provider_auth_with_rate_limit(me);
    if (exists(name)) me.name = name;
    if (exists(url)) me.url = url;
}

operation __begin_block(height: integer) {
    before_begin_block(height);

    if (empty(blockchain @? { chain_context.blockchain_rid })) return;
    val expected_config = get_blockchain_configuration(chain_context.blockchain_rid, height);
    if (expected_config == null or expected_config.config_hash == chain_context.raw_config.hash()) return;

    log("Chain0 config for height %d changed from %s to %s and will be stored".format(
        height, expected_config.config_hash, chain_context.raw_config.hash()));
    val config_map = map<text, gtv>.from_gtv(chain_context.raw_config);
    config_map.remove_or_null("signers");
    val base_config = config_map.to_gtv().to_bytes();
    create blockchain_configuration(blockchain @ { chain_context.blockchain_rid }, height, base_config);
    add_dependencies(base_config, chain_context.blockchain_rid, height);
}

@extendable function before_begin_block(height: integer) {}
