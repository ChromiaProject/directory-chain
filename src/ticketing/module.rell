module;

import model.*;
import common.*;
import cluster_class.*;

val ticket_chain_name = "ticket_chain";

object ticket_chain {
    mutable rid: byte_array = x"";
}

operation init_ticketing(my_pubkey: pubkey, ticket_chain_config: byte_array) {
    require_is_provider_with_rate_limit(my_pubkey);
    require_is_system_provider(my_pubkey);

    require(ticket_chain.rid == x"", "Ticket chain is already started");

    val nodes = cluster_node @* { system_cluster() } (@sort .node.pubkey);
    // do not write new configuration when size is 0 since it's impossible to recover from that
    require(nodes.size() > 0, "System cluster must have at least one node");

    val ticket_chain_config_map = map<text,gtv>.from_gtv(gtv.from_bytes(ticket_chain_config));
    ticket_chain_config_map["icmf"] = [
        "receiver": [
            "local": [
                [
                    "bc-rid": chain_context.blockchain_rid.to_gtv(),
                    "topic": "L_ticket_result".to_gtv()
                ].to_gtv()
            ].to_gtv()
        ].to_gtv()
    ].to_gtv();

    log("Adding ticket chain to system container");
    val ticket_blockchain = add_blockchain(ticket_chain_config_map.to_gtv().to_bytes(), nodes, ticket_chain_name, system_container(), true);
    update ticket_chain(rid = ticket_blockchain.rid);
}

function create_provider_from_ticket(pubkey, name?, url: text?) {
    require_pubkey(pubkey);
    require(not(exists(provider @? { pubkey })), "Provider with pubkey %s already exists".format(pubkey));
    register_and_enable_provider(provider_info(pubkey, name = name ?: "", url = url ?: ""), provider_tier.COMMUNITY_NODE_PROVIDER, null, null, true);
}

function create_provider_if_not_exist(pubkey): provider {
    var provider = provider @? { pubkey };
    if (provider == null) {
        register_and_enable_provider(
            provider_info(pubkey),
            provider_tier.COMMUNITY_NODE_PROVIDER,
            null,
            null,
            enabled_by_default = true
        );
        provider = provider @ { pubkey };
    }
    return provider;
}

function create_container_from_ticket(pubkey, container_units: integer, cluster_class: text): text {
    val provider = require_provider(pubkey);

    val clusters = cluster @* { cluster.name != clusters.system, .operational };
    for (cluster in clusters) {
        val available_container_units = get_available_container_units(cluster);
        if (is_cluster_in_class(cluster, cluster_class) and available_container_units >= container_units) {
            val container = create_container_in_cluster(provider, cluster);
            return container.name;
        }
    }
    return "";
}

function create_container_in_cluster(provider, cluster): container {
    val name = [cluster.to_gtv(), provider.pubkey.to_gtv(), op_context.transaction.tx_rid.to_gtv()].hash().to_hex();
    return create_container_impl(provider, name, cluster, 1, [provider.pubkey], standard_container_defaults.container_units, standard_container_defaults.max_blockchains);
}

function stop_container(container_name: text) {
    val container = container @ { .name == container_name };
    container.state = container_state.STOPPED;
}

function restart_container(container_name: text) {
    val container = container @ { .name == container_name };
    container.state = container_state.RUNNING;
}
