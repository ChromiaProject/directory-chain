module;

import model.*;
import common.*;
import cluster_class.*;

val ticket_chain_name = "ticket_chain";

object ticket_chain {
    mutable rid: byte_array = x"";
}

operation init_ticketing(my_pubkey: pubkey, ticket_chain_config: byte_array) {
    require_is_provider_with_rate_limit(my_pubkey);
    require_is_system_provider(my_pubkey);

    require(ticket_chain.rid == x"", "Ticket chain is already started");

    val nodes = cluster_node @* { system_cluster() } (@sort .node.pubkey);
    // do not write new configuration when size is 0 since it's impossible to recover from that
    require(nodes.size() > 0, "System cluster must have at least one node");

    log("Adding ticket chain to system container");
    val ticket_blockchain = add_blockchain(ticket_chain_config, nodes, ticket_chain_name, system_container(), true);
    update ticket_chain(rid = ticket_blockchain.rid);
}

query get_ticket_chain_rid(): byte_array? = if (ticket_chain.rid == x"") null else ticket_chain.rid;

function create_provider_if_not_exist(pubkey): provider {
    var provider = provider @? { pubkey };
    if (provider == null) {
        register_and_enable_provider(
            provider_info(pubkey),
            provider_tier.COMMUNITY_NODE_PROVIDER,
            null,
            null,
            enabled_by_default = true
        );
        provider = provider @ { pubkey };
    }
    return provider;
}

function create_container_from_ticket(provider_pubkey: pubkey, container_units: integer, cluster_class: text,
        extra_storage: integer, cluster_name: text?): text {
    require_pubkey(provider_pubkey);
    val provider = create_provider_if_not_exist(provider_pubkey);

    val clusters = cluster @* { cluster.name != clusters.system, .operational };
    for (cluster in clusters) {
        val available_container_units = get_available_container_units(cluster);
        val available_extra_storage = get_available_extra_storage(cluster);
        if (is_cluster_in_class(cluster, cluster_class)
            and available_container_units >= container_units
            and available_extra_storage >= extra_storage
            and (cluster_name == null or cluster_name == cluster.name)
        ) {
            val container = create_container_in_cluster(provider, cluster, container_units, extra_storage);
            return container.name;
        }
    }
    return "";
}

function upgrade_container_from_ticket(container_name: text, container_units: integer, cluster_class: text, extra_storage: integer, cluster_name: text) {
    val container = container @ { .name == container_name };
    val current_cluster = container.cluster;
    if (current_cluster.name == cluster_name) {
        require(is_cluster_in_class(current_cluster, cluster_class), "Requested cluster for upgraded container does not match cluster class");
        upgrade_container(container, container_units, extra_storage, standard_container_defaults.max_blockchains);
    } else {
        // TODO: Move chains
        require(false, "Moving to new cluster is not supported");
        val destination_cluster = cluster @ { .name == cluster_name };
        require(is_cluster_in_class(destination_cluster, cluster_class), "Requested cluster for upgraded container does not match cluster class");
    }
}

function create_container_in_cluster(provider, cluster, container_units: integer, extra_storage: integer): container {
    val name = [cluster.to_gtv(), provider.pubkey.to_gtv(), op_context.transaction.tx_rid.to_gtv()].hash().to_hex();
    return create_container_impl(
        provider, name, cluster, 1, [provider.pubkey],
        container_units,
        standard_container_defaults.max_blockchains,
        extra_storage
    );
}

function stop_container(container_name: text) {
    val container = container @ { .name == container_name };
    container.state = container_state.STOPPED;
}

function restart_container(container_name: text) {
    val container = container @ { .name == container_name };
    container.state = container_state.RUNNING;
}
