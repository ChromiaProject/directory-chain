module;

import common.*;

struct legacy_anchored_block {
    height: integer;
    block_rid: byte_array;
}

// Deprecated
operation anchor_block(header: base_block_header, signers: list<pubkey>, signatures: list<byte_array>) {
    val blockchain = blockchain @ { header.blockchain_rid };
    val existing_ab = anchored_block @? { blockchain, header.height };
    if (exists(existing_ab)) {
        log("Block %d of blockchain %s is already anchored".format(header.height, header.blockchain_rid));
        return;
    }

    val all_signers = set<pubkey>.from_gtv(
        get_signers_for_configuration(blockchain, header.height)
    );

    val block_rid = header.hash();

    for (i in range(0, signers.size())) {
        require(all_signers.contains(signers[i]),
            "Can't anchor block %d of blockchain %s, unknown signer %s detected"
                .format(header.height, header.blockchain_rid, signers[i])
        );
        require(verify_signature(block_rid, signers[i], signatures[i]),
            "Can't anchor block %d of blockchain %s, invalid signature of signer %s detected: %s"
                .format(header.height, header.blockchain_rid, signers[i], signatures[i])
        );
    }

    val block = create anchored_block ( blockchain, header.height, block_rid );
    for (signer in signers) {
        create anchored_block_signer(block, node @ { signer });
    }
}

query get_last_legacy_anchored_block(blockchain_rid: byte_array): legacy_anchored_block? {
    val blockchain = blockchain @ { blockchain_rid };
    return anchored_block @? { blockchain } (@omit @sort_desc .height, legacy_anchored_block(.height, .block_rid)) limit 1;
}

@extend (before_delete_blockchain) function remove_anchored_blocks(blockchain) {
    val blocks = anchored_block @* { blockchain };
    for (block in blocks) {
        delete anchored_block_signer @* { block };
    }
    delete blocks;
}
