module;

import ^.common.*;
import ^.region.*;

// "7:EU:ETHEREUM_BRIDGE,BCS_BRIDGE"
// "::", "" - no requirements
function is_cluster_in_class(cluster, cluster_class: text): boolean {
    if (cluster_class.empty()) return true;
    val requirements = cluster_class.split(":");

    val number_of_nodes = requirements[0];
    if (not number_of_nodes.empty() and number_of_nodes_in_cluster(cluster) != integer(number_of_nodes)) return false;

    val required_region = requirements[1];
    if (not required_region.empty()) {
        val region = region @? { .name == required_region };
        if (region == null or not is_cluster_in_region(cluster, region)) return false;
    }

    val node_capabilities = requirements[2];
    if (not node_capabilities.empty()) {
        for (capability in node_capabilities.split(",")) {
            val node_capability_type = parse_node_capability_type(capability);
            if (node_capability_type == null or not cluster_has_capability(cluster, node_capability_type)) return false;
        }
    }

    return true;
}
