// Creates a cluster with a set of providers
operation create_cluster(my_pubkey: pubkey, name, governor_voter_set: text, provider_pubkeys: list<pubkey>) {
    create_cluster_with_units_impl(my_pubkey, name, governor_voter_set, provider_pubkeys, standard_cluster_defaults.cluster_units);
}

operation create_cluster_with_units(my_pubkey: pubkey, name, governor_voter_set: text, provider_pubkeys: list<pubkey>, cluster_units: integer) {
    create_cluster_with_units_impl(my_pubkey, name, governor_voter_set, provider_pubkeys, cluster_units);
}

function create_cluster_with_units_impl(my_pubkey: pubkey, name, governor_voter_set: text, provider_pubkeys: list<pubkey>, cluster_units: integer) {
    val me = require_is_provider_with_rate_limit(my_pubkey);
    require_system_access(me);
    val governor = require_voter_set(governor_voter_set);
    create_cluster_impl(me, name, governor, provider_pubkeys, cluster_units);
}

// Creates a cluster provided by the members of an existing voter set
operation create_cluster_from(my_pubkey: pubkey, name, governor_voter_set: text, provider_voter_set: text) {
    create_cluster_from_with_units_impl(my_pubkey, name, governor_voter_set, provider_voter_set, standard_cluster_defaults.cluster_units);
}

operation create_cluster_from_with_units(my_pubkey: pubkey, name, governor_voter_set: text, provider_voter_set: text, cluster_units: integer) {
    create_cluster_from_with_units_impl(my_pubkey, name, governor_voter_set, provider_voter_set, cluster_units);
}

function create_cluster_from_with_units_impl(my_pubkey: pubkey, name, governor_voter_set: text, provider_voter_set: text, cluster_units: integer) {
    val me = require_is_provider_with_rate_limit(my_pubkey);
    require_system_access(me);
    val governor = require_voter_set(governor_voter_set);
    val node_provider_set = require_voter_set(provider_voter_set);
    create_cluster_impl(me, name, governor, voter_set_member @* { node_provider_set }.provider.pubkey, cluster_units);
}

operation request_cluster(my_pubkey: pubkey, name, size: integer, require_full: boolean) {
    request_cluster_with_units_impl(my_pubkey, name, size, require_full, standard_cluster_defaults.cluster_units);
}

operation request_cluster_with_units(my_pubkey: pubkey, name, size: integer, require_full: boolean, cluster_units: integer) {
    request_cluster_with_units_impl(my_pubkey, name, size, require_full, cluster_units);
}

function request_cluster_with_units_impl(my_pubkey: pubkey, name, size: integer, require_full: boolean, cluster_units: integer) {
    require(size >= 4, "At least 4 nodes should be requested to be able to reach bft majority");
    val me = require_is_provider_with_rate_limit(my_pubkey);
    require_system_access(me);

    val possible_nodes = (node, node_capabilities) @* { 
        node_capabilities.node == node,
        node_capabilities.type == node_capability_type.SYSTEM_MANAGED,
        not(.pubkey in cluster_node @* {} (.node.pubkey)) 
        }.node;
    val available_nodes: list<node> = list<node>();
    for (pnode in possible_nodes) {
        if (get_available_cluster_units_for_node(pnode) >= cluster_units) available_nodes.add(pnode);
    }
    val unique_providers = set<provider>();
    unique_providers.add_all(available_nodes @* {}.provider);
    val chosen_providers = unique_providers @* {} limit size;
    require(chosen_providers.size() >= 4, "Clusters can only be created when at least four nodes are available");
    require(chosen_providers.size() == size or not(require_full), "Not enough providers have available nodes, found %d, requested %d".format(chosen_providers.size(), size));

    log("Creating cluster " + name + " with providers " + chosen_providers @*{}.pubkey);
    val cluster = create_cluster_impl(me, name, system_voter_set(), chosen_providers @* {}.pubkey, cluster_units);
    for (p in chosen_providers) {
        val node = available_nodes @ { .provider == p } limit 1;
        add_node_to_cluster_internal(p, node, cluster);
    }
}