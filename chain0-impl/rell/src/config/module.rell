module;

import ^.model.*;
import ^.common.util.*;
import ^.common.cluster.*;
import ^.chain0_icmf_receiver.*;
import ^.config_common.*;

entity pending_blockchain_configuration {
    key blockchain, minimum_height: integer;
    index base_config_hash: byte_array;
    base_config: byte_array;
}

@extend(receive_icmf_message) function receive_configuration_updated(sender: byte_array, topic: text, body: gtv) {
    if (topic != configuration_updated_topic) return;

    val message = configuration_updated.from_gtv(body);

    val bc = require_blockchain(message.blockchain_rid);
    val cluster = get_cluster_for_blockchain(message.blockchain_rid);
    val anchor_chain = cluster_anchoring_chain @ { cluster } (.blockchain);
    require(sender == anchor_chain.rid,
        "Received updated configuration from chain %s, which is not anchor chain for cluster %s".format(sender, cluster.name));

    log("Received updated configuration for chain %s at height %d to %s"
        .format(message.blockchain_rid, message.height, message.base_config_hash));

    val pending_configuration = require(
        pending_blockchain_configuration @? { bc, .base_config_hash == message.base_config_hash, .minimum_height <= message.height }
            (@omit @sort .minimum_height, $) limit 1,
        "Configuration with hash %s not found for chain %s".format(message.base_config_hash, message.blockchain_rid)
    );

    val pending_base_config = pending_configuration.base_config;
    require(empty(blockchain_configuration @? { bc, message.height }),
        "Configuration at height %d already exists for chain %s".format(message.height, message.blockchain_rid));

    delete pending_configuration;
    create blockchain_configuration(bc, message.height, pending_base_config);
    add_dependencies(pending_base_config, bc.rid, message.height);
}
