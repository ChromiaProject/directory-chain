import ^^.proposal.*;
import ^^.model.util.constants.*;
import ^^.config.*;

// NB: check authority before calling this function
function internal_vote(provider, proposal, vote: boolean) {
    require(voter_set_member @? { proposal.voter_set, provider }, provider.pubkey + " must be a member of the voter set");
    create vote(proposal, provider, vote);
    log("vote added with value:", if (vote) "Yes" else "False");
    try_to_apply_proposal(proposal);
}

function try_to_apply_proposal(prop: proposal) {
    val prop_str = proposal_str(prop);
    val results = get_proposal_voting_results(prop.rowid);
    when (results.voting_result) {
        pending -> log("proposal is still under discussion:", prop_str);
        rejected -> {
            log("proposal rejected:", prop_str);
            delete_proposal(prop);
        }
        approved -> {
            log("proposal approved:", prop_str);
            apply_voting_result_handlers()[prop.proposal_type.name](prop);
            delete_proposal(prop);
        }
    }
}

@extendable function apply_other_voting_result(proposal) { /* Should be extended */ }

// TODO: Move implemetation to modules
@extendable function apply_voting_result_handlers(): map<text, (proposal) -> unit> = [
    proposal_type.container_limits.name: apply_container_limits(*),
    proposal_type.cluster_limits.name: apply_cluster_limits(*),
    proposal_type.cluster_provider.name: apply_cluster_provider(*),
    proposal_type.cluster_remove.name: apply_remove_cluster(*),
    proposal_type.other.name: apply_other_voting_result(*)
];

function apply_container_limits(proposal) {
    val pps = pending_container_limits @ { proposal };
    update container_resource_limit @ {pps.container, container_resource_limit_type.max_blockchains} (pps.max_blockchains);
    update container_resource_limit @ {pps.container, container_resource_limit_type.cpu} (pps.cpu);
    update container_resource_limit @ {pps.container, container_resource_limit_type.ram} (pps.ram);
    update container_resource_limit @ {pps.container, container_resource_limit_type.storage} (pps.storage);
    update container_resource_limit @ {pps.container, container_resource_limit_type.io_read} (pps.io_read);
    update container_resource_limit @ {pps.container, container_resource_limit_type.io_write} (pps.io_write);
}

function apply_cluster_limits(proposal) {
    val pps = pending_cluster_limits @ { proposal };
    update cluster_resource_limit @ {pps.cluster, cluster_resource_limit_type.max_containers} (pps.max_containers);
    update cluster_resource_limit @ {pps.cluster, cluster_resource_limit_type.default_container_max_blockchains} (pps.default_container_max_blockchains);
    update cluster_resource_limit @ {pps.cluster, cluster_resource_limit_type.default_container_cpu} (pps.default_container_cpu);
    update cluster_resource_limit @ {pps.cluster, cluster_resource_limit_type.default_container_ram} (pps.default_container_ram);
    update cluster_resource_limit @ {pps.cluster, cluster_resource_limit_type.default_container_storage} (pps.default_container_storage);
    update cluster_resource_limit @ {pps.cluster, cluster_resource_limit_type.default_container_io_read} (pps.default_container_io_read);
    update cluster_resource_limit @ {pps.cluster, cluster_resource_limit_type.default_container_io_write} (pps.default_container_io_write);
}

function apply_remove_cluster(proposal) {
    val cl = pending_remove_cluster @ { proposal } .cluster;
    delete pending_remove_cluster @ { proposal };
    remove_cluster_impl(cl);
}

function apply_cluster_provider(proposal) {
    val pps = pending_cluster_provider @ {proposal};
    if (pps.add) {
        create cluster_provider(pps.cluster, pps.provider);
    } else {
        delete cluster_provider @ {pps.cluster, pps.provider};
    }
}

function proposal_str(prop: proposal) {
    return "%s:%d".format(prop.proposal_type, prop.rowid);
}

@extendable function before_delete_blockchain(blockchain) {}
