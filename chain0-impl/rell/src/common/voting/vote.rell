
enum proposal_status {
    pending,
    approved,
    rejected
}

struct voting_results {
    positive_votes: integer;
    negative_votes: integer;
    max_votes: integer;
    threshold: integer;
    proposal_status;
}

function positive_votes(proposal) = vote @? { proposal, .vote == true } (@sum 1) ?: 0;
function negative_votes(proposal) = vote @? { proposal, .vote == false } (@sum 1) ?: 0;
function max_votes(voter_set) = voter_set_member @ { voter_set } (@sum 1);

function _compute_proposal_status(yes: integer, no: integer, max: integer, threshold: integer): proposal_status {
    require (threshold >= -1 and threshold <= max, "Invalid threshold, must be in range [%d, %d] but was: %d".format(-1, max, threshold));
    require (yes + no <= max, "Too many votes");
    when (threshold) {
        -1 -> return _compute_proposal_status_majority(yes, no, max);
        0 -> return _compute_proposal_status_super_majority(yes, no, max);
        else -> return _compute_proposal_status_custom(yes, no, max, threshold);
    }
}

function _compute_proposal_status_custom(yes: integer, no: integer, max: integer, threshold: integer): proposal_status {
    return _proposal_status(yes, no, max, threshold);
}

function _compute_proposal_status_majority(yes: integer, no: integer, max: integer): proposal_status {
    val required = max / 2 + 1;
    return _proposal_status(yes, no, max, required);
}

function _compute_proposal_status_super_majority(yes: integer, no: integer, max: integer): proposal_status {
    val required = max - (max - 1) / 3;
    return _proposal_status(yes, no, max, required);
}

function _proposal_status(yes: integer, no: integer, max: integer, required: integer): proposal_status {
    print("Votes - positive: %d, negative: %d, required: %d, maximum: %d".format(yes, no, required, max));
    return when {
        yes >= required -> proposal_status.approved;
        no > max - required -> proposal_status.rejected;
        else -> proposal_status.pending;
    };
}
