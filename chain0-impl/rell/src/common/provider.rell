
/*
    The provider with type in line can (+) / can not (-) register a provider with the type in the column:

         | CNP | NP
    -----|-----|-----
     CNP |  +  |  -
     NP  |  +  |  -
     SP  |  +  |  +
*/
operation register_provider(my_pubkey: pubkey, pubkey, provider_tier) {
    val me = require_provider(my_pubkey);
    require_provider_auth_with_rl(me);
    require(empty(provider @* { pubkey }), "Provider already exists: " + pubkey);

    register_and_enable_provider(
        pubkey,
        provider_tier,
        cluster = null,
        voter_set = null,
        enabled_by_default = _is_node_provider(me.tier) and not(_is_node_provider(provider_tier))
    );
    if (_is_node_provider(provider_tier)) {
        require(roles.has_system_access(me), "Must be system provider to add a node provider");
        enroll.node(provider @ { pubkey });
    }
}

function _is_node_provider(tier: provider_tier) = tier == provider_tier.NODE_PROVIDER;

@extendable function register_and_enable_provider(pubkey, provider_tier, cluster?, voter_set?, enabled_by_default: boolean = false) {
	val provider = create provider(
		pubkey,
		name = "",
        active = enabled_by_default,
        tier = provider_tier
    );
    create provider_rl_state(provider, points = 100, last_update=op_context.last_block_time);
    if (exists(cluster)) {
        create cluster_provider(cluster, provider);
    }
    if (exists(voter_set)) {
    	create voter_set_member(voter_set, provider);
    }
}

operation promote_node_provider(my_pubkey: pubkey, provider_pubkey: pubkey) { // TODO: Should be able to demote
    val me = require_is_provider_with_rl(my_pubkey);
    require_is_system_provider(my_pubkey);
    val p = require_provider(provider_pubkey);
    require(p.tier != provider_tier.NODE_PROVIDER, "Provider already has this role");
    enroll.node(p);
}

// Recover provider's action points and consume one, if possible
function provider_rate_limit(provider) {
	val max_actions_per_day = provider_quota @ {
			.tier == provider.tier,
			provider_quota_type.max_actions_per_day
	} .value;

	// We recover max_actions_per_day in 24 hours, find time needed to recover 1 point
	val recovery_time = (86400 * 1000) / max_actions_per_day;
    val state = provider_rl_state @ { provider } (.points, .last_update);
    val time_delta = op_context.last_block_time - state.last_update;
    var got_points = 0;
    var update_time = state.last_update;

    if (time_delta > recovery_time)
    {
        got_points = time_delta / recovery_time;
        // advance  update_time to a multiple of recovery_time to avoid wasting time
        update_time = state.last_update + got_points * recovery_time;
        if (got_points + state.points > max_actions_per_day) {
            got_points = max_actions_per_day - state.points;
            // if user is at the maximum reset his timer
            update_time = op_context.last_block_time;
        }
    }

    require(state.points + got_points > 0); // make sure we have at least one point, which will be spent

    update provider_rl_state @ { provider } (
        .points += got_points - 1,
        .last_update = update_time
    );
}

operation transfer_action_points(from: pubkey, to: pubkey, amount: integer) {
	val _from = require_is_provider_with_rl(from);
	val _to = require_provider(to);
	require(provider_rl_state @ { _from } .points >= amount, "Not enough action points to transfer from.");
	update provider_rl_state @ { _from } ( .points -= amount );
	update provider_rl_state @ { _to } ( .points += amount );
}

function require_provider_quota(provider, quota_type: provider_quota_type) {
    val quota = provider_quota @ { provider.tier, quota_type } (.value);
    if (quota > 0) {
        when (quota_type) {
            max_nodes -> _require_provider_quota(quota, quota_type, node @ { provider } (@sum 1));
        }
    }
}

function _require_provider_quota(quota: integer, quota_type: provider_quota_type, count: integer) {
    require(count < quota , "Provider quota exceeded: %s = %d".format(quota_type, quota));
}
