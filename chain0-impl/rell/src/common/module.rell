module;

import ^.model.*;
import ^.cm_api.*;
import ^.nm_api.*;
import ^.cluster_anchoring;
import .cluster.*;
import .voting.*;
import .proposal.*;
import .queries.*;
import .util.*;
import ^.cluster.*;

// Adds the initial provider as a system provider along with voter sets and clusters needed to start
function initialize_module(
    initial_provider: pubkey,
    genesis_node: node_info,
    system_anchoring_config: byte_array,
    cluster_anchoring_config: byte_array,
    majority_threshold: integer = 0,
    provider_quota_max_actions_per_day: integer = provider_quota_defaults.MAX_ACTIONS_PER_DAY,
    provider_quota_max_containers: integer = provider_quota_defaults.MAX_CONTAINERS
) {
    require(empty( provider @* {}));
    log("--------------------Initializing-Chain-0-----------------------");
    log("Creating provider quotas");
    _setup_provider_quotas(provider_quota_max_actions_per_day, provider_quota_max_containers);

    log("Creating SYSTEM voter set");
    create_voter_set_internal(voter_sets.system, 1);
    /**
     * System provider create a ‘system’ cluster which will include ‘system’ nodes and has a ‘system’ container
     * which will run the directory bc.
     */
    log("Creating SYSTEM_P voter set");
    val system_voter_set = create_voter_set_internal(voter_sets.system_p, majority_threshold);

    log("Creating initial provider with pubkey: " + initial_provider);
    register_and_enable_provider(
        provider_info(initial_provider),
        provider_tier.NODE_PROVIDER,
        cluster = null,
        voter_set = null,
        enabled_by_default = true
    );
    val provider = provider @ { initial_provider };

    log("Creating system cluster with SYSTEM_P as governor");
    cluster_anchoring.set_config(cluster_anchoring_config);
    val system_cluster = create_cluster_impl(
        provider,
        clusters.system,
        governor = system_voter_set,
        providers = list<pubkey>()
       );

    enroll.system(provider);

    val system_container = container @ { .cluster == system_cluster, .system };

    log("Adding c0 blockchain to system container");
    val c0_config = map<text,gtv>.from_gtv(chain_context.raw_config);
    val c0_signers_gtv = c0_config["signers"];
    add_blockchain(chain_context.raw_config.to_bytes(), c0_signers_gtv.to_bytes(), blockchains.c0, system_container, true);

    val system_anchoring_config_map = map<text,gtv>.from_gtv(gtv.from_bytes(system_anchoring_config));
    if (system_anchoring_config_map.size() > 0) {
        log("Adding system anchoring blockchain to system container");
        val system_anchoring_blockchain_rid = add_blockchain(system_anchoring_config, c0_signers_gtv.to_bytes(), blockchains.system_anchoring, system_container, true);
        update system_anchoring_chain ( rid = system_anchoring_blockchain_rid );
    }

    val signer_node_keys = list<byte_array>.from_gtv(c0_signers_gtv);
    require(signer_node_keys.size() == 1, "C0 must have exactly one initial signer");
    val initial_signer_node_key = signer_node_keys[0];
    require(initial_signer_node_key == genesis_node.pubkey, "Blockchain signer must match genesis node configuration");

    log("Adding initial signer node of c0 to system cluster: " + initial_signer_node_key);
    val initial_node = create node(
        provider,
        initial_signer_node_key,
        host = genesis_node.host,
        port = genesis_node.port,
        api_url = genesis_node.api_url,
        last_updated = op_context.last_block_time
    );
    create cluster_node(system_cluster, initial_node);
    node_list.last_update = op_context.last_block_time;
    check_operational(system_cluster);
    log("---------------------------------------------------------------");
}

function _setup_provider_quotas(actions_per_day: integer, max_containers: integer) {
    // max_actions_per_day
    create provider_quota(tier = provider_tier.COMMUNITY_NODE_PROVIDER, provider_quota_type.max_actions_per_day, value = actions_per_day);
    create provider_quota(tier = provider_tier.NODE_PROVIDER, provider_quota_type.max_actions_per_day, value = actions_per_day);
    // max_nodes
    create provider_quota(tier = provider_tier.COMMUNITY_NODE_PROVIDER, provider_quota_type.max_nodes, value = provider_quota_defaults.MAX_NODES);
    create provider_quota(tier = provider_tier.NODE_PROVIDER, provider_quota_type.max_nodes, value = -1);
    // max_containers
    create provider_quota(tier = provider_tier.NODE_PROVIDER, provider_quota_type.max_containers, value = max_containers);
}
