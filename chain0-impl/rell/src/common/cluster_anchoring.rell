
function set_cluster_anchoring_config(config: byte_array) {
    map<text, gtv>.from_gtv(gtv.from_bytes(config)); // Validate that config is a map
    cluster_anchoring_config.raw_config = config;
}

@extend(after_cluster_creation) function create_cluster_anchoring_chain(provider, cluster) {
    val config_map = map<text,gtv>.from_gtv(gtv.from_bytes(cluster_anchoring_config.raw_config));
    // feature toggle
    if (config_map.size() > 0) {
        require(empty(cluster_anchoring_chain @? { cluster }), "Anchoring chain already exists for cluster " + cluster.name);

        config_map["cluster"] = cluster.name.to_gtv();
        val unique_config = config_map.to_gtv_pretty();
        val blockchain_rid = unique_config.hash();
        val blockchain = create blockchain(blockchain_rid, blockchains.cluster_anchoring_prefix + cluster.name, system = true, active = false);
        create blockchain_configuration(blockchain, 0, unique_config.to_bytes());

        val system_container = container @ { .name == system_container_name(cluster.name), cluster };

        create blockchain_added(blockchain, op_context.transaction);
        create container_blockchain(system_container, blockchain);
        create cluster_anchoring_chain(blockchain, cluster);

        if (cluster.name != clusters.system) {
            // Add replication of this chain to all system nodes
            val system_cluster_nodes = cluster_node @* { .cluster.name == clusters.system  } ( .node );
            for (node in system_cluster_nodes) {
                create blockchain_replica_node(blockchain, node);
            }
        }
    }
}

@extend(after_cluster_operational) function activate_cluster_anchoring_chain(cluster) {
    val anchoring_chain = cluster_anchoring_chain @? { cluster } (.blockchain);

    if (anchoring_chain != null and not anchoring_chain.active) {
        val cluster_signers = cluster_node @* { cluster } (@sort .node.pubkey).to_gtv().to_bytes();
        val current_anchoring_signers = blockchain_configuration_signers @? { anchoring_chain, 0 };
        if (current_anchoring_signers == null) {
            create blockchain_configuration_signers(anchoring_chain, 0, cluster_signers);
        } else {
            current_anchoring_signers.signers = cluster_signers;
        }

        anchoring_chain.active = true;
    }
}

@extend(before_system_container_removal) function remove_cluster_anchoring_chain(cluster) {
    val config_map = map<text,gtv>.from_gtv(gtv.from_bytes(cluster_anchoring_config.raw_config));
    // feature toggle
    if (config_map.size() > 0) {
        val anchor = cluster_anchoring_chain @ { cluster } (.blockchain);
        delete blockchain_configuration @* { anchor };
        delete blockchain_configuration_signers @* { anchor };
        delete blockchain_added @* { anchor };

        delete container_blockchain @* { anchor };

        delete cluster_anchoring_chain @ { anchor };
        delete blockchain_replica_node @* { anchor };
        delete blockchain @ { anchor.rid };
    }
}

@extend(after_node_added_to_cluster) function replicate_cluster_anchor_chain_on_system_node(cluster, node) {
    if (cluster.name == clusters.system) {
        val cluster_anchoring_chains = cluster_anchoring_chain @* { .cluster.name != clusters.system } ( .blockchain );
        for (blockchain in cluster_anchoring_chains) {
            if (not(exists(blockchain_replica_node @? { blockchain, node }))) {
                create blockchain_replica_node(blockchain, node);
            }
        }
    }
}
