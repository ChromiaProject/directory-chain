import ^.model.util.*;

function add_blockchain(raw_configuration: byte_array, signers: byte_array, name: text, container, system: boolean = false): byte_array {
    val blockchain_rid = map<text, gtv>.from_gtv(gtv.from_bytes(raw_configuration)).hash();
    val blockchain = create blockchain(blockchain_rid, name, system);
    create blockchain_configuration(blockchain, 0, raw_configuration);
    create blockchain_configuration_signers(blockchain, 0, signers);
    create blockchain_added(blockchain, op_context.transaction);
    create container_blockchain(container, blockchain);
    add_dependencies(raw_configuration, blockchain_rid, 0);
    return blockchain_rid;
}

function add_dependencies(data: byte_array, me_brid: byte_array, height: integer) {
    val config_map = map<text, gtv>.from_gtv(gtv.from_bytes(data));
    if (config_map.contains("dependencies")) {
        val deps = list<(text, byte_array)>.from_gtv(config_map["dependencies"]);   // Returns e.g.  [brid0, brid22, ..]
        for ((_, dep) in deps) {
            val dependent_on = blockchain @? { dep };
            if (exists(dependent_on)) {
                require(me_brid != dep);
                create blockchain_dependency(
                    me = blockchain @ {me_brid},
                    dependent_on,
                    height = height);
            }
        }
    }
}

function require_no_dependencies_on_me(blockchain) {
    require (empty(blockchain_dependency @* { .dependent_on == blockchain}));
}

function get_last_height(blockchain): integer {
    if (blockchain.rid == chain_context.blockchain_rid) {
        return op_context.block_height;
    } else {
        return (anchored_block @? { blockchain } (@sort_desc .height) limit 1) ?: -1;
    }
}

@extendable function before_delete_blockchain(blockchain) {}