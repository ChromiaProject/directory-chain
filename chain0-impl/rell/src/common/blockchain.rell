import ^.model.util.*;

function add_blockchain(raw_configuration: byte_array, signers: byte_array, name: text, container, system: boolean = false): byte_array {
    val blockchain_rid = map<text, gtv>.from_gtv(gtv.from_bytes(raw_configuration)).hash();
    val blockchain = create blockchain(blockchain_rid, name, system);
    create blockchain_configuration(blockchain, 0, raw_configuration);
    create blockchain_configuration_signers(blockchain, 0, signers);
    create blockchain_added(blockchain, op_context.transaction);
    create container_blockchain(container, blockchain);
    add_dependencies(raw_configuration, blockchain_rid, 0);
    return blockchain_rid;
}

function add_dependencies(data: byte_array, me_brid: byte_array, height: integer) {
    val config_map = map<text, gtv>.from_gtv(gtv.from_bytes(data));
    if (config_map.contains("dependencies")) {
        val deps = list<(text, byte_array)>.from_gtv(config_map["dependencies"]);   // Returns e.g.  [brid0, brid22, ..]
        for ((_, dep) in deps) {
            val dependent_on = blockchain @? { dep };
            if (exists(dependent_on)) {
                require(me_brid != dep);
                create blockchain_dependency(
                    me = blockchain @ {me_brid},
                    dependent_on,
                    height = height);
            }
        }
    }
}

function require_no_dependencies_on_me(blockchain) {
    require (empty(blockchain_dependency @* { .dependent_on == blockchain}));
}

function get_last_height(blockchain): integer {
    if (blockchain.rid == chain_context.blockchain_rid) {
        return op_context.block_height;
    } else {
        return (anchored_block @? { blockchain } (@sort_desc .height) limit 1) ?: -1;
    }
}

operation add_blockchain_replica(my_pubkey: pubkey, blockchain_rid: byte_array, node_pubkey: byte_array) {
    val provider = require_provider(my_pubkey);
    require_provider_auth_with_rl(provider);
    val node = require_node(node_pubkey);
    val blockchain = require_blockchain(blockchain_rid);
    require(empty(blockchain_replica_node @? { blockchain, node }), "Node is already a replica of blockchain %s".format(node.pubkey, blockchain.rid));
    require(node.provider == provider, "It is only allowed to add own node as a blockchain replica");
    create blockchain_replica_node(blockchain, node);
}

operation remove_blockchain_replica(my_pubkey: pubkey, blockchain_rid: byte_array, node_pubkey: byte_array) {
    val provider = require_provider(my_pubkey);
    require_provider_auth_with_rl(provider);
    val blockchain = require_blockchain(blockchain_rid);
    val node = require_node(node_pubkey);
    require(node.provider == provider, "It is only allowed to remove own blockchain replica node; provider:%s, node: %s".format(provider.pubkey, node.pubkey));
    delete blockchain_replica_node @? { blockchain, node };
}
