import ^.model.util.*;

function add_blockchain(raw_configuration: byte_array, signers: byte_array, name: text, container, system: boolean = false): byte_array {
    val blockchain_rid = map<text, gtv>.from_gtv(gtv.from_bytes(raw_configuration)).hash();
    val blockchain = create blockchain(blockchain_rid, name, system);
    create blockchain_configuration(blockchain, 0, raw_configuration);
    create blockchain_configuration_signers(blockchain, 0, signers);
    create blockchain_added(blockchain, op_context.transaction);
    create container_blockchain(container, blockchain);
    add_dependencies(raw_configuration, blockchain_rid, 0);
    return blockchain_rid;
}

function add_dependencies(data: byte_array, me_brid: byte_array, height: integer) {
    val config_map = map<text, gtv>.from_gtv(gtv.from_bytes(data));
    if (config_map.contains("dependencies")) {
        val deps = list<(text, byte_array)>.from_gtv(config_map["dependencies"]);   // Returns e.g.  [brid0, brid22, ..]
        for ((_, dep) in deps) {
            val dependent_on = blockchain @? { dep };
            if (exists(dependent_on)) {
                require(me_brid != dep);
                create blockchain_dependency(
                    me = blockchain @ {me_brid},
                    dependent_on,
                    height = height);
            }
        }
    }
}

function require_no_dependencies_on_me(blockchain) {
    require (empty(blockchain_dependency @* { .dependent_on == blockchain}));
}

function get_last_height(blockchain): integer {
    if (blockchain.rid == chain_context.blockchain_rid) {
        return op_context.block_height;
    } else {
        return (anchored_block @? { blockchain } (@sort_desc .height) limit 1) ?: -1;
    }
}

function get_blockchain_signer_nodes(blockchain: blockchain?): list<(byte_array, text, integer, boolean, integer)> {
    if (exists(blockchain)) {
        return (cluster_node, container_blockchain) @* {
            container_blockchain.blockchain == blockchain,
            cluster_node.cluster == container_blockchain.container.cluster
        } (
            @sort .node.pubkey,
            .node.host,
            .node.port,
            .node.active,
            .node.last_updated
        );
    }
    return list();
}

// Cannot use function get_last_height, since it uses an op_context.
// Deprecated: relies on legacy anchoring which will be removed
function deprecated_get_blockchain_last_height(blockchain_rid: byte_array): integer {
    if (blockchain_rid == chain_context.blockchain_rid) {
        return (block @? {} (@sort_desc .block_height) limit 1) ?: -1;
    } else {
        return (anchored_block @? { blockchain @ { blockchain_rid } } (@sort_desc .height) limit 1) ?: -1;
    }
}

@extendable function before_delete_blockchain(blockchain) {}