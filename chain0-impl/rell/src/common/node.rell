function add_node_internal(provider, node_pubkey: pubkey, host: text, port: integer, api_url: text, clusters: list<text>): node {
    require(empty(provider @? { node_pubkey }), "This pubkey is already registered as a provider: " + node_pubkey);
    require(empty(node @? { node_pubkey }), "Node already exists: " + node_pubkey);
    require_provider_quota(provider, provider_quota_type.max_nodes);
    val node = create node(provider, node_pubkey, host, port = port, api_url = api_url, last_updated = op_context.last_block_time);
    for (cluster_name in clusters) {
        val cluster = require_cluster(cluster_name);
        if (roles.has_node_access(provider)) {
            add_node_to_cluster_internal(provider, node, cluster);
        } else { // provider_tier.COMMUNITY_NODE_PROVIDER
            _add_replica_node_to_cluster_internal(cluster, node);
        }
        node_list.last_update = op_context.last_block_time;
    }
    after_node_added(node);
    return node;
}

function require_node_provider(node_pubkey: pubkey, provider_pubkey: pubkey) {
    val provider = require(provider @? { provider_pubkey }, "Provider %s does not exist".format(provider_pubkey));
    require_provider_auth_with_rl(provider);
    val node = require_node(node_pubkey);
    require(node.provider == provider, "Must be provider of node to update its state");
    return node;
}

@extendable function after_node_added(node) {}
