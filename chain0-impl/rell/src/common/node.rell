
operation register_node(my_pubkey: pubkey, node_pubkey: pubkey, host: text, port: integer, api_url: text, clusters:list<text> = list<text>()) {
    log("------------- Register-Node: %s --------------".format(node_pubkey));
    val provider = require_provider(my_pubkey);
    require_provider_auth_with_rl(provider);
    require_pubkey(node_pubkey);
    add_node_internal(provider, node_pubkey, host, port, api_url, clusters);
    log("Added node information for node: " + node_pubkey);
    log("-----------------------------------");
}

operation replace_node(my_pubkey: pubkey, old_node_key: pubkey, new_node_key: pubkey, new_host: text?, new_port: integer?, new_api_url: text?) {
    log("------------- Replace-Node: %s --------------".format(old_node_key));
    val me = require_is_provider_with_rl(my_pubkey);
    require_is_signer(old_node_key);
    require_is_signer(new_node_key);
    val old_node = node @ { old_node_key };
    require(old_node.provider == me, "Node must be owned by provider");

    val host = new_host ?: old_node.host;
    val port = new_port ?: old_node.port;
    val api_url = new_api_url ?: old_node.api_url;

    val cluster_names = cluster_node @* { old_node }.cluster.name;
    delete cluster_node @* { old_node };
    val clusters_replicated_by_node = cluster_replica_node @* { old_node } (.cluster);
    delete cluster_replica_node @* { old_node };
    val blockchains_replicated_by_node = blockchain_replica_node @* { old_node } (.blockchain);
    delete blockchain_replica_node @* { old_node };

    delete old_node;
    add_node_internal(me, new_node_key, host, port, api_url, cluster_names);

    val new_node = node @ { new_node_key };
    for (cl in clusters_replicated_by_node) {
        _add_replica_node_to_cluster_internal(cl, new_node);
    }

    for (blockchain in blockchains_replicated_by_node) {
        if (not(exists(blockchain_replica_node @? { blockchain, new_node }))) {
            create blockchain_replica_node(blockchain, new_node);
        }
    }

    node_list.last_update = op_context.last_block_time;
    log("---------------------------------------");
}

operation enable_node(my_pubkey: pubkey, node_pubkey: pubkey) {
    log("------------- Enable-Node: %s --------------".format(node_pubkey));
    val provider = require_is_provider_with_rl(my_pubkey);
    val node = require_node(node_pubkey);
    require(node.provider == provider, "Node must be owned by provider: " + node_pubkey);
    require(not(node.active), "Node is already active: " + node_pubkey);
    node.active = true;
    log("-----------------------------------");
}

function add_node_internal(provider, node_pubkey: pubkey, host: text, port: integer, api_url: text, clusters: list<text>): node {
    require(empty(provider @? { node_pubkey }), "This pubkey is already registered as a provider: " + node_pubkey);
    require(empty(node @? { node_pubkey }), "Node already exists: " + node_pubkey);
    require_provider_quota(provider, provider_quota_type.max_nodes);
    val node = create node(provider, node_pubkey, host, port = port, api_url = api_url, last_updated = op_context.last_block_time);
    for (cluster_name in clusters) {
        val cluster = require_cluster(cluster_name);
        if (roles.has_node_access(provider)) {
            add_node_to_cluster_internal(provider, node, cluster);
        } else { // provider_tier.COMMUNITY_NODE_PROVIDER
            _add_replica_node_to_cluster_internal(cluster, node);
        }
        node_list.last_update = op_context.last_block_time;
    }
    after_node_added(node);
    return node;
}

operation disable_node(my_pubkey: pubkey, node_pubkey: pubkey) {
    val provider = require_provider(my_pubkey);
    require_provider_auth_with_rl(provider);
    val node_to_disable = require_node(node_pubkey);

    if (provider != node_to_disable.provider) {
        require(roles.has_system_access(provider), "Non system provider is only allowed to disable own nodes");
        require(
            node_to_disable.provider.tier == provider_tier.NODE_PROVIDER and not(node_to_disable.provider.system),
            "System provider is only allowed to disable nodes of non system provider");
    }

    node_to_disable.active = false;
    // cluster nodes
    val clusters = cluster_node @* { .node.pubkey == node_pubkey } .cluster;
    delete cluster_node @* { .node.pubkey == node_pubkey };
    for (cl in clusters) {
        // Disabling the last node of a cluster is not allowed:
        require(not(empty(cluster_node @* { cl })), "Cannot disable the last node of a cluster " + cl.name);
        update_configuration_signers(cl);
    }
    // cluster replica nodes
    delete cluster_replica_node @* { .node.pubkey == node_pubkey };
    // blockchain replica nodes
    delete blockchain_replica_node @* { .node.pubkey == node_pubkey };

    // updating node list timestamp
    node_list.last_update = op_context.last_block_time;
}

operation remove_node(my_pubkey: pubkey, node_pubkey: pubkey) {
    log("------------- Remove-Node: %s --------------".format(node_pubkey));
    val provider = require_provider(my_pubkey);
    require_provider_auth_with_rl(provider);
    val node_to_remove = require_node(node_pubkey);
    require(provider == node_to_remove.provider, "It is only allowed to remove own nodes: " + node_pubkey);
    require(not(node_to_remove.active), "Can't remove active nodes: " + node_pubkey);
    delete node_to_remove;
    log("---------------------------------------");
}

operation update_node(my_pubkey: pubkey, node_pubkey: pubkey, host: text? = null, port: integer? = null, api_url: text? = null) {
    val node = require_node_provider(node_pubkey, my_pubkey);
    if (host != null) node.host = host;
    if (port != null) node.port = port;
    if (api_url != null) node.api_url = api_url;
    if (host != null or port != null or api_url != null) node.last_updated = op_context.last_block_time;
    if (host != null or port != null) node_list.last_update = op_context.last_block_time;
}

function require_node_provider(node_pubkey: pubkey, provider_pubkey: pubkey) {
    val provider = require(provider @? { provider_pubkey }, "Provider %s does not exist".format(provider_pubkey));
    require_provider_auth_with_rl(provider);
    val node = require_node(node_pubkey);
    require(node.provider == provider, "Must be provider of node to update its state");
    return node;
}

@extendable function after_node_added(node) {}
