import ^.util.*;
import ^^.cluster.*;
import ^^.model.*;

val container_prefix = "anchoring_";

object anchoring_config {
    mutable raw_config: byte_array = map<text, gtv>().to_gtv().to_bytes();
}

function set_config(config: byte_array) {
    map<text, gtv>.from_gtv(gtv.from_bytes(config)); // Validate that config is a map
    anchoring_config.raw_config = config;
}

@extend(after_cluster_creation) function create_cluster_anchoring_chain(cluster) {
    val config_map = map<text,gtv>.from_gtv(gtv.from_bytes(anchoring_config.raw_config));
    // feature toggle
    if (config_map.size() > 0) {
        require(empty(anchoring_chain @? { cluster }), "Anchoring chain already exists for cluster " + cluster.name);

        config_map["cluster"] = cluster.name.to_gtv();
        val unique_config = config_map.to_gtv_pretty();
        val blockchain_rid = unique_config.hash();
        val blockchain = create blockchain(blockchain_rid, container_prefix + cluster.name, system = true);
        create blockchain_configuration(blockchain, 0, unique_config.to_bytes());

        val container = create_container_with_resource_limits(
            container_prefix + cluster.name,
            container_type.naked,
            cluster = cluster,
            voter_set = system_voter_set()
        );
        val signers = cluster_node @* { cluster }.node.pubkey;
        create blockchain_configuration_signers(blockchain, 0, signers.to_gtv().to_bytes());
        create blockchain_added(blockchain, op_context.transaction);
        create container_blockchain(container, blockchain);
        create anchoring_chain(blockchain, cluster);
    }
}

@extend(before_cluster_removal) function remove_cluster_anchoring_chain(cluster) {
    val config_map = map<text,gtv>.from_gtv(gtv.from_bytes(anchoring_config.raw_config));
    // feature toggle
    if (config_map.size() > 0) {
        val anchor = anchoring_chain @ { cluster } .blockchain;
        delete blockchain_configuration @* { anchor };
        delete blockchain_configuration_signers @* { anchor };
        delete blockchain_added @* { anchor };

        val cont = container @ { container_prefix + cluster.name };
        delete container_resource_limit @* { cont };
        delete container_blockchain @* { anchor };
        delete cont;

        delete anchoring_chain @ { anchor };
        delete blockchain @ { anchor.rid };
    }
}
