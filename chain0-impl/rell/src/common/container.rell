function create_system_container(me: provider, name, cluster, voter_set): container {
    val c = create container(name, cluster, voter_set, me, system = true);
    create container_resource_limit(c, container_resource_limit_type.max_blockchains, -1);
    create container_resource_limit(c, container_resource_limit_type.cpu, -1);
    create container_resource_limit(c, container_resource_limit_type.ram, -1);
    create container_resource_limit(c, container_resource_limit_type.storage, -1);
    create container_resource_limit(c, container_resource_limit_type.io_read, -1);
    create container_resource_limit(c, container_resource_limit_type.io_write, -1);
    return c;
}

function create_container_with_resource_limits(me: provider, name, cluster, voter_set, max_blockchains: integer = -1, cpu: integer = -1, ram: integer = -1, storage: integer = -1, io_read: integer = -1, io_write: integer = -1): container {
    val c = create container(name, cluster, voter_set, me);
    create container_resource_limit(c, container_resource_limit_type.max_blockchains, max_blockchains);
    create container_resource_limit(c, container_resource_limit_type.cpu, cpu);
    create container_resource_limit(c, container_resource_limit_type.ram, ram);
    create container_resource_limit(c, container_resource_limit_type.storage, storage);
    create container_resource_limit(c, container_resource_limit_type.io_read, io_read);
    create container_resource_limit(c, container_resource_limit_type.io_write, io_write);
    return c;
}

function remove_container_impl(container) {
    delete container_resource_limit @* { container };
    delete container;
}

@extendable function is_container_available_for_removal(container): text? {
    return when {
        container.system -> "System container can't be deleted";
        exists(container_blockchain @* { container }) -> "Container %s is not empty and can't be deleted. Delete blockchains first".format(container.name);
        else -> null;
    };
}

function require_container_available_for_removal(container) {
    val objections = is_container_available_for_removal(container);
    require(empty(objections), objections!!);
}

@extend(before_cluster_removal) function remove_system_container(cluster) {
    before_system_container_removal(cluster);
    remove_container_impl(container @ { cluster, .system == true });
}

@extendable function before_system_container_removal(cluster) {}

function create_container_impl(me: provider, name, cluster, consensus_threshold: integer, deployers: list<pubkey>) {
    require(consensus_threshold >= -1 and consensus_threshold <= deployers.size(), "Invalid threshold");

    val vs = create_voter_set_internal("container_" + name + "_deployer", consensus_threshold, cluster.governance);
    for (deployer_key in deployers) {
        val deployer = require_provider(deployer_key);
        create voter_set_member(vs, deployer);
    }

    val max_blockchains = _get_cluster_limit_or_default(cluster, cluster_resource_limit_type.default_container_max_blockchains);
    val cpu = _get_cluster_limit_or_default(cluster, cluster_resource_limit_type.default_container_cpu);
    val ram = _get_cluster_limit_or_default(cluster, cluster_resource_limit_type.default_container_ram);
    val storage = _get_cluster_limit_or_default(cluster, cluster_resource_limit_type.default_container_storage);
    create_container_with_resource_limits(me, name, cluster, vs, max_blockchains, cpu, ram, storage);
}

function remove_container_and_voter_set(container) {
    if (empty(is_container_available_for_removal(container))) {
        val vs = container.deployer;
        remove_container_impl(container);
        remove_voter_set_impl(vs);
    }
}

function _get_cluster_limit_or_default(cluster, type: cluster_resource_limit_type): integer {
    return cluster_resource_limit @? { cluster, .cluster_resource_limit_type == type } (.value) ?: -1;
}