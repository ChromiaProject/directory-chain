import ^.model.util.constants.*;

function create_container_with_resource_limits(me: provider, name, cluster, voter_set, max_blockchains: integer = -1, cpu: integer = -1, ram: integer = -1, storage: integer = -1): container {
    val c = create container(name, cluster, voter_set, me);
    create container_resource_limit(c, container_resource_limit_type.max_blockchains, max_blockchains);
    create container_resource_limit(c, container_resource_limit_type.cpu, cpu);
    create container_resource_limit(c, container_resource_limit_type.ram, ram);
    create container_resource_limit(c, container_resource_limit_type.storage, storage);
    return c;
}

function remove_container_impl(container) {
    delete container_resource_limit @* { container };
    delete container;
}

function is_container_available_for_removal(container): (boolean, text) {
    return when {
        container.name == containers.system -> (false, "System container can't be deleted");
        exists(container_blockchain @* { container }) -> (false, "Container %s is not empty and can't be deleted. Delete blockchains first".format(container.name));
        exists(pending_container_limits @* { container }) -> (false, "Container %s has pending proposals and can't be deleted. Resolve proposals first".format(container.name));
        exists(pending_blockchain @* { container }) -> (false, "Container %s has pending proposals and can't be deleted. Resolve proposals first".format(container.name));
        else -> (true, "");
    };
}

function require_container_available_for_removal(container) {
    val (available, msg) = is_container_available_for_removal(container);
    require(not(available), msg);
}
