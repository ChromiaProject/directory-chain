
operation propose_cluster_provider(my_pubkey: pubkey, cluster_name: text, provider_pubkey: pubkey, add: boolean) {
	val me = require_is_provider_with_rl(my_pubkey);
	val provider = require_provider(provider_pubkey);
	require_node_access(provider);
	// Check that provider authority and that it is a cluster governor
	val cluster = require_cluster(cluster_name);
	require(cluster.name != clusters.system, "Cannot add provider to system cluster manually");
	require_cluster_governor(cluster, me);
	val prop = create proposal(op_context.last_block_time, proposal_type.cluster_provider, me, cluster.governance);
	create pending_cluster_provider(prop, cluster, provider, add);
	internal_vote(me, prop, true);
}

/*
      | CNP | NP  | SP
 -----|-----|-----|-----
  CNP |  -  |  -  |  -
  NP  |  +  |  -  |  -
  SP  |  +  |  +  |  +
*/
operation propose_enable_provider(my_pubkey: pubkey, enable_pubkey: pubkey) {
	val me = require_provider(my_pubkey);
	val other_prov = require_provider(enable_pubkey);
	require_provider_auth_with_rl(me);

    // Only SP and NP can enable providers
	require_node_access(me);

    // NP can enable CNP without voting, otherwise
	if (roles.has_node_access(me) and other_prov.tier == provider_tier.COMMUNITY_NODE_PROVIDER) {
		update_provider_state(other_prov, true);		
	} else {
		require_system_access(me);
		if (empty(pending_provider_state @* { .provider == other_prov, .active == true } limit 1)) {
			val prop = create proposal(op_context.last_block_time, proposal_type.provider_state, me, system_p_voter_set());
			create pending_provider_state(prop, other_prov, .active = true);
			internal_vote(me, prop, true);
		}
	}
}

operation propose_disable_provider(my_pubkey: pubkey, disable_pubkey: pubkey) {
	val me = require_is_system_provider(my_pubkey);
	val other_prov = require_provider(disable_pubkey);
	require_provider_auth_with_rl(me);
	
	if (empty(pending_provider_state @* { .provider == other_prov, .active == false } limit 1)) {
		val prop = create proposal(op_context.last_block_time, proposal_type.provider_state, me, system_p_voter_set());
		create pending_provider_state(prop, other_prov, .active = false);
		internal_vote(me, prop, true);
	}
}

operation propose_provider_is_system(my_pubkey: pubkey, provider_pubkey: pubkey, promote: boolean) {
	val me = require_is_system_provider(my_pubkey);
	val other_prov = require_provider(provider_pubkey);
	require_provider_auth_with_rl(me);

	if (empty(pending_provider_is_system @* { .provider == other_prov, .system == promote } limit 1)) {
		val prop = create proposal(op_context.last_block_time, proposal_type.provider_is_system, me, system_p_voter_set());
		create pending_provider_is_system(prop, other_prov, .system = promote);
		internal_vote(me, prop, true);
	}
}