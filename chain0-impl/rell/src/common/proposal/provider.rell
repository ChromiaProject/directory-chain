
operation propose_cluster_provider(my_pubkey: pubkey, cluster_name: text, provider_pubkey: pubkey, add: boolean, description: text = "") {
    val me = require_is_provider_with_rl(my_pubkey);
    val provider = require_provider(provider_pubkey);
    require_node_access(provider);
    // Check that provider authority and that it is a cluster governor
    val cluster = require_cluster(cluster_name);
    require(cluster.name != clusters.system, "Cannot add provider to system cluster manually");
    require_cluster_governor(cluster, me);
    val prop = create proposal(op_context.last_block_time, proposal_type.cluster_provider, me, cluster.governance, description);
    create pending_cluster_provider(prop, cluster, provider, add);
    internal_vote(me, prop, true);
}

/*
    The provider with type in line can (+) / can not (-) change the state of the other one in the column:

         | CNP | NP  | SP
    -----|-----|-----|-----
     CNP |  -  |  -  |  -
     NP  |  +  |  -  |  -
     SP  |  +  |  +  |  +
*/
operation propose_provider_state(my_pubkey: pubkey, provider_pubkey: pubkey, active: boolean, description: text = "") {
    val me = require_provider(my_pubkey);
    val other_prov = require_provider(provider_pubkey);
    require_provider_auth_with_rl(me);

    // Only SP and NP can enable/disable providers
    require_node_access(me);

    if (roles.has_node_access(me) and other_prov.tier == provider_tier.COMMUNITY_NODE_PROVIDER) {
        update_provider_state(other_prov, active);
    } else {
        require_system_access(me);
        if (empty(pending_provider_state @* { .provider == other_prov, .active == active } limit 1)) {
            val prop = create proposal(op_context.last_block_time, proposal_type.provider_state, me, system_p_voter_set(), description);
            create pending_provider_state(prop, other_prov, .active = active);
            internal_vote(me, prop, true);
        }
    }
}

operation propose_remove_provider(my_pubkey: pubkey, provider_pubkey: pubkey, description: text = "") {
    val me = require_is_provider_with_rl(my_pubkey);
    require_system_access(me);

    // active (voter set member)
    val prov = require_provider(provider_pubkey);
    require(not(prov.active), "Active provider can't be deleted: " + provider_pubkey);

    // container
    val containers = container @* { prov } (.name);
    require(empty(containers), "Provider is the author of the container(s) %s and can't be deleted: %s".format(containers.to_text(), provider_pubkey));

    val prop = create proposal(op_context.last_block_time, proposal_type.provider_remove, me, system_p_voter_set(), description);
    create pending_remove_provider(prop, prov);
    internal_vote(me, prop, true);
}

operation propose_provider_is_system(my_pubkey: pubkey, provider_pubkey: pubkey, promote: boolean, description: text = "") {
    val me = require_is_provider_with_rl(my_pubkey);
    require_is_system_provider(my_pubkey);
    val other_prov = require_provider(provider_pubkey);

    if (empty(pending_provider_is_system @* { .provider == other_prov, .system == promote } limit 1)) {
        val prop = create proposal(op_context.last_block_time, proposal_type.provider_is_system, me, system_p_voter_set(), description);
        create pending_provider_is_system(prop, other_prov, .system = promote);
        internal_vote(me, prop, true);
    }
}

operation propose_provider_quota(my_pubkey: pubkey, tier: provider_tier, provider_quota_type, value: integer, description: text = "") {
    val me = require_is_provider_with_rl(my_pubkey);
    require_is_system_provider(my_pubkey);

    // quota value requirements
    when (provider_quota_type) {
        max_actions_per_day -> require(value > 0, "Proposed max_actions_per_day quota value must be > 0: " + value);
        max_nodes -> {
            require(value > 0, "Proposed max_nodes quota value must be > 0: " + value);
        }
        max_containers -> {
            require(value >= -1, "Proposed max_containers quota value must be >= -1: " + value);
            require(tier != provider_tier.COMMUNITY_NODE_PROVIDER, "Proposing max_containers quota is not allowed for COMMUNITY_NODE_PROVIDER");
        }
    }

    val prop = create proposal(op_context.last_block_time, proposal_type.provider_quota, me, system_p_voter_set(), description);
    create pending_provider_quota(prop, tier, provider_quota_type, value);
    internal_vote(me, prop, true);
}

struct provider_info {
	pubkey;
	name = "";
	url: text = "";
}

operation propose_providers(my_pubkey: pubkey, provider_infos: list<provider_info>, tier: provider_tier, system: boolean, active: boolean, description: text = "") {
    val me = require_is_provider_with_rl(my_pubkey);
    require_is_system_provider(my_pubkey);
    if (system) {
        require(tier == provider_tier.NODE_PROVIDER, "Only NODE_PROVIDER can be marked as system provider");
    }
    require(not(empty(provider_infos)), "Proposed provider key list is empty");

    val providers_map = map<pubkey, provider_info>();
    for (pi in provider_infos) {
        providers_map[pi.pubkey] = pi;
    }
    val providers = providers_map.values();
    for (p in providers) {
        require(empty(provider @? { p.pubkey }), "Provider already exists: " + p.pubkey);
    }

    val already_proposed = set<pubkey>();
    for (ppb in pending_provider_batch @* {}) {
        already_proposed.add_all(
            list<provider_info>.from_gtv(gtv.from_bytes(ppb.provider_infos)) @* {} ( .pubkey )
        );
    }
    for (p in providers) {
        require(not(p.pubkey in already_proposed), "Provider is already proposed: " + p.pubkey);
    }

    val prop = create proposal(op_context.last_block_time, proposal_type.provider_batch, me, system_p_voter_set(), description);
    create pending_provider_batch(prop, providers.to_gtv().to_bytes(), tier, system, active);
    internal_vote(me, prop, true);
}
