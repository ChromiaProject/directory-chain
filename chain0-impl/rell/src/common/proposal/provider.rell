
operation propose_cluster_provider(my_pubkey: pubkey, cluster_name: text, provider_pubkey: pubkey, add: boolean) {
    val me = require_is_provider_with_rl(my_pubkey);
    val provider = require_provider(provider_pubkey);
    require_node_access(provider);
    // Check that provider authority and that it is a cluster governor
    val cluster = require_cluster(cluster_name);
    require(cluster.name != clusters.system, "Cannot add provider to system cluster manually");
    require_cluster_governor(cluster, me);
    val prop = create proposal(op_context.last_block_time, proposal_type.cluster_provider, me, cluster.governance);
    create pending_cluster_provider(prop, cluster, provider, add);
    internal_vote(me, prop, true);
}

/*
    The provider with type in line can (+) / can not (-) change the state of the other one in the column:

         | CNP | NP  | SP
    -----|-----|-----|-----
     CNP |  -  |  -  |  -
     NP  |  +  |  -  |  -
     SP  |  +  |  +  |  +
*/
operation propose_provider_state(my_pubkey: pubkey, provider_pubkey: pubkey, active: boolean) {
    val me = require_provider(my_pubkey);
    val other_prov = require_provider(provider_pubkey);
    require_provider_auth_with_rl(me);

    // Only SP and NP can enable/disable providers
    require_node_access(me);

    if (roles.has_node_access(me) and other_prov.tier == provider_tier.COMMUNITY_NODE_PROVIDER) {
        update_provider_state(other_prov, active);
    } else {
        require_system_access(me);
        if (empty(pending_provider_state @* { .provider == other_prov, .active == active } limit 1)) {
            val prop = create proposal(op_context.last_block_time, proposal_type.provider_state, me, system_p_voter_set());
            create pending_provider_state(prop, other_prov, .active = active);
            internal_vote(me, prop, true);
        }
    }
}

operation propose_provider_is_system(my_pubkey: pubkey, provider_pubkey: pubkey, promote: boolean) {
    val me = require_is_provider_with_rl(my_pubkey);
    require_is_system_provider(my_pubkey);
    val other_prov = require_provider(provider_pubkey);

    if (empty(pending_provider_is_system @* { .provider == other_prov, .system == promote } limit 1)) {
        val prop = create proposal(op_context.last_block_time, proposal_type.provider_is_system, me, system_p_voter_set());
        create pending_provider_is_system(prop, other_prov, .system = promote);
        internal_vote(me, prop, true);
    }
}

operation propose_provider_quota(my_pubkey: pubkey, tier: provider_tier, provider_quota_type, value: integer) {
    val me = require_is_provider_with_rl(my_pubkey);
    require_is_system_provider(my_pubkey);

    // quota value requirements
    when (provider_quota_type) {
        max_actions_per_day -> require(value > 0, "Proposed max_actions_per_day quota value must be > 0: " + value);
        max_nodes -> require(false, "Proposing max_nodes quota value is not allowed");
        max_containers -> {
            require(value >= -1, "Proposed max_containers quota value must be >= -1: " + value);
            require(tier != provider_tier.COMMUNITY_NODE_PROVIDER, "Proposing max_containers quota is not allowed for COMMUNITY_NODE_PROVIDER");
        }
    }

    val prop = create proposal(op_context.last_block_time, proposal_type.provider_quota, me, system_p_voter_set());
    create pending_provider_quota(prop, tier, provider_quota_type, value);
    internal_vote(me, prop, true);
}

operation propose_providers(my_pubkey: pubkey, provider_keys: list<pubkey>, provider_tier, system: boolean, active: boolean) {
    val me = require_is_provider_with_rl(my_pubkey);
    require_is_system_provider(my_pubkey);
    val keys = list<pubkey>(set<pubkey>(provider_keys));
    require(not(empty(keys)), "Proposed provider key list is empty");
    for (pk in keys) {
        require(empty(provider @? { pk }), "Provider already exists: " + pk);
    }

    val already_proposed = list<byte_array>();
    for (ppb in pending_provider_batch @* {}) {
        already_proposed.add_all(list<byte_array>.from_gtv(gtv.from_bytes(ppb.gtv_keys)));
    }
    for (pk in keys) {
        require(not(pk in already_proposed), "Provider is already proposed: " + pk);
    }

    val prop = create proposal(op_context.last_block_time, proposal_type.provider_batch, me, system_p_voter_set());
    create pending_provider_batch(prop, keys.to_gtv().to_bytes(), provider_tier, system, active);
    internal_vote(me, prop, true);
}
