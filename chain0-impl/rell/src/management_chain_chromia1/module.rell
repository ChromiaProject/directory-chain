module;

import ^.version;
import ^.common.*;
import ^.common.init.*;
import ^.direct_cluster.*;
import ^.proposal.*;
import ^.proposal_blockchain.*;
import ^.proposal_cluster.*;
import ^.proposal_cluster_anchoring.*;
import ^.proposal_container.proposal_container_limits.*;
import ^.proposal_provider.*;
import ^.proposal_voter_set.*;
import .ft3.ft3_basic;
import ft3_account: .ft3.account;
import ft3_core: .ft3.core;

/*
 * Chromia1 is a public blockchain networking dapp where the c1 dapp manages and controls creating and deleting clusters, containers and blockchains.
 * To run this dapp postchain must be started in managed mode using anchoring, EIF and preferably the master/subnode configuration.
 * This dapp supports usage of the CHR token across dapps.
 */

entity provider_beneficiary {
    key provider;
    mutable beneficiary: ft3_account.account;
}

@extend(after_init) function init_asset () {
    ft3_core.register_asset("CHR", chain_context.blockchain_rid);
}

function create_simple_ft3_account(pubkey): ft3_account.account {
    val account_id = ft3_account.create_account_with_auth(
        ft3_account.auth_descriptor(
            "C",
            [pubkey],
            [pubkey.to_gtv()]
        )
    );
    return ft3_account.account @ { account_id };
}

@extend(register_and_enable_provider) function add_account_to_provider(provider_info, provider_tier, cluster?, voter_set?, enabled_by_default: boolean) {
    val account = create_simple_ft3_account(provider_info.pubkey);
    create provider_beneficiary(provider @ { provider_info.pubkey }, account);
}

operation update_provider(my_pubkey: pubkey, name?, beneficiary_account_id: byte_array?) {
    val me = require_provider(my_pubkey);
    require_provider_auth_with_rl(me);
    if (exists(name)) {
        me.name = name;
    }
    if (exists(beneficiary_account_id)) {
        update provider_beneficiary @ { me } (
            .beneficiary = ft3_account.account @ { .id == beneficiary_account_id }
        );
    }
}
