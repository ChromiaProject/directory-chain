module;

import ^.common.*;
import ^.model.*;

/*
 * Cluster Management api used by postchain to get information about cluster anchoring chains
*/

struct cm_peer_info {
    pubkey: pubkey;
    api_url: text;
}

struct cm_cluster_info {
    name;
    anchoring_chain: byte_array;
    peers: list<cm_peer_info>;
}

query cm_get_cluster_info(name): cm_cluster_info {
    val cluster_peer = (cluster_node, cluster, cluster_anchoring_chain) @* {
        cluster_node.cluster == cluster,
        cluster_anchoring_chain.cluster == cluster,
        cluster.name == name
    } (
        name = cluster.name,
        anchoring_chain = cluster_anchoring_chain.blockchain.rid,
        peer = cluster_node.node.pubkey,
        peer_api_url = cluster_node.node.api_url
    ); 
    val peers = list<cm_peer_info>();
    for (cp in cluster_peer) {
        peers.add(cm_peer_info(pubkey = cp.peer, api_url = cp.peer_api_url));
    }
    return cm_cluster_info(
        name = cluster_peer[0].name,
        anchoring_chain = cluster_peer[0].anchoring_chain,
        peers = peers
    );
}

query cm_get_cluster_names(): list<text> {
    return cluster @* { .operational == true } ( .name );
}

query cm_get_cluster_blockchains(name): list<byte_array> {
    return (container_blockchain) @* { .container.cluster.name == name } ( .blockchain.rid );
}

// Returns signers of blockchain at specific height
query cm_get_peer_info(brid: byte_array, height: integer): set<pubkey> {
    val bc = blockchain @ { brid };
    if (pcu_enabled()) {
        val signers = pending_blockchain_configuration @? { bc } (@sort_desc @omit .minimum_height <= height, gtv.from_bytes(.signers)) limit 1;
        return set<pubkey>.from_gtv(
            signers ?: get_signers_for_configuration(bc, height)
        );
    } else {
        return set<pubkey>.from_gtv(
            get_signers_for_configuration(bc, height)
        );
    }
}

query cm_get_blockchain_cluster(brid: byte_array): text {
    return get_cluster_for_blockchain(brid).name;
}

query cm_get_blockchain_api_urls(blockchain_rid: byte_array) {
    return (blockchain, container_blockchain, cluster_node) @*
    {
        blockchain.rid == blockchain_rid,
        container_blockchain.blockchain.rid == blockchain.rid,
        container_blockchain.container.cluster == cluster_node.cluster
    } (
        cluster_node.node.api_url
    );
}

query cm_get_cluster_anchoring_chains(): list<byte_array> {
    return cluster_anchoring_chain @* {} ( .blockchain.rid );
}

query cm_get_system_anchoring_chain(): byte_array? {
    if (system_anchoring_chain.rid.empty()) return null;

    return system_anchoring_chain.rid;
}

query cm_get_system_chains(): list<byte_array> {
    return blockchain @* { .system }.rid;
}