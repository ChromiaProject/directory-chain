@test module;

import ^^.*;
import ^^^.common.test.ops.*;
import ^^^.common.test.setup.*;
import ^^^.common.test.util.*;
import ^^^.proposal.voting.test.ops.*;

function setup() {
    setup_module();
    rell.test.tx().op(create_test_provider("bob", rell.test.pubkeys.bob)).run();
}

function test_propose_blockchain() {
    setup();

    val cl = system_cluster();
    val co = system_container();
    val alice = provider @ { rell.test.pubkeys.alice };
    val bob = provider @ { rell.test.pubkeys.bob };
    rell.test.tx().op(add_test_member(system_p_voter_set(), bob)).run();

    var conf = ["config_consensus_strategy": "HEADER_HASH".to_gtv()];
    rell.test.tx().op(
        propose_blockchain(alice.pubkey, conf.to_gtv().to_bytes(), "foo_chain", co.name)
    ).sign(rell.test.keypairs.alice).run();

    // Proposal is pending
    val prop = last_proposal();
    val config_proposal = get_blockchain_proposal(prop.rowid);
    assert_not_null(config_proposal);
    assert_equals(config_proposal.container, system_container_name(cl.name));
    
    rell.test.tx().op(
        create_test_node(alice, rell.test.pubkeys.alice, cl)
    ).sign(rell.test.keypairs.alice).run_must_fail();

    // Bob votes
    bob_votes();

    // Asserting blockchain is running
    val bc = blockchain @ { .name == "foo_chain" };
    assert_equals(bc.state, blockchain_state.RUNNING);

    // 2. Proposing blockchain pause
    alice_proposes_action(bc, blockchain_action.pause);
    assert_action_proposed(blockchain_action.pause);
    bob_votes();
    assert_equals(bc.state, blockchain_state.PAUSED);

    // 3. Proposing blockchain resume
    alice_proposes_action(bc, blockchain_action.resume);
    assert_action_proposed(blockchain_action.resume);
    bob_votes();
    assert_equals(bc.state, blockchain_state.RUNNING);

    // 4. Proposing blockchain deleted
    val brid = bc.rid;
    alice_proposes_action(bc, blockchain_action.remove);
    assert_action_proposed(blockchain_action.remove);
    bob_votes();
    assert_null( blockchain @? { .rid == brid } );

    // Proposal(s) is removed
    assert_null(proposal @? {} limit 1);
}

function alice_proposes_action(bc: blockchain, action: blockchain_action) {
    rell.test.tx().op(
        propose_blockchain_action(rell.test.pubkeys.alice, bc.rid, action)
    ).sign(rell.test.keypairs.alice).run();
}

function bob_votes() {
    val bob = rell.test.pubkeys.bob;
    rell.test.tx().op(
        make_vote(bob, last_proposal().rowid.to_integer(), true)
    ).sign(rell.test.keypairs.bob).run();
}

function assert_action_proposed(action: blockchain_action) {
    assert_equals(
        pending_blockchain_action @ { last_proposal() } .action,
        action
    );
}

function test_propose_configuration_at() {
    setup_module();

    var conf = ["config_consensus_strategy": "HEADER_HASH".to_gtv()];
    rell.test.tx().op(
        propose_blockchain(initial_provider.pub, conf.to_gtv().to_bytes(), "foo_chain", system_container_name(clusters.system))
    ).sign(initial_provider).run();
    val bc = blockchain @? { conf.hash() };
    assert_not_null(bc);

    // 1. force == false
    // 1.1. at height 10
    propose_config(bc.rid, conf, 10, false).run();
    assert_not_null(blockchain_configuration @? { bc, 10 });
    // 1.2. before 10
    propose_config(bc.rid, conf, 8, false).run();
    assert_not_null(blockchain_configuration @? { bc, 8 });

    // assert unique configurations
    assert_not_equals(blockchain_configuration @? { bc, 10 } (.data), blockchain_configuration @? { bc, 8 } (.data));

    // 1.3. again 10
    propose_config(bc.rid, conf, 10, false).run_must_fail();
    // 1.4. height is null
    propose_config(bc.rid, conf, -1, false).run_must_fail();
    // 1.5. height is -2, to be less than last_height (-1)
    propose_config(bc.rid, conf, -2, false).run_must_fail();

    // 2. force == true
    var conf2 = ["config_consensus_strategy": "HEADER_HASH".to_gtv()];
    conf2["name"] = "conf2".to_gtv();
    propose_config(bc.rid, conf2, 8, true).run();
    val actual_config_bytes = blockchain_configuration @ { bc, 8 } (.data);
    val actual_config = map<text, gtv>.from_gtv(gtv.from_bytes(actual_config_bytes));
    assert_equals(actual_config["name"], "conf2".to_gtv());
    // NB: we can't test `height = -1` case
    // propose_config(bc.rid, conf, -1, false).run();
    // See kotlin test
}

function propose_config(brid: byte_array, conf: map<text, gtv>, height: integer, force: boolean) {
    return rell.test.tx().op(
        propose_configuration_at(initial_provider.pub, brid, conf.to_gtv().to_bytes(), height, force)
    ).sign(initial_provider);
}
