// Proposed bc:s are put here while waiting for enough positive votes.
entity pending_blockchain {
    key proposal;
    name;
    data: byte_array;
    container;
}

@extend(is_container_available_for_removal) function(container) = 
        if (exists(pending_blockchain @* { container }))
            "Container %s has pending proposals and can't be deleted. Resolve proposals first".format(container.name)
        else null;

@extend(apply_voting_result_handlers) function() = [proposal_type.bc.name: apply_blockchain_proposal(*)];

// Initial signers of new bc are the ones in cluster_node table.
function apply_blockchain_proposal(proposal) {
    val bc = pending_blockchain @? {proposal};
    if (bc == null) return;
    val nodes = cluster_node @* { bc.container.cluster } (@sort .node.pubkey);
    // do not write new configuration when size is 0 since it's impossible to recover from that
    require(nodes.size() > 0, "Cluster must have at least one node");

    val blockchain_rid = add_blockchain(bc.data, nodes.to_gtv().to_bytes(), bc.name, bc.container);
    log("Added blockchain", blockchain_rid);
}

@extend(delete_proposal_handlers) function(): map<text, (proposal) -> unit> = [proposal_type.bc.name: delete_pending_blockchain(*)];

function delete_pending_blockchain(proposal) {
    delete pending_blockchain @? { proposal };
}

/*
 * Proposes a new blockchain to a container.
 * NB: only the deployer voter set of the container can do this.
 */
//Who can propose a new blockchain? The container deployer voter set
operation propose_blockchain(my_pubkey: pubkey, config_data: byte_array, bc_name: text, container_name: text, description: text = "") {
    val me = require_is_provider_with_rl(my_pubkey);
    val container = require_container(container_name);
    require_container_deployer(container, me);

    validate_blockchain_configuration(config_data, signers=true, header_hash=pcu_enabled());

    // Require container resource limits are honored
    val max_blockchains = container_resource_limit @ { container, container_resource_limit_type.max_blockchains } (.value);
    if (max_blockchains > 0) {
        val container_dapps_count = container_blockchain @* { container } (@sum 1)[0];
        require(container_dapps_count < max_blockchains, "Can't propose blockchain, container %s is full".format(container_name));
    }

    // If already proposed, do not add again.
    if (empty(pending_blockchain @* {.data == config_data } limit 1)) {
        val prop = create proposal(op_context.last_block_time, proposal_type.bc, me, container.deployer, description);
        create pending_blockchain(prop, bc_name, config_data, container);
        internal_vote(me, prop, true);
    }
}

query get_blockchain_proposal(rowid): (data:byte_array, container:text)? {
    return pending_blockchain @? { require_proposal(rowid) } ( data = .data, container = .container.name );
}