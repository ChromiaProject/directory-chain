module;

import ^.common.*;
import .proposal.*;
import .ft3.ft3_basic;
import ft3_account: .ft3.account;
import ft3_core: .ft3.core;
import ^.cluster.cluster_op.*;

/*
 * Chromia1 is a public blockchain networking dapp where the c1 dapp manages and controls creating and deleting clusters, containers and blockchains.
 * To run this dapp postchain must be started in managed mode using anchoring, EIF and preferably the master/subnode configuration.
 * This dapp supports usage of the CHR token across dapps.
 */
struct module_args {
	initial_provider: pubkey;
	genesis_node: node_info;
}

entity provider_beneficiary {
	key provider;
	mutable beneficiary: ft3_account.account; 	 
}

operation init (initial_node_host:text, initial_node_port:integer, anchoring_config: gtv) {
	initialize_module(chain_context.args.initial_provider, chain_context.args.genesis_node, 100, anchoring_config = anchoring_config);
	ft3_core.register_asset("CHR", chain_context.blockchain_rid);
}

function create_simple_ft3_account(pubkey): ft3_account.account {
	val account_id = ft3_account.create_account_with_auth(
		ft3_account.auth_descriptor(
			"C",
			[pubkey],
			[pubkey.to_gtv()]
		)	
	);
	return ft3_account.account @ { account_id };
}

@extend(register_and_enable_provider) function add_account_to_provider(pubkey, provider_tier, cluster?, voter_set?, enabled_by_default: boolean) {
	val account = create_simple_ft3_account(pubkey);
	create provider_beneficiary(provider @ { pubkey }, account);
}

operation update_provider(my_pubkey: pubkey, name?, beneficiary_account_id: byte_array?) {
    val me = require_provider(my_pubkey);
	require_provider_auth_with_rl(me);
	if (exists(name)) {
		me.name = name;
	}
	if (exists(beneficiary_account_id)) {
		update provider_beneficiary @ { me } (
			.beneficiary = ft3_account.account @ { .id == beneficiary_account_id }
		);
	} 
}
