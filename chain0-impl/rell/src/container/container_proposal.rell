module;

import ^^.model.*;
import ^^.common.proposal.*;
import ^.*;

enum container_proposal_type {
    create_container,
    create_container_with_resource_limits,
    remove_container
}

entity container_proposal {
    key proposal;
    container_proposal_type;
}

entity pending_container {
    key proposal;
    key name;
    cluster;
    deployer: voter_set;
    proposed_by: provider;
}

entity pending_container_with_resource_limits {
    key proposal;
    key name;
    cluster;
    deployer: voter_set;
    max_blockchains: integer;
    cpu: integer;
    ram: integer;
    storage: integer;
    proposed_by: provider;
}

entity pending_remove_container {
    key proposal;
    key container;
}

@extend(delete_other_proposal) function delete_container_proposal(proposal) {
    val container_proposal = container_proposal @? { proposal };
    if (container_proposal == null) return;
    when (container_proposal.container_proposal_type) {
        create_container -> delete pending_container @ { proposal };
        create_container_with_resource_limits -> delete pending_container_with_resource_limits @ { proposal };
        remove_container -> delete pending_remove_container @? { proposal };
    }
    delete container_proposal;
}

@extend(apply_other_voting_result) function apply_container_proposal(proposal) {
    val container_proposal = container_proposal @? { proposal };
    if (container_proposal == null) return;
    when (container_proposal.container_proposal_type) {
        create_container -> apply_container(proposal);
        create_container_with_resource_limits -> apply_container_with_resource_limits(proposal);
        remove_container -> apply_container_remove(proposal);
    }
}

// Who can create a new container? Cluster deployers' voter set. (They can also update container limits.)
operation propose_container(my_pubkey: pubkey, cluster_name: text, name, deployer_name: text, description: text = "") {
    // check that provider authority and that it is cluster's deployer
    val me = require_provider(my_pubkey);
    require_provider_auth_with_rl(me);
    val cluster = require_cluster(cluster_name);
    val deployer = require_voter_set(deployer_name);
    require_cluster_governor(cluster, me);
    require_provider_quota(me, provider_quota_type.max_containers);
    require_cluster_quotas(cluster);

    val max_blockchains = _get_cluster_limit_or_default(cluster, cluster_resource_limit_type.default_container_max_blockchains);
    val cpu = _get_cluster_limit_or_default(cluster, cluster_resource_limit_type.default_container_cpu);
    val ram = _get_cluster_limit_or_default(cluster, cluster_resource_limit_type.default_container_ram);
    val storage = _get_cluster_limit_or_default(cluster, cluster_resource_limit_type.default_container_storage);

    val prop = create proposal(op_context.last_block_time, proposal_type.other, me, cluster.governance, description);
    create pending_container_with_resource_limits(
        prop, name, cluster, deployer, max_blockchains, cpu, ram, storage, me
    );
    create container_proposal(prop, container_proposal_type.create_container_with_resource_limits);
    internal_vote(me, prop, true);
}

operation propose_remove_container(my_pubkey: pubkey, name, description: text = "") {
    val me = require_provider(my_pubkey);
    require_provider_auth_with_rl(me);
    val cont = require_container(name);
    require_cluster_governor(cont.cluster, me);
    require_container_available_for_removal(cont);

    val prop = create proposal(op_context.last_block_time, proposal_type.other, me, cont.cluster.governance, description);
    create pending_remove_container(prop, cont);
    create container_proposal(prop, container_proposal_type.remove_container);
    internal_vote(me, prop, true);
}

function apply_container(proposal) {
    val pps = pending_container @ { proposal };
    create_container_with_resource_limits(
        pps.proposed_by,
        pps.name,
        pps.cluster,
        pps.deployer
    );
}

function apply_container_with_resource_limits(proposal) {
    val pps = pending_container_with_resource_limits @ { proposal };
    create_container_with_resource_limits(
        pps.proposed_by,
        pps.name,
        pps.cluster,
        pps.deployer,
        pps.max_blockchains,
        pps.cpu,
        pps.ram,
        pps.storage
    );
}

function apply_container_remove(proposal) {
    val cont = pending_remove_container @ { proposal } .container;
    delete container_resource_limit @* { cont };
    delete pending_remove_container @ { proposal };
    delete container @ { cont.name };
}
