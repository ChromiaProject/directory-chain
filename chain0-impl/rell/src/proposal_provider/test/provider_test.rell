@test module;

import ^^.*;
import ^^^.common.test.setup.*;
import ^^^.common.test.util.*;
import ^^^.direct_container.*;

val system_provider = rell.test.keypairs.bob;
val node_provider = rell.test.keypairs.trudy;
val dapp_provider = rell.test.keypair(
     priv = x"B39E4CCCB9B0FD71B7AC9FFF1216C34648FA7362ECD9874743776BDFDEE4F6A8",
     pub = x"03BD01AF899839BDDB5810616C1AF8B61B415E903D73418DED238A8EEA352C72E0"
);
val provider1 = rell.test.keypair(
    priv = x"71C89AE77719E3779EAE09C26A229F7AF33D8C8F7E7E8D82A9A42470C224AB56",
    pub = x"020EE9063CED9B47CC60EB931443C01F3FD7A0DAB4B2D0505D3A2FAAD4FA9ABF13"
);
val provider2 = rell.test.keypair(
    priv = x"49DB53CB0E1CC472DE90FC833CEDB4E1B412C5AF658342762D1BB8F3886063B6",
    pub = x"031D22EA1C599A69E35E023E1CBCEAC66C046B445FF5507DBA650B58F28C650A15"
);

function test_propose_providers() {
    setup_module(majority_threshold = 1);
    val keys = [provider_info(provider1.pub), provider_info(provider2.pub)];

    // setup
    rell.test.tx().op(
        register_provider(initial_provider.pub, node_provider.pub, provider_tier.NODE_PROVIDER),
        register_provider(initial_provider.pub, dapp_provider.pub, provider_tier.COMMUNITY_NODE_PROVIDER)
    ).sign(initial_provider).run();

    // Ð¡NP tries to propose_providers() and fails
    rell.test.tx().op(
        propose_providers(dapp_provider.pub, keys, provider_tier.NODE_PROVIDER, false, false)
    ).sign(dapp_provider).run_must_fail();

    // NP tries to propose_providers() and fails
    rell.test.tx().op(
        propose_providers(node_provider.pub, keys, provider_tier.NODE_PROVIDER, false, false)
    ).sign(node_provider).run_must_fail();

    // IP tries to propose_providers() with empty arg and fails
    rell.test.tx().op(
        propose_providers(initial_provider.pub, [], provider_tier.NODE_PROVIDER, false, false)
    ).sign(initial_provider).run_must_fail();

    // IP tries to propose_providers() with existent provider and fails
    rell.test.tx().op(
        propose_providers(initial_provider.pub, [provider_info(node_provider.pub)], provider_tier.NODE_PROVIDER, false, false)
    ).sign(initial_provider).run_must_fail();

    // IP proposes providers batch
    val non_system_enabled_keys = [
        provider_info(x"03BD01AF899839BDDB5810616C1AF8B61B415E903D73418DED238A8EEA352C72EF"),
        provider_info(x"03BD01AF899839BDDB5810616C1AF8B61B415E903D73418DED238A8EEA352C72E1")
    ];
    val non_system_disabled_keys = [
            provider_info(x"03BD01AF899839BDDB5810616C1AF8B61B415E903D73418DED238A8EEA352C72E4")
        ];
    val system_disabled_keys = [
        provider_info(x"03BD01AF899839BDDB5810616C1AF8B61B415E903D73418DED238A8EEA352C72E5"),
        provider_info(x"03BD01AF899839BDDB5810616C1AF8B61B415E903D73418DED238A8EEA352C72E6")
    ];
    val system_enabled_keys = [
        provider_info(x"03BD01AF899839BDDB5810616C1AF8B61B415E903D73418DED238A8EEA352C72E2"),
        provider_info(x"03BD01AF899839BDDB5810616C1AF8B61B415E903D73418DED238A8EEA352C72E3")
    ];
    rell.test.tx().op(
        propose_providers(initial_provider.pub, non_system_enabled_keys, provider_tier.NODE_PROVIDER, false, true),
        propose_providers(initial_provider.pub, non_system_disabled_keys, provider_tier.NODE_PROVIDER, false, false),
        propose_providers(initial_provider.pub, system_disabled_keys, provider_tier.NODE_PROVIDER, true, false)
    ).sign(initial_provider).run();

    assert_true(exists(provider @? { non_system_enabled_keys[0].pubkey, .system == false, .active == true }));
    assert_true(exists(provider @? { non_system_enabled_keys[1].pubkey, .system == false, .active == true }));

    assert_true(exists(provider @? { non_system_disabled_keys[0].pubkey, .system == false, .active == false }));

    assert_true(exists(provider @? { system_disabled_keys[0].pubkey, .system == true, .active == false }));
    assert_true(exists(provider @? { system_disabled_keys[1].pubkey, .system == true, .active == false }));

    // Making sure that newly added disabled system providers are not members of system governance
    assert_equals(voter_set_member @ { system_p_voter_set() } (@sum 1), 1);
    assert_equals(cluster_provider @ { system_cluster() } (@sum 1), 3);

    rell.test.tx().op(
        propose_providers(initial_provider.pub, system_enabled_keys, provider_tier.NODE_PROVIDER, true, true)
    ).sign(initial_provider).run();

    assert_true(exists(provider @? { system_enabled_keys[0].pubkey, .system == true, .active == true }));
    assert_true(exists(provider @? { system_enabled_keys[1].pubkey, .system == true, .active == true }));

    // Making sure that newly added enabled system providers are members of system governance
    assert_equals(voter_set_member @ { system_p_voter_set() } (@sum 1), 3);
    assert_equals(cluster_provider @ { system_cluster() } (@sum 1), 5);
}

function test_propose_providers_duplication() {
    setup_module();
    rell.test.tx().op(
        register_provider(initial_provider.pub, system_provider.pub, provider_tier.NODE_PROVIDER),
        propose_provider_is_system(initial_provider.pub, system_provider.pub, true)
    ).sign(initial_provider).run();

    val keys1 = [provider_info(dapp_provider.pub), provider_info(provider1.pub)];
    val keys2 = [provider_info(dapp_provider.pub), provider_info(provider2.pub)];
    rell.test.tx().op(
        propose_providers(initial_provider.pub, keys1, provider_tier.NODE_PROVIDER, true, false)
    ).sign(initial_provider).run();

    // IP tries to propose_providers() with already proposed provider and fails
    rell.test.tx().op(
        propose_providers(initial_provider.pub, keys2, provider_tier.NODE_PROVIDER, true, false)
    ).sign(initial_provider).run_must_fail();

    // tolerating of incoming duplicates
    val keys3 = [provider_info(provider2.pub), provider_info(provider2.pub)];
    rell.test.tx().op(
        propose_providers(initial_provider.pub, keys3, provider_tier.NODE_PROVIDER, true, false)
    ).sign(initial_provider).run();
    rell.test.tx().op(
        make_vote(system_provider.pub, last_proposal().rowid.to_integer(), true)
    ).sign(system_provider).run();
    assert_true(exists(provider @? { keys3[0].pubkey, .system == true, .active == false }));
}

function test_propose_remove_provider() {
    setup_module();

    // setup
    rell.test.tx().op(
        register_provider(initial_provider.pub, node_provider.pub, provider_tier.NODE_PROVIDER),
        register_provider(initial_provider.pub, dapp_provider.pub, provider_tier.COMMUNITY_NODE_PROVIDER)
    ).sign(initial_provider).run();

    // require auth
    val failure = rell.test.tx().op(
        propose_remove_provider(node_provider.pub, dapp_provider.pub)
    ).sign(initial_provider).run_must_fail();
    assert_true(failure.message.contains("Operation must be signed by"));

    // IP is trying to remove unknown provider and fails
    val failure2 = rell.test.tx().op(
        propose_remove_provider(initial_provider.pub, x"ff")
    ).sign(initial_provider).run_must_fail();
    assert_true(failure2.message.contains("Unknown provider"));

    // IP is trying to remove active CNP and fails
    val failure3 = rell.test.tx().op(
        propose_remove_provider(initial_provider.pub, dapp_provider.pub)
    ).sign(initial_provider).run_must_fail();
    assert_true(failure3.message.contains("Active provider can't be deleted"));

    // IP removes NP
    rell.test.tx().op(
        propose_remove_provider(initial_provider.pub, node_provider.pub)
    ).sign(initial_provider).run();
    assert_true(empty(provider @? { node_provider.pub }));

    // More complex test with second SP
    // adding SP
    rell.test.tx().op(
        register_provider(initial_provider.pub, system_provider.pub, provider_tier.NODE_PROVIDER),
        propose_provider_is_system(initial_provider.pub, system_provider.pub, true)
    ).sign(initial_provider).run();

    // adding SP's node
    val sp_node_key = x"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbE7260BA921CD673F";
    rell.test.tx().op(
        register_node(system_provider.pub, sp_node_key, "host", 7777, "http://host/api_url", [clusters.system])
    ).sign(system_provider).run();
    assert_true(exists(cluster_node @? { system_cluster(), node @ { sp_node_key } }));
    assert_true(exists(cluster_provider @? { system_cluster(), provider @ { system_provider.pub } }));

    // More data for SP
    // 1. Adding SP to voter_set. SP will be removed from voter_set in propose_provider_state(..., false) operation.
    rell.test.tx().op(
        create_voter_set(system_provider.pub, "test_vs", 1, [system_provider.pub], null)
    ).sign(system_provider).run();
    // 2. SP creates a container
    rell.test.tx().op(
        create_container(system_provider.pub, "sp_container", clusters.system, 1, [system_provider.pub])
    ).sign(system_provider).run();

    // disabling SP
    rell.test.tx().op(
        propose_provider_state(system_provider.pub, system_provider.pub, false)
    ).sign(system_provider).run();
    vote_for_last_proposal(initial_provider);
    assert_true(exists(node @? { sp_node_key }));
    assert_false(exists(cluster_node @? { system_cluster(), .node.pubkey == sp_node_key }));
    assert_true(exists(cluster_provider @? { system_cluster(), provider @ { system_provider.pub } }));

    // IP is trying to delete IP and fails because "sp_container" exists
    val failure4 = rell.test.tx().op(
        propose_remove_provider(initial_provider.pub, system_provider.pub)
    ).sign(initial_provider).run_must_fail();
    assert_true(failure4.message.contains("Provider is the author of the container(s)"));
    rell.test.tx().op(
        remove_container(initial_provider.pub, "sp_container")
    ).sign(initial_provider).run();

    // IP removes SP
    rell.test.tx().op(
        propose_remove_provider(initial_provider.pub, system_provider.pub)
    ).sign(initial_provider).run();
    assert_false(exists(provider @? { system_provider.pub }));
    assert_false(exists(node @? { sp_node_key }));
    assert_false(exists(cluster_node @? { system_cluster(), .node.pubkey == sp_node_key }));
    assert_false(exists(cluster_provider @? { system_cluster(), .provider.pubkey == system_provider.pub }));
}

function test_propose_remove_provider_with_cross_requirements() {
    setup_module();

    // setup
    rell.test.tx().op(
        register_provider(initial_provider.pub, system_provider.pub, provider_tier.NODE_PROVIDER),
        propose_provider_is_system(initial_provider.pub, system_provider.pub, true),
        register_provider(initial_provider.pub, rell.test.pubkeys.trudy, provider_tier.NODE_PROVIDER),
        propose_provider_is_system(initial_provider.pub, rell.test.pubkeys.trudy, true)
    ).sign(initial_provider).run();
    vote_for_last_proposal(system_provider);

    // propose state, propose removal
    rell.test.tx().op(
        propose_provider_state(initial_provider.pub, system_provider.pub, false)
    ).sign(initial_provider).run();
    val failure1 = rell.test.tx().op(
        propose_remove_provider(initial_provider.pub, system_provider.pub)
    ).sign(initial_provider).run_must_fail();
    failure1.message.contains("Provider state is proposed for changes");

    // voting for SP disabling
    vote_for_last_proposal(system_provider);
    vote_for_last_proposal(rell.test.keypairs.trudy);

    // propose removal, propose state
    rell.test.tx().op(
        propose_remove_provider(initial_provider.pub, system_provider.pub)
    ).sign(initial_provider).run();
    val failure2 = rell.test.tx().op(
        propose_provider_state(rell.test.keypairs.trudy.pub, system_provider.pub, false)
    ).sign(rell.test.keypairs.trudy).run_must_fail();
    failure2.message.contains("Provider is proposed for removal");
}