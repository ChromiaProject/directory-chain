
import ^.model.*;

/*
    Returns NM API Version
    NM API Version: 1
*/
query nm_api_version () = 4;

/*
    Returns version of peerlist
    NM API Version: 1
*/
query nm_get_peer_list_version() = node_list.last_update;

/*
    Returns peer info list
    NM API Version: 1
    (API expects array, so we need suppress naming)
*/
query nm_get_peer_infos() = node @* {} (_ = .host, _ = .port, _ = .pubkey, _ = .last_updated);

/*
    Configuration updates are found in two tables. Both must be checked to get next configuration height.
    NM API Version: 1
*/
query nm_find_next_configuration_height(blockchain_rid: byte_array, height: integer): integer? {
    val bc = blockchain @? { blockchain_rid };
    if (bc == null) return null;
    val conf_h = blockchain_configuration @? { bc, .height > height } (@sort .height) limit 1;
    val sign_h = blockchain_configuration_signers @? { bc, .height > height } (@sort .height) limit 1;
    if (conf_h == null) return sign_h;
    if (sign_h == null) return conf_h;
    return max(conf_h, sign_h);
}

/*
    Merge content of blockchain_configuration and blockchain_configuration_signers
    NM API Version: 1
*/
query nm_get_blockchain_configuration(blockchain_rid: byte_array, height: integer): byte_array? {
	val bc = blockchain @ { blockchain_rid };
    // Find configuration height -- the latest height up to given height.
    // If conf_h exist, so does signer_h, thus no need to check both.
    val config_h = blockchain_configuration @? { bc, .height <= height } (@sort_desc .height) limit 1;
    if (config_h != null)
        return get_blockchain_configuration_with_signers(bc, height, config_h);
    else
        return null;
}

/*
    Returns list of blockchains to be launched
    NM API Version: 1 (Deprecated: Use nm_compute_blockchain_info_list)
*/
query nm_compute_blockchain_list(node_id: pubkey): list<byte_array> {
    val res = list<byte_array>();
	for (blockchain in compute_blockchain_info_list(node_id)) {
	    res.add(blockchain.rid);
	}
	return res;
}

/*
    Returns list of blockchains to be launched
    NM API Version: 4
*/
query nm_compute_blockchain_info_list(node_id: pubkey): list<blockchain_info> {
    return compute_blockchain_info_list(node_id);
}

function compute_blockchain_info_list(node_id: pubkey): list<blockchain_info> {
    val node = node @? { node_id };
    if (exists(node)) {
        val res = set<blockchain_info>();
        res.add_all(get_cluster_node_blockchains(node));
        res.add_all(get_cluster_replica_node_blockchains(node));
        res.add_all(get_blockchains_replicated_by_node(node));
        return list(res);
    } else {
        return [blockchain_info(chain_context.blockchain_rid, true)];
    }
}

/*
    NM API Version: 4
*/
query nm_get_blockchain_replica_node_map_v4(blockchain_rids: set<byte_array>): map<byte_array, set<byte_array>> {
    val res = map<byte_array, set<byte_array>>();
    for (brid in set(blockchain_rids)) {
        /*
            Kalle: we include signers in this list because node processing old blocks might
            want to connect to _current_ signers to get blocks
        */
        val nodes = set<byte_array>();
        nodes.add_all(get_blockchain_signers_and_replicas(brid));
        nodes.add_all(blockchain_replica_node @* { .blockchain.rid == brid } (.node.pubkey));
        res.put(brid, nodes);
    }
    return res;
}

/*
    NM API Version: 1
    Deprecated, use `nm_get_node_blockchain_replica_node_map()` instead
*/
query nm_get_blockchain_replica_node_map(blockchain_rids: list<byte_array>): list<list<byte_array>> {
	val res = list<list<byte_array>>();
	for (brid in blockchain_rids) {
		val bc = blockchain @? { brid };
		if (empty(bc)) {
			res.add(list<byte_array>());
		} else {
			// Kalle: we include signers in this list because node processing old blocks might
			// want to connect to _current_ signers to get blocks
			val container = container_blockchain @ {bc} .container;
			val signers = set( cluster_node @* { container.cluster } .node.pubkey );
			signers.add_all(
				blockchain_replica_node @* { bc } .node.pubkey
			);
			res.add(list(signers));
		}
	}
	return res;
}

/*
    Function used by  mustSyncUntil (height) pos-146
    NM API Version: 2
*/
query nm_get_blockchain_last_height_map(blockchain_rids: list<byte_array>) : list<integer> {
	val res = list<integer>();
    for (brid in blockchain_rids) {
        val bc = blockchain @? { brid };
        if (brid == chain_context.blockchain_rid) {
            val h = (block @? {} (@sort_desc .block_height) limit 1) ?: -1;
            res.add(h);
        } else if (empty(bc)) {
            res.add(-1);
        } else {
            val h = (anchored_block @? { bc } (@sort_desc .height) limit 1) ?: -1;
            res.add(h);
        }
    }
    return res;
}

/*
    NM API Version: 3
*/
query nm_get_container_limits(name): map<text, integer> {
	val container = container @ {name};
	var return_map = map<text, integer>();
	val limits_list = container_resource_limit @* { container };
	for (l in limits_list) {
		val r = l.container_resource_limit_type;
		return_map.put(r.name, l.value);
	}
	return return_map;
}

/*
    NM API Version: 3
*/
query nm_get_cluster_limits(name): map<text, integer> {
	val cluster = cluster @ {name};
	var return_map = map<text, integer>();
	val limits_list = cluster_resource_limit @* {cluster};
	for (l in limits_list) {
		val r = l.cluster_resource_limit_type;
		return_map.put(r.name, l.value);
	}
	return return_map;
}

/*
    Returns node containers
    NM API Version: 3
*/
query nm_get_containers(pubkey): list<text> {
	val clusters = cluster_node @* {node @ { pubkey }} .cluster;
	val res = list<text>();
	for (cl in clusters) {
		val containers = container @* { cl } .name;
		res.add_all(containers);
	}
	return res;
}

/*
    NM API Version: 3
*/
query nm_get_blockchains_for_container(container_name: text): list<byte_array> {
	val container = container @? {container_name};
	val res = list<byte_array>();
	if (exists(container)) {
		val cluster = container.cluster;
		res.add_all(container_blockchain @* {container, .blockchain.active == true} .blockchain.rid);
	}
	return res;
}

/*
    NM API Version: 3
*/
query nm_get_container_for_blockchain(blockchain_rid: byte_array): text {
    val bc = require(blockchain @? { blockchain_rid }, "Blockchain with rid not found: " + blockchain_rid);
    return container_blockchain @ { bc } .container.name;
}

/*
    Returns a list of brids with corresponding container that this blockchain is dependent on. At the given height.
    NM API Version: 3
*/
query nm_get_blockchain_dependencies(blockchain, height: integer): list<(byte_array, text)> {
	val res = list<(byte_array, text)>();
	val conf_h = blockchain_configuration @? { blockchain, .height <= height }
        	(@sort .height) limit 1;
    if (conf_h != null) {
    	val brids = blockchain_dependency @* {.me == blockchain, conf_h} .dependent_on.rid;
    	for (brid in brids) {
    		res.add((brid, container_blockchain @ { blockchain @{brid}} .container.name));
    	}
    }
	return res;
}
