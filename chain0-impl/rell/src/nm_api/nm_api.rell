import ^.common.*;
import ^.model.*;

/*
    Returns NM API Version
    NM API Version: 1
*/
query nm_api_version () = 5;

/*
    Returns version of peerlist
    NM API Version: 1
*/
query nm_get_peer_list_version() = node_list.last_update;

/*
    Returns peer info list
    NM API Version: 1
    (API expects array, so we need suppress naming)
*/
query nm_get_peer_infos() = node @* {} (_ = .host, _ = .port, _ = .pubkey, _ = .last_updated);

/*
    Returns last built height of the blockchain
    NM API Version: 4
    Deprecated: relies on legacy anchoring which will be removed
*/
query nm_get_blockchain_last_built_height(blockchain_rid: byte_array) =
    deprecated_get_blockchain_last_height(blockchain_rid);

/*
    Configuration updates are found in two tables. Both must be checked to get next configuration height.
    NM API Version: 1
*/
query nm_find_next_configuration_height(blockchain_rid: byte_array, height: integer): integer? {
    val bc = blockchain @? { blockchain_rid };
    if (bc == null) return null;
    val conf_h = blockchain_configuration @? { bc, .height > height } (@sort .height) limit 1;
    val sign_h = blockchain_configuration_signers @? { bc, .height > height } (@sort .height) limit 1;
    if (conf_h == null) return sign_h;
    if (sign_h == null) return conf_h;
    return max(conf_h, sign_h);
}

/*
    Merge content of blockchain_configuration and blockchain_configuration_signers
    NM API Version: 1
*/
query nm_get_blockchain_configuration(blockchain_rid: byte_array, height: integer): byte_array? {
    val bc = require_blockchain(blockchain_rid);
    // Find configuration height -- the latest height up to given height.
    // If conf_h exist, so does signer_h, thus no need to check both.
    val base_config = blockchain_configuration @? { bc, .height <= height } (@omit @sort_desc .height, $) limit 1;
    if (base_config != null) {
        // Checking that signers.size() is non-zero is done when population blockchain_configuration_signers.
        val signers = require(blockchain_configuration_signers @? { bc, .height <= height } (@omit @sort_desc .height, .signers) limit 1,
            "No signers configuration for blockchain %s for height %d".format(blockchain_rid, height));

        val full_config = map<text, gtv>.from_gtv(gtv.from_bytes(base_config.data));
        full_config["signers"] = gtv.from_bytes(signers);
        return full_config.to_gtv().to_bytes();
    } else {
        return null;
    }
}

/*
    NM API Version: 5
*/
query nm_get_blockchain_configuration_v5(blockchain_rid: byte_array, height: integer):
        (base_config: byte_array, signers: list<pubkey>)? {
    val bc = require_blockchain(blockchain_rid);
    // Find configuration height -- the latest height up to given height.
    // If conf_h exist, so does signer_h, thus no need to check both.
    val base_config = blockchain_configuration @? { bc, .height <= height } (@omit @sort_desc .height, .data) limit 1;
    if (base_config != null) {
        // Checking that signers.size() is non-zero is done when population blockchain_configuration_signers.
        val signers = require(blockchain_configuration_signers @? { bc, .height <= height } (@omit @sort_desc .height, .signers) limit 1,
            "No signers configuration for blockchain %s for height %d".format(blockchain_rid, height));
        return (base_config=base_config, signers=list<pubkey>.from_gtv(gtv.from_bytes(signers)));
    } else {
        return null;
    }
}

/*
    Returns list of blockchains to be launched
    NM API Version: 1 (Deprecated: Use nm_compute_blockchain_info_list)
*/
query nm_compute_blockchain_list(node_id: pubkey): list<byte_array> {
    val res = list<byte_array>();
    for (blockchain in compute_blockchain_info_list(node_id)) {
        res.add(blockchain.rid);
    }
    return res;
}

/*
    Returns list of blockchains to be launched
    NM API Version: 4
*/
query nm_compute_blockchain_info_list(node_id: pubkey): list<blockchain_info> {
    return compute_blockchain_info_list(node_id);
}

function compute_blockchain_info_list(node_id: pubkey): list<blockchain_info> {
    val node = node @? { node_id };
    if (exists(node)) {
        val res = set<blockchain_info>();
        res.add_all(get_cluster_node_blockchains(node));
        res.add_all(get_cluster_replica_node_blockchains(node));
        res.add_all(get_blockchains_replicated_by_node(node));
        return list(res);
    } else {
        return [blockchain_info(chain_context.blockchain_rid, true)];
    }
}

/*
    NM API Version: 4
*/
query nm_get_blockchain_replica_node_map(blockchain_rids: set<byte_array>): map<byte_array, set<byte_array>> {
    val res = map<byte_array, set<byte_array>>();
    for (brid in set(blockchain_rids)) {
        res.put(brid, get_blockchain_replica_nodes(brid));
    }
    return res;
}

/*
    Function used by  mustSyncUntil (height) pos-146
    NM API Version: 2
    Deprecated: relies on legacy anchoring which will be removed
*/
query nm_get_blockchain_last_height_map(blockchain_rids: list<byte_array>) : list<integer> {
    val res = list<integer>();
    for (brid in blockchain_rids) {
        if (empty(blockchain @? { brid })) {
            res.add(-1);
        } else {
            res.add(deprecated_get_blockchain_last_height(brid));
        }
    }
    return res;
}

/*
    NM API Version: 3
*/
query nm_get_container_limits(name): map<text, integer> {
    val container = container @ {name};
    var return_map = map<text, integer>();
    val limits_list = container_resource_limit @* { container };
    for (l in limits_list) {
        val r = l.container_resource_limit_type;
        return_map.put(r.name, l.value);
    }
    return return_map;
}

/*
    NM API Version: 3
*/
query nm_get_cluster_limits(name): map<text, integer> {
    val cluster = cluster @ {name};
    var return_map = map<text, integer>();
    val limits_list = cluster_resource_limit @* {cluster};
    for (l in limits_list) {
        val r = l.cluster_resource_limit_type;
        return_map.put(r.name, l.value);
    }
    return return_map;
}

/*
    Returns node containers
    NM API Version: 3
*/
query nm_get_containers(pubkey): list<text> {
    val clusters = cluster_node @* {node @ { pubkey }} .cluster;
    val res = list<text>();
    for (cl in clusters) {
        val containers = container @* { cl } .name;
        res.add_all(containers);
    }
    return res;
}

/*
    NM API Version: 3
*/
query nm_get_blockchains_for_container(container_name: text): list<byte_array> {
    val container = container @? {container_name};
    val res = list<byte_array>();
    if (exists(container)) {
        val cluster = container.cluster;
        res.add_all(container_blockchain @* {container, .blockchain.active == true} .blockchain.rid);
    }
    return res;
}

/*
    NM API Version: 3
*/
query nm_get_container_for_blockchain(blockchain_rid: byte_array): text {
    val bc = require_blockchain(blockchain_rid);
    return container_blockchain @ { bc } .container.name;
}

/*
    Returns a list of brids with corresponding container that this blockchain is dependent on. At the given height.
    NM API Version: 3
*/
query nm_get_blockchain_dependencies(blockchain, height: integer): list<(byte_array, text)> {
    val res = list<(byte_array, text)>();
    val conf_h = blockchain_configuration @? { blockchain, .height <= height }
            (@sort .height) limit 1;
    if (conf_h != null) {
        val brids = blockchain_dependency @* {.me == blockchain, conf_h} .dependent_on.rid;
        for (brid in brids) {
            res.add((brid, container_blockchain @ { blockchain @{brid}} .container.name));
        }
    }
    return res;
}

/*
    Precise Configuration Update
    NM API Version: 5
*/
query nm_get_pending_blockchain_configuration(blockchain_rid: byte_array, height: integer):
        list<(base_config: byte_array, signers: list<pubkey>, minimum_height: integer)> {
    val bc = require_blockchain(blockchain_rid);
    return pending_blockchain_configuration @* { bc, .minimum_height <= height }
        (base_config=.base_config,
         signers=list<pubkey>.from_gtv(gtv.from_bytes(.signers)),
         @sort minimum_height=.minimum_height);
}
