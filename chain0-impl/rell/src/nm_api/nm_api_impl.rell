import ^.model.*;

/*
    Checking that signers.size() is non-zero is done when population blockchain_configuration_signers.
    Thus, not needed to check here.
*/
function get_blockchain_configuration_with_signers(blockchain, height: integer, config_height: integer) : byte_array {
    val (base_config, signers) = get_blockchain_configuration_and_signers(blockchain, height, config_height);
    val config_dict = map<text, gtv>.from_gtv(gtv.from_bytes(base_config));
    config_dict["signers"] = signers.to_gtv();
    return config_dict.to_gtv().to_bytes();
}

/*
    Checking that signers.size() is non-zero is done when population blockchain_configuration_signers.
    Thus, not needed to check here.
*/
function get_blockchain_configuration_and_signers(blockchain, height: integer, config_height: integer):
        (base_config: byte_array, signers: list<pubkey>) {
    val base_config = blockchain_configuration @ { blockchain, .height == config_height } (.data);
    return (base_config=base_config, signers=list<pubkey>.from_gtv(get_signers_for_configuration(blockchain, height)));
}

function get_cluster_node_blockchains(node) = set(
    (cluster_node, container_blockchain) @* {
        cluster_node.node == node,
        cluster_node.cluster == container_blockchain.container.cluster,
        container_blockchain.blockchain.active == true
    } ( blockchain_info(container_blockchain.blockchain.rid, container_blockchain.blockchain.system) )
);

function get_cluster_replica_node_blockchains(node) = set(
    (cluster_replica_node, container_blockchain) @* {
        cluster_replica_node.node == node,
        cluster_replica_node.cluster == container_blockchain.container.cluster,
        container_blockchain.blockchain.active == true
    } ( blockchain_info(container_blockchain.blockchain.rid, container_blockchain.blockchain.system) )
);

function get_blockchains_replicated_by_node(node) = set(
    blockchain_replica_node @* { node } (blockchain_info(.blockchain.rid, .blockchain.system))
);

function get_blockchain_replica_nodes(blockchain_rid: byte_array): set<byte_array> {
    val replicas = set<byte_array>();

    // cluster_replica_node
    val replica_nodes = (crn: cluster_replica_node, cb: container_blockchain) @* {
        cb.blockchain.rid == blockchain_rid,
        cb.container.cluster == crn.cluster
    } (.node.pubkey);
    replicas.add_all(replica_nodes);

    // blockchain_replica_node
    replicas.add_all(blockchain_replica_node @* { .blockchain.rid == blockchain_rid } (.node.pubkey));

    return replicas;
}