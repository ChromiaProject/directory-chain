import ^.anchoring_chain_common.*;
import ^.icmf.*;

@extend(after_anchoring_block) function process_configuration_updated(block_rid: byte_array, header: block_header) {
    if (not header.extra.contains("config_hash")) return;
    val new_config_hash = byte_array.from_gtv(header.extra["config_hash"]);
    val blockchain_rid = header.blockchain_rid;

    val last_anchored_block_header = anchor_block @? { blockchain_rid, .block_height < header.height } (@omit @sort_desc .block_height,
        block_header.from_gtv(gtv.from_bytes($.block_header))
    ) limit 1;
    val current_config_hash = if (last_anchored_block_header != null and last_anchored_block_header.extra.contains("config_hash"))
        byte_array.from_gtv(last_anchored_block_header.extra["config_hash"])
    else
        null;

    if (current_config_hash != null and new_config_hash != current_config_hash) {
        log("Updated configuration for %s at height %d to %s".format(blockchain_rid, header.height, new_config_hash));
        report_updated_configuration(header.blockchain_rid, header.height, new_config_hash);
    }
}

struct configuration_updated {
    blockchain_rid: byte_array;
    height: integer;
    config_hash: byte_array;
}

function report_updated_configuration(blockchain_rid: byte_array, height: integer, config_hash: byte_array) {
    send_message("configuration_updated",
        configuration_updated(blockchain_rid = blockchain_rid, height, config_hash = config_hash).to_gtv());
}
