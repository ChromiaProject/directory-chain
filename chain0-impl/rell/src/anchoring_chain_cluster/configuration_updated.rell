import ^.anchoring_chain_common.*;
import ^.icmf.*;

entity current_configuration {
    key blockchain_rid: byte_array;
    mutable config_hash: byte_array;
}

@extend(after_anchoring_block) function process_configuration_updated(block_rid: byte_array, header: block_header) {
    if (not header.extra.contains("config_hash")) return;
    val new_config_hash = byte_array.from_gtv(header.extra["config_hash"]);

    val current_config_hash = current_configuration @? { .blockchain_rid == header.blockchain_rid } (.config_hash);

    if (current_config_hash == null) {
        create current_configuration(blockchain_rid = header.blockchain_rid, config_hash = new_config_hash);
    } else if (new_config_hash != current_config_hash) {
        report_updated_configuration(header.blockchain_rid, header.height, new_config_hash);
        update current_configuration @ { .blockchain_rid == header.blockchain_rid } (.config_hash = new_config_hash);
    }
}

struct configuration_updated {
    blockchain_rid: byte_array;
    height: integer;
    config_hash: byte_array;
}

function report_updated_configuration(blockchain_rid: byte_array, height: integer, config_hash: byte_array) {
    send_message("configuration_updated",
        configuration_updated(blockchain_rid = blockchain_rid, height, config_hash = config_hash).to_gtv());
}
