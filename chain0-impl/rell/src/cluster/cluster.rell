import ^.config.*;

/**
 * Adding a node to a cluster automatically makes it signer of all bc in this cluster.
 * Only one node per provider and cluster.
 */
operation add_node_to_cluster(my_pubkey: pubkey, node_pubkey: pubkey, cluster_name: text) {
    val provider = require_provider(my_pubkey);
    require_provider_auth_with_rl(provider);
    val cluster = require_cluster(cluster_name);
    val node = require_node(node_pubkey);
    add_node_to_cluster_internal(provider, node, cluster);
}

operation add_replica_node_to_cluster(my_pubkey: pubkey, node_pubkey: pubkey, cluster_name: text) {
    val provider = require_provider(my_pubkey);
    require_provider_auth_with_rl(provider);
    val cluster = require_cluster(cluster_name);
    val node = require_node(node_pubkey);
    require(empty(cluster_replica_node @* { cluster, node }), "Node %s is already a replica of the cluster %s".format(node_pubkey, cluster_name));
    require(node.provider == provider, "It is only allowed to add own node as a container replica");
    require(empty(cluster_node @* { cluster, node }), "Node %s is a cluster node and can't be added to cluster %s as a replica node".format(node_pubkey, cluster_name));
    _add_replica_node_to_cluster_internal(cluster, node);
}

function _add_replica_node_to_cluster_internal(cluster, node) {
    create cluster_replica_node(cluster, node);
}

operation remove_replica_node_from_cluster(my_pubkey: pubkey, node_pubkey: pubkey, cluster_name: text) {
    val provider = require_provider(my_pubkey);
    require_provider_auth_with_rl(provider);
    val cluster = require_cluster(cluster_name);
    val node = require_node(node_pubkey);
    require(exists(cluster_replica_node @* { cluster, node }), "Node %s is not a replica of the cluster %s".format(node_pubkey, cluster_name));
    require(node.provider == provider, "It is only allowed to remove own container replica node");
    _remove_replica_node_from_cluster_internal(node);
}

function _remove_replica_node_from_cluster_internal(node) {
    delete cluster_replica_node @* { node };
}

/**
 * When all providers have provided a node each, cluster goes operational and stays operational even if a provider is added to the cluster
 */
function check_operational(cl: cluster) {
    val providers = cluster_provider @* { cl }.provider;
    val nodes = cluster_node @* { cl }.node;
    if (nodes.size() == providers.size()) {
        update cluster @ { cl.name } (.operational = true);
        after_cluster_operational(cl);
    }
}

/**
 * If a provider is part of that cluster, and if provider do not already have a node in this cluster,
 * add node as block signer to this cluster. blockchain_configuration_signers update is included.
 */
function add_node_to_cluster_internal(provider, node, cluster) {
    if (exists(cluster_node @? { cluster, node })) return; // Node already part of cluster
    if (exists(cluster_provider @* { cluster, provider })) {
        val provider_cluster_nodes = cluster_node @* { cluster, .node in node @* { provider } };
        require(empty(provider_cluster_nodes), "A provider can only provide one node to each cluster");
        create cluster_node(cluster, node);
        update_configuration_signers(cluster);
        _remove_replica_node_from_cluster_internal(node);
        // check if cluster now is operational, if so update the flag:
        check_operational(cluster);
        log("blockchain configuration signers are updated");

        after_node_added_to_cluster(cluster, node);
    }
}

// Use this to update signers after a change in cluster_node table.
function update_configuration_signers(cluster) {
    val bcs = container_blockchain @*{ .container.cluster == cluster} .blockchain;
    for (blockchain in bcs) {
        val container = container_blockchain @ {blockchain} .container;
        val signers = cluster_node @* { container.cluster } (@sort .node.pubkey);
        // do not write new configuration when size is 0 since it's impossible to recover from that
        require(signers.size() > 0);

        val is_chain0 = blockchain.rid == chain_context.blockchain_rid;

        if (is_chain0) {
            update_configuration_signers_chain0(blockchain, signers);
        } else if (pcu_enabled()) {
            update_configuration_signers_pcu(blockchain, signers);
        } else {
            update_configuration_signers_legacy(blockchain, signers);
        }
    }
}

function update_configuration_signers_chain0(blockchain, signers: list<pubkey>) {
    val height = op_context.block_height + 1;
    log("Signers update for chain0 at height %d: %s".format(height, signers));
    val bc_signers = blockchain_configuration_signers @? { blockchain, height };
    if (bc_signers == null) {
        create blockchain_configuration_signers(blockchain, height, signers.to_gtv().to_bytes());
    } else {
        bc_signers.signers = signers.to_gtv().to_bytes();
    }
}

function update_configuration_signers_pcu(blockchain, signers: list<pubkey>) {
    val last_signers_config = blockchain_configuration_signers @? { blockchain } (@sort_desc .height, .signers) limit 1;
    val last_signers_height = if (last_signers_config != null) last_signers_config.height else 0;
    val last_pending_configuration = pending_blockchain_configuration @? { blockchain } (@sort_desc @omit .minimum_height, $) limit 1;
    val (minimum_height, base_config, last_signers) = if (last_pending_configuration != null)
        (last_signers_height.max(last_pending_configuration.minimum_height) + 1,
         last_pending_configuration.base_config,
         last_pending_configuration.signers)
    else
        (last_signers_height + 1,
         blockchain_configuration @ { blockchain } (@omit @sort_desc .height, .data) limit 1,
         if (last_signers_config != null) last_signers_config.signers else x"");
    if (signers.to_gtv().to_bytes() == last_signers) {
        log("Signers update for chain %s not necessary, already %s".format(blockchain.rid, signers));
        return;
    }

    log("Signers update with PCU for chain %s at minimum height %d: %s".format(blockchain.rid, minimum_height, signers));
    val full_config = map<text, gtv>.from_gtv(gtv.from_bytes(base_config));
    full_config["signers"] = signers.to_gtv();
    create pending_blockchain_configuration(
        blockchain,
        minimum_height,
        config_hash=full_config.to_gtv().hash(),
        base_config,
        signers=signers.to_gtv().to_bytes()
    );
}

function update_configuration_signers_legacy(blockchain, signers: list<pubkey>) {
    val height = get_last_height(blockchain) + 5;
    log("Signers update without PCU for chain %s at height %d: %s".format(blockchain.rid, height, signers));
    val bc_signers = blockchain_configuration_signers @? { blockchain, height };
    if (bc_signers == null) {
        create blockchain_configuration_signers(blockchain, height, signers.to_gtv().to_bytes());
    } else {
        bc_signers.signers = signers.to_gtv().to_bytes();
    }
}

function require_cluster_available_for_removal(cluster) {
    require(cluster.name != clusters.system, "System cluster can't be deleted");
    require(
        empty(container @* { cluster, .system == false }),
        "Cluster %s is not empty and can't be deleted. Delete containers first".format(cluster.name)
    );
}

function get_cluster_for_blockchain(blockchain_rid: byte_array): cluster {
    return (container_blockchain, blockchain) @ { blockchain.rid == blockchain_rid, blockchain == container_blockchain.blockchain }
                 ( container_blockchain.container.cluster );
}

@extendable function after_cluster_operational(cluster) {}

@extendable function after_node_added_to_cluster(cluster, node) {}
