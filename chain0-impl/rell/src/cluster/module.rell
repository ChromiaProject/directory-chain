module;

import ^.model.*;
import ^.common.*;
import ^.model.util.constants.*;

function create_cluster_impl(me: provider, name, governor: voter_set, providers: list<pubkey>, max_containers: integer = -1, cpu: integer = -1, ram: integer = -1, storage: integer = -1) {
    require(empty(cluster @* { name }), "Cluster with name %s already exists".format(name));
    val c = create cluster(name, governor);
    create cluster_resource_limit(c, cluster_resource_limit_type.max_containers , max_containers);
    create cluster_resource_limit(c, cluster_resource_limit_type.default_container_max_blockchains, -1);
    create cluster_resource_limit(c, cluster_resource_limit_type.default_container_cpu, cpu);
    create cluster_resource_limit(c, cluster_resource_limit_type.default_container_ram, ram);
    create cluster_resource_limit(c, cluster_resource_limit_type.default_container_storage, storage);
    for (p_key in providers) {
        val provider = require_provider(p_key);
        require_node_access(provider);
        create cluster_provider(c, provider);
    }

    create_system_container(
        me,
        system_container_name(c.name),
        cluster = c,
        voter_set = governor
    );

    after_cluster_creation(me, c);
    return c;
}

@extendable function after_cluster_creation(provider, cluster) {}

function require_cluster_quotas(cluster) {
    val max_containers = cluster_resource_limit @? { cluster, cluster_resource_limit_type.max_containers } (.value);
    if (max_containers != null and max_containers != -1) {
        val cluster_container_count = container @ { cluster, .system == false } (@sum 1);
        require(cluster_container_count < max_containers, "Can't propose container, cluster %s is full".format(cluster.name));
    }
}
