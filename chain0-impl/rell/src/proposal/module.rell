module;

import ^.common.*;
import .voting.*;

enum proposal_type {
    other,
    configuration_at,
    configuration,
    bc,
    container_limits,
    cluster_limits,
    cluster_provider,
    cluster_remove,
    voter_set_update,
    provider_state,
    provider_is_system,
    provider_quota,
    provider_batch,
    provider_remove,
    blockchain_action,
    cluster_anchoring_configuration,
    container,
    container_remove
    // and a lot more
}

entity proposal {
    index timestamp, proposal_type;
    proposed_by: provider;
    index voter_set;
    description: text = "";
}

operation revoke_proposal(my_pubkey: pubkey, proposal_rowid: rowid) {
    val me = require_is_provider_with_rate_limit(my_pubkey);
    require_provider_auth_with_rate_limit(me);
    val prop = proposal @? { proposal_rowid };
    require(exists(prop), "Proposal not found: %d".format(proposal_rowid));
    require(prop!!.proposed_by == me, "It is only allowed to revoke own proposals");
    delete_proposal(prop);
}

function delete_proposal(prop: proposal) {
    require(prop.proposal_type != proposal_type.other, "Proposal of type 'other' is not allowed");
    delete_proposal_handlers()[prop.proposal_type.name](prop);
    delete vote @* { .proposal == prop };
    delete proposal @ { .rowid == prop.rowid };
}

@extendable function delete_proposal_handlers(): map<text, (proposal) -> unit>;