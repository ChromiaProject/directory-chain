query get_proposals_since(since: rowid) {
    return proposal @* { .rowid >= since } (.rowid, .proposal_type);
}

query get_relevant_proposals(my_pubkey: pubkey, since: rowid) {
    return (proposal, voter_set_member) @* {
        voter_set_member.voter_set == proposal.voter_set,
        voter_set_member.provider.pubkey == my_pubkey,
        proposal.rowid >= since
    } (proposal.rowid, proposal.proposal_type);
}

query get_proposal(id: rowid?): (id: rowid, timestamp: integer, type: proposal_type, proposed_by: pubkey, description: text)? {
    val result = if (id == null) proposal @? {} (@sort_desc @omit .rowid, $) limit 1 else proposal @? { id };
    if (result == null) return null;
    return (
        id = result.rowid,
        timestamp = result.timestamp,
        type = result.proposal_type,
        proposed_by = result.proposed_by.pubkey,
        description = result.description
    );
}

function require_proposal(rowid) = require(proposal @? { rowid }, "Proposal " + rowid + " not found");

query get_cluster_provider_proposal(rowid?) {
    val proposal = get_latest_proposal(rowid, proposal_type.cluster_provider);
    if (proposal == null) return null;
    val pcp = pending_cluster_provider @ { proposal };
    return (
        cluster = pcp.cluster.name,
        provider = pcp.provider.pubkey,
        add = pcp.add
    );
}

query get_container_limits_proposal(rowid) {
    val proposal = get_latest_proposal(rowid, proposal_type.container_limits);
    if (proposal == null) return null;
    val pcl = pending_container_limits @ { proposal };
    return (
        container = pcl.container.name,
        max_blockchains = pcl.max_blockchains,
        cpu = pcl.cpu,
        ram = pcl.ram,
        storage = pcl.storage,
        io_read = pcl.io_read,
        io_write = pcl.io_write
    );
}

query get_cluster_limits_proposal(rowid) {
    val proposal = get_latest_proposal(rowid, proposal_type.cluster_limits);
    if (proposal == null) return null;
    val pcl = pending_cluster_limits @ { proposal };
    return (
        cluster = pcl.cluster.name,
        max_containers = pcl.max_containers,
        default_container_max_blockchains = pcl.default_container_max_blockchains,
        default_container_cpu = pcl.default_container_cpu,
        default_container_ram = pcl.default_container_ram,
        default_container_storage = pcl.default_container_storage,
        default_container_io_read = pcl.default_container_io_read,
        default_container_io_write = pcl.default_container_io_write
    );
}

query get_cluster_remove_proposal(rowid) {
    val proposal = get_latest_proposal(rowid, proposal_type.cluster_remove);
    if (proposal == null) return null;
    return pending_remove_cluster @ { proposal } .cluster.name;
}

function get_latest_proposal(rowid?, proposal_type) = if (rowid == null) proposal @ { proposal_type } ( @max proposal ) else proposal @ { rowid };

struct proposal_voting_results {
    positive_votes: integer;
    negative_votes: integer;
    max_votes: integer;
    threshold: integer;
    voting_result;
}

query get_proposal_voting_results(rowid): proposal_voting_results {
    val proposal = require_proposal(rowid);
    val positive_votes = positive_votes(proposal);
    val negative_votes = negative_votes(proposal);
    val max_votes = max_votes(proposal.voter_set);
    val threshold = proposal.voter_set.threshold;
    val status = _compute_voting_result(positive_votes, negative_votes, max_votes, threshold);
    return proposal_voting_results(positive_votes, negative_votes, max_votes, threshold, status);
}
