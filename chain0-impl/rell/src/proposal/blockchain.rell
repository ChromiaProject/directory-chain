import ^.config.*;

/*
 * Proposes a new blockchain to a container.
 * NB: only the deployer voter set of the container can do this.
 */
//Who can propose a new blockchain? The container deployer voter set
operation propose_blockchain(my_pubkey: pubkey, config_data: byte_array, bc_name: text, container_name: text, description: text = "") {
    val me = require_is_provider_with_rl(my_pubkey);
    val container = require_container(container_name);
    require_container_deployer(container, me);

    validate_blockchain_configuration(config_data, signers=true, header_hash=pcu_enabled());

    // Require container resource limits are honored
    val max_blockchains = container_resource_limit @ { container, container_resource_limit_type.max_blockchains } (.value);
    if (max_blockchains > 0) {
        val container_dapps_count = container_blockchain @* { container } (@sum 1)[0];
        require(container_dapps_count < max_blockchains, "Can't propose blockchain, container %s is full".format(container_name));
    }

    // If already proposed, do not add again.
    if (empty(pending_blockchain @* {.data == config_data } limit 1)) {
        val prop = create proposal(op_context.last_block_time, proposal_type.bc, me, container.deployer, description);
        create pending_blockchain(prop, bc_name, config_data, container);
        internal_vote(me, prop, true);
    }
}

operation propose_configuration(my_pubkey: pubkey, blockchain_rid: byte_array, config_data: byte_array, description: text = "") {
    val me = require_is_provider_with_rl(my_pubkey);
    val blockchain = require_blockchain(blockchain_rid);
    val container = container_blockchain @ {blockchain} .container;
    require_container_deployer(container, me);
    val is_chain0 = blockchain.rid == chain_context.blockchain_rid;

    validate_blockchain_configuration(config_data, signers=not is_chain0, header_hash=pcu_enabled() and not is_chain0);

    val prop = create proposal(op_context.last_block_time, proposal_type.configuration, me, container.deployer, description);
    create pending_configuration(prop, blockchain, config_data);
    internal_vote(me, prop, true);
}

/*
 * Proposes a new configuration for a blockchain.
 * NB: Only the deployer of the container the blockchain is running in can perform operation
 */
operation propose_configuration_at(my_pubkey: pubkey, blockchain_rid: byte_array, config_data: byte_array, height: integer, force: boolean, description: text = "") {
    val me = require_is_provider_with_rl(my_pubkey);
    val blockchain = require_blockchain(blockchain_rid);
    val container = container_blockchain @ { blockchain }.container;
    require_container_deployer(container, me);
    val is_chain0 = blockchain.rid == chain_context.blockchain_rid;

    validate_blockchain_configuration(config_data, signers=not is_chain0, header_hash=false);

    val last_height = get_last_height(blockchain);
    val cant_apply_message = "Height (%d) must be greater than current height (%d)".format(height, last_height);
    if (force) {
        if (height != -1) {
            require(last_height < height, cant_apply_message);
        }
    } else {
        require(last_height < height, cant_apply_message);
        require(empty(blockchain_configuration @? { blockchain, height } limit 1), "Configuration at height %d already exists for blockchain %s".format(height, blockchain_rid));
    }

    val pending_config = pending_configuration_at @? { blockchain, height } limit 1;
    require(empty(pending_config),
        "Pending configuration proposal already exists: blockchain_rid: %s, height: %d. Revoke the proposal %d first."
            .format(blockchain.rid, height, pending_config?.proposal)
    );

    val prop = create proposal(op_context.last_block_time, proposal_type.configuration_at, me, container.deployer, description);
    create pending_configuration_at(prop, blockchain, height, force, data = config_data);
    internal_vote(me, prop, true);
}

operation propose_blockchain_action(my_pubkey: pubkey, blockchain_rid: byte_array, action: blockchain_action, description: text = "") {
    val me = require_is_provider_with_rl(my_pubkey);
    val blockchain = require_blockchain(blockchain_rid);
    val container = container_blockchain @ {blockchain} .container;
    require_container_deployer(container, me);
    val prop = create proposal(op_context.last_block_time, proposal_type.blockchain_action, me, container.deployer, description);
    create pending_blockchain_action(prop, blockchain, action);
    internal_vote(me, prop, true);
}

function validate_blockchain_configuration(config_data: byte_array, signers: boolean, header_hash: boolean) {
    val config_map = map<text, gtv>.from_gtv(gtv.from_bytes(config_data));
    if (signers) {
        require("signers" not in config_map, "Configuration must not contain \"signers\"");
    }
    if (header_hash) {
        require("config_consensus_strategy" in config_map,
            "Configuration must contain \"config_consensus_strategy\"=\"HEADER_HASH\"");
        require(config_map["config_consensus_strategy"] == "HEADER_HASH".to_gtv(),
            "Configuration must contain \"config_consensus_strategy\"=\"HEADER_HASH\"");
    }
}
